<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap" rel="stylesheet">
    <title>ARDIST - Thule</title>
    <style>
        
        body {
          font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
            background-color: #E8E3C4;
            color: #35100B;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
    max-width: 1763px; /* Increased from 1200px - 25% wider */
    width: 100%;
}
        
        h2 {
            color: #8b4513;
            margin-bottom: 5px;
        }
        
        p {
            margin-top: 5px;
            margin-bottom: 15px;
        }
        
        /* Synth panel styling */
        /* Update the synth-panel class */
        .synth-panel {
  display: flex;
  flex-direction: row;
  gap: 2px;
  background-color: #f2eed3;
  border: 2px solid #35100B;
  border-radius: 5px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  overflow-x: auto;
  align-items: stretch; /* Ensures same height for all modules */
}
        
        .module {
    background-color: #f2eed3;
    border: 1px solid #35100B;
    border-radius: 5px;

    display: flex;
    flex-direction: column;
    width: 80px; /* Fixed width, reduced by ~30% from original */
    min-width: 80px; /* Same as width to prevent resizing */
    max-width: 80px; /* Same as width to prevent resizing */
}
        
        .module-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #35100B;
        }
        .wave-select-container {
    position: relative;
    width: 100%;
    margin: 10px 0;
}
/* Updated Module title for sampler */
.sampler {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 5px;
  background-color: #BA5446; /* Same color as LFO */
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px; /* Pull it up slightly to connect with top edge */
}

/* Make sampler module match LFO module styling */
.sampler-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 139px;
  max-width: 139px;
  align-items: center;
  padding-top: 15px; /* Remove top padding */
  overflow: hidden; /* Ensure the header connects to edges */
  box-sizing: border-box; /* Include padding in width */
}

/* Update sample columns layout */
.sampler-columns {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: 116%;
  margin-top: 10px; /* Reduced from 20px */
  gap: 0px; /* Add small gap between columns */
}

/* Make columns narrower with less space */
.sampler-column {
  width: 150%; /* Slightly narrower */
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0px; /* Add consistent spacing between elements */
}

/* Improve knob container spacing */
.knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 9px 0; /* Reduced from 10px */
}

/* Update knobs to match LFO knobs */
.sampler-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #BA5446;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  
  /* Double border effect - EXACT match to LFO depth knob */
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;
  
  /* Center point marker */
  transform-origin: center center;
}

.sampler-module #sample-start-knob{
  border: 0.5px solid #000000;
  background-color: #4E658B;
  box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;
}

.sampler-module #sample-end-knob{
  border: 0.5px solid #000000;
  background-color: #4E658B;
  box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;
}

.sampler-module #sample-crossfade-knob{
  border: 0.5px solid #000000;
  background-color: #6B8F53;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
}
.sampler-module #sample-fade-knob{
  border: 0.5px solid #000000;
  background-color: #6B8F53;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
}

/* Style knob indicator lines to match LFO */
.sampler-module .knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px; /* Longer line from center to edge */
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg); /* Center at origin */
}

/* Update labels to match LFO style */
.knob-container label, 
.switch-container label,
.lofi-button-container label,
.rec-button-container label {
  margin-top: -3.5px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}

/* New simplified CSS for file input */
.sample-selector-container {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  margin: 5px 0;
}
.sample-selector-container label {
  color: #f2eed3;
}
.hidden-file-input {
  width: 0.1px;
  height: 0.1px;
  opacity: 0;
  overflow: hidden;
  position: absolute;
  z-index: -1;
}

.custom-file-button {
  background-color: #4E658B;
  border: 2.5px solid #35100B;
  border-radius: 5px;
  padding: 8px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  line-height: 0.7;
  color: #35100B;
  height: 21px;
  width: 45.57px;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}

.custom-file-button:hover {
  background-color: #597097;
  cursor: pointer;
}

.custom-file-button:active {
  background-color: #3b5174;
  box-shadow: inset 0px 2px 5px rgba(0, 0, 0, 0.244);
}

#sample-selector-btn {
  background-color: #4E658B;
  border: 2.5px solid #35100B;
  border-radius: 5px;
  padding: 8px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  line-height: 0.9;
  color: #35100B;
  cursor: pointer;
  height: 21px; /* Match height of other buttons */
  width: 45.57px;
  box-sizing: border-box;
  transition: background-color 0.2s, box-shadow 0.2s;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 5px; /* Add spacing below */
  margin-top: 5px; /* Add spacing above */
}

#sample-selector-btn:hover {
  background-color: #597097;
}

#sample-selector-btn:active {
  background-color: #3b5174;
  box-shadow: inset 0px 2px 5px rgba(0, 0, 0, 0.244);
}
#sample-selector-btn label {

  color: #f2eed3;

}
/* Fix dropdown styling */
.sample-dropdown {
  display: none;
  position: absolute;
  z-index: 10;
  width: 81%;
  top: 100%; /* Position below button */
  left: 6px;
  border: 1px solid #35100B;
  background-color: #4E658B;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  margin-top: 2px;
}
.sample-dropdown.show {
  display: block;
}
.dropdown-item {
  padding: 8px;
  border-radius: 5px;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  line-height: 0.9;
  color: #f2eed3;
  cursor: pointer;
}

.dropdown-item:hover {
  background-color: #5a739a;
}

/* Update Lo-Fi and Rec buttons to match Select button in LFO */
.lofi-button,
.rec-button {
  position: relative;
  width: 41px;
  height: 21px;
  background-color: #6B8F53; /* Default background color */
  border: 2.5px solid #35100B;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  margin-bottom: 5px;
  transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
  color: #35100B;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
}

.lofi-button:hover,
.rec-button:hover {
  background-color: #729759;
}

/* Active/ON state - solid color with glow effect */
.lofi-button.active,
.rec-button.recording {
  background-color: #7da263; /* Solid color when active */
  color: #f2eed3; /* White text when active */
  box-shadow: 0 0 15px #9ec681; /* Glow effect */
  transform: scale(0.98); /* Slight pressed effect */
}

/* Remove the LED elements */
.lofi-button .select-led,
.rec-button .select-led {
  display: none;
}
.rec-button {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.rec-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.rec-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.rec-button.active .icon,
.rec-button.recording .icon {
  filter: invert(24%) sepia(84%) saturate(7343%) hue-rotate(357deg) brightness(98%) contrast(116%);
}
.lofi-button {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.lofi-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.lofi-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.lofi-button.active .icon {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}
#sample-selector-btn {

  color: #f2eed3; /* Changed from #35100B to #f2eed3 */

}
/* Normalize title styles */
.module-title.sampler {
  margin-bottom: 0;
}
.tooltip {
    position: absolute;
    background: #35100bcf;
    color: #f2eed3;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s;
}
/* Style for options */
.wave-select option {
    background-color: #f2eed3;
    color: #35100B;
    padding: 8px;
}
        /* Sliders and knobs */
        .knob {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    background-color: #f2eed3;
    border: 1px solid #35100B;
    position: relative;
    margin: 10px auto;
    box-sizing: border-box;
    cursor: grab;
    transform-origin: center center;
    transition: transform 0.05s ease-out;
}

.knob:active {
    cursor: grabbing;
}

.knob::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 3px;    /* Changed from 3px to 2px for consistency */
    height: 14px;   /* Changed from 14px to 10px for consistency */
    background-color: #35100B;
    transform-origin: bottom center;
    transform: translateX(-50%);
}
        
.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    height: 120px;
    margin: 0 10px;
}

.slider-container label {
    font-size: 12px;
    color: #35100B;
    margin-top: 10px;
}

.slider-container input[type="range"] {
    width: 100px;
    height: 30px;
    background: transparent;
    transform: rotate(270deg) translate(-35px, 35px);
}

.slider-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #f2eed3;
    border: 1px solid #35100B;
    cursor: grab;
    margin-top: -12px;
}

.slider-container input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #f2eed3;
    border: 1px solid #35100B;
    border-radius: 2px;
}

.slider-container span {
    font-size: 12px;
    color: #35100B;
    margin-top: 5px;
}
        
        /* Radio button group styling */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 10px 0;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        /* Keyboard responsive resizing */
.keyboard {
    display: flex;
    width: 100%;
    position: relative;
    background-color: #f2eed3;
    border: 2px solid #35100B;
    border-radius: 5px;
    /* Create an aspect ratio container */
    aspect-ratio: 4 / 1; /* Width:Height ratio for the keyboard */
    max-height: 190px; /* Maximum height */
    margin-top: 20px;
    overflow: hidden;
}

.key {
    flex: 1;
    height: 100%;
    background-color: #f2eed3;
    border: 1px solid #35100B;
    cursor: pointer;
    position: relative;
    user-select: none;
    margin: 0;
    padding: 0;
}

.key.black {
    background-color: #35100B;
    position: absolute;
    width: 7%; /* Relative width instead of fixed pixels */
    height: 60%; /* Height relative to keyboard height */
    z-index: 1;
    border: none;
    transform: translateX(-50%);
    max-width: 5.5%; /* Maximum width for larger screens */
}

/* Update black key positioning calculations */
.key.black:nth-of-type(15) { left: calc(100% * 1/14); }   /* C# */
.key.black:nth-of-type(16) { left: calc(100% * 2/14); }   /* D# */
.key.black:nth-of-type(17) { left: calc(100% * 4/14); }   /* F# */
.key.black:nth-of-type(18) { left: calc(100% * 5/14); }   /* G# */
.key.black:nth-of-type(19) { left: calc(100% * 6/14); }   /* A# */
.key.black:nth-of-type(20) { left: calc(100% * 8/14); }   /* C# (second octave) */
.key.black:nth-of-type(21) { left: calc(100% * 9/14); }   /* D# (second octave) */
.key.black:nth-of-type(22) { left: calc(100% * 11/14); }  /* F# (second octave) */
.key.black:nth-of-type(23) { left: calc(100% * 12/14); }  /* G# (second octave) */
.key.black:nth-of-type(24) { left: calc(100% * 13/14); }  /* A# (second octave) */
/* Add a responsive adjustment for small screens */
@media (max-width: 768px) {
    .keyboard {
        max-height: 150px; /* Smaller maximum height on small screens */
    }
    
    .key.black {
        width: 8%; /* Slightly wider on small screens for better touch targets */
    }
}

/* For very small screens */
@media (max-width: 480px) {
    .keyboard {
        max-height: 120px; /* Even smaller on very small screens */
    }
}
/* Make sure the black keys overflow is visible */

.key.pressed {
    background-color: #E8E3C4;
}

.key.black.pressed {
    background-color: #4A261D;
}
        
        /* Voice monitoring */
        .voice-monitor {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #35100B;
            border-radius: 4px;
            background-color: #f2eed3;
        }
        
        .voice-item {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            background-color: #f2eed3;
            border-radius: 3px;
            border: 1px solid #35100B;
        }
        
        .active-voice {
            background-color: #8b4513;
            color: white;
        }
        


        
        

        
body {
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.adsr-graph {
    width: 100%;
    height: 100px;
    min-height: 100px;
    background-color: #f2eed3;
    margin: 10px 0;

    position: relative;
    overflow: hidden; /* Prevent overflow */
}
/* Make ADSR module match LFO/SAMPLER module styling */
.module[style="grid-column: span 2;"] {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 169px;
  max-width: 169px;
  align-items: center;
  padding-top: 15px; /* Remove top padding */
  overflow: hidden; /* Ensure the header connects to edges */
  box-sizing: border-box; /* Include padding in width */
}

.adsr-graph {
  width: 90%;
  height: 70px;
  background-color: #35100B;
  margin: 15px 0 15px 0;
  position: relative;
  border: 2px solid #35100B;
  border-radius: 5px;
}

/* Values row */
.slider-values {
    display: flex;
    justify-content: space-between;
    width: 220px; /* Match slider group width */
    margin-bottom: 5px;
}

.slider-values span {
    font-size: 12px;
    color: #35100B;
    width: 40px;
    text-align: center;
}

.slider-group {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  width: 90%;
  margin: 0;
  gap: 8px;
}



.slider-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 18px;
  height: 26px;
  cursor: pointer;
  bottom: 10px;
  border-radius: 5px;
  /* Add indicator line like LFO sliders */
  background-image: linear-gradient(to top, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 2px 100% ;
  background-repeat: no-repeat;
  background-position: center;
margin-top: -10.6px;
}

/* ADSR slider tracks */
.slider-group input[type="range"]::-webkit-slider-runnable-track {
  background: #35100B;
  border-radius: 5px;
  height: 5px;
  border: none;
}

/* Labels row */
.slider-labels {
    display: flex;
    justify-content: space-between;
    width: 220px;
    margin-top: -10px;
}

.slider-labels label {
    font-size: 12px;
    color: #35100B;
    width: 40px;
    text-align: center;
}
.module-title.adsr {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 5px;
  background-color: #BA5446; /* Same color as LFO/SAMPLER */
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px; /* Pull it up slightly to connect with top edge */
}
/* ADSR container styles */
.module[style="grid-column: span 2;"] {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 159px;
  max-width: 159px;
  align-items: center;
  padding-top: 15px; /* Remove top padding */
  overflow: hidden; /* Ensure the header connects to edges */
  box-sizing: border-box; /* Include padding in width */
}


/* Individual slider containers */
.slider-attack, .slider-decay, .slider-sustain, .slider-release {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 22%;
}

/* Common slider styles */
.slider-group input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 241px;
  height: 5px; /* Thinner track like LFO */
  background: transparent;
  transform: rotate(270deg);
  position: absolute;
  top: 135px;
}

/* Values above sliders */
#attack-value, #decay-value, #sustain-value, #release-value {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-weight: 750;
  font-variant-caps: all-small-caps;
  color: #35100B;
  width: 25px; /* Fixed width */
  text-align: center;
  display: block;
  margin: 0 auto 5px auto;
  height: 12px; /* Fixed height */
  overflow: hidden; /* Prevent overflow */
}

/* Labels below sliders */
.slider-labels {
  display: flex;
  justify-content: space-between;
  width: 90%;
  margin-top: 244px;
}

.slider-labels label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-weight: 750;
  font-variant-caps: all-small-caps;
  color: #35100B;
  text-align: center;
  width: 22%;
}

/* Slider group containing all sliders */




/* Add vertical switch styling */
.switch-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px 0;
}

.switch-label {
    font-size: 10px;
    margin-bottom: 5px;
    color: #35100B;
    text-align: center;
}



/* Mono controls container */
.mono-controls {
    width: 100%;
    transition: opacity 0.3s;
}

.legato-controls {
    width: 100%;
    transition: opacity 0.3s;
}


/* Module title */
.lfo {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 5px;
  background-color:  #4E658B;
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;

  margin-top: -15px; /* Pull it up slightly to connect with top edge */
}
/* LFO Module container */
.LFO-Module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 169px;
  max-width: 169px;
  align-items: center;
  padding-top: 15px; /* Remove top padding */
  overflow: hidden; /* Ensure the header connects to edges */
  box-sizing: border-box; /* Include padding in width */
}
/* Add flex: none to prevent unwanted stretching */
.synth-panel > div {
  flex: none;
}
/* Main controls container (sliders + buttons) */
.lfo-controls-container {
  display: flex;
  width: 87%;
  justify-content: space-between;
  height: 240px; /* Match your original height */
  padding-top: 7%;
  margin-bottom: -25px;
  margin-right: 30px;
  padding-top: 0px;
  margin-top: -29px;
}

/* Left container for vertical sliders */
.lfo-sliders-container {
  position: relative;
  display: flex;
  gap: 25px; /* Reduced from 25px to make space for tick marks */
  height: 85%;
  margin-left: 20px; /* Reduced from 10% */
  margin-right: 15px; /* Add right margin to prevent overlap */
  top: 10px;
}
.filter-slider-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  bottom: -20px;
  left: 50%; /* Center relative to parent */
  transform: translateX(-50%); /* Perfect centering */
  right: auto; /* Remove the right offset that was causing misalignment */
}
.filter-sliders-container .slider-tick-container {
  position: relative;
  width: 15px; /* Set explicit width */
  display: flex;
  flex-direction: column;
  align-items: center;
}
/* Vertical sliders: Rate and Delay */
.rate-slider-range,
.delay-slider-range {
  -webkit-appearance: none;
  appearance: none;
  width: 5px; /* Thin track (matches the horizontal slider track height) */
  height: 100%;
  background: transparent;
  writing-mode: vertical-lr; /* Modern vertical orientation */
  direction: rtl; /* Bottom to top orientation */
}

.lfo-destination-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: 82%;
  margin-top: 2px;
  position: relative;
  top: 30px;
}

/* Vertical destination range slider */
.lfo-destination-range {
  -webkit-appearance: none;
  appearance: none;
  width: 20px; /* Make the slider wider than standard */
  height: 100%;
  background: transparent;
  writing-mode: vertical-lr;
  direction: rtl; /* Bottom to top orientation */
  margin-left: 5px;
  margin-right: 15px;
}

/* Custom track styling */
.lfo-destination-range::-webkit-slider-runnable-track {
  width: 10px; /* Keep the width */
  height: 100%; /* Use full height without the calculation */
  background: #35100B;
  border-radius: 8px;
}

/* Ticks container positioned to the right of the slider */
.lfo-destination-ticks {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 65%;
  margin-left: -11px;
  margin-bottom: 56px;
  pointer-events: none; /* Don't block interaction */
}

/* Individual tick with label container */
.tick-with-label {
  display: flex;
  align-items: center;
  height: calc(100% / 9);
}

/* Tick mark styling */
.tick {
  width: 5px;
  height: 1.9px;
  background-color: #35100B;
}

/* Label styling */
.tick-label {
  margin-left: 5px;
  font-size: 10px;
  white-space: nowrap;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  margin-bottom: 1.6px;
  color: #35100B;
}
.lfo-selector-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 7px;
}

/* Horizontal five-step selector */
.five-step-selector-range {
  -webkit-appearance: none;
  appearance: none;
  width: 100px;
  height: 14px;
  background: transparent;
  margin: 0;
  padding: 0;
}

/* Shared slider track styling - make tracks thinner */
.rate-slider-range::-webkit-slider-runnable-track,
.delay-slider-range::-webkit-slider-runnable-track {
  background: #35100B;
  border-radius: 5px;
  width: 5px; /* For vertical sliders (needed for proper appearance) */
  border: none;
}
.five-step-selector-range::-webkit-slider-runnable-track{
  background: #35100B;
  border-radius: 5px;
  height: 10px; /* For horizontal slider */
  border: none;
}


.five-step-selector-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 18px;
  height: 24px;
  cursor: pointer;
  margin-top: -6.7px; /* For horizontal slider */
  border-radius: 5px;
      /* Optional: Add a small indicator line */
      background-image: linear-gradient(to top, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center;
}
.rate-slider-range::-webkit-slider-thumb,
.delay-slider-range::-webkit-slider-thumb {
  -webkit-appearance: none;

  background: #35100B;
  width: 26px;
  height: 18px;
  cursor: pointer;
  margin-left: -10.6px; /* For vertical sliders */
  border-radius: 5px; /* Remove circular shape to make rectangular */
    /* Optional: Add a small indicator line */
    background-image: linear-gradient(to right, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}
/* Firefox versions */
.five-step-selector-range::-moz-range-track,
.rate-slider-range::-moz-range-track,
.delay-slider-range::-moz-range-track {
  background: #35100B;
  border-radius: 5px;
  height: 5px;
  width: 5px;
}

/* Firefox versions */
.five-step-selector-range::-moz-range-thumb,
.rate-slider-range::-moz-range-thumb,
.delay-slider-range::-moz-range-thumb,
.lfo-destination-range::-moz-range-thumb {
  background: #f2eed3;
  border: 2px solid #35100B;
  width: 18px;
  height: 24px;
  cursor: pointer;
  border-radius: 5px;
}

.lfo-destination-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 24px; /* Make it wider than the track */
  height: 26px; /* Make it taller */
  cursor: pointer;
  border-radius: 5px; /* Rectangular shape with rounded corners */
  
  /* Center it on the track */
  margin-left: -6.8px; 
  
  /* Add a subtle shadow for depth */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  
  /* Optional: Add a small indicator line */
  background-image: linear-gradient(to right, #f2eed3 30%, transparent 30%, transparent 70%, #f2eed3 70%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}

/* Firefox version */
.lfo-destination-range::-moz-range-thumb {
  appearance: none;
  background: #f2eed3;
  border: 2px solid #35100B;
  width: 24px;
  height: 26px;
  cursor: pointer;
  border-radius: 5px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  background-image: linear-gradient(to right, #35100B 30%, transparent 30%, transparent 70%, #35100B 70%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}
.slider-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  right: 5px;
  top: 148px;
}

/* Position the slider containers correctly to make room for labels */
.slider-tick-container {
  position: relative;

}
.five-step-ticks {
  display: flex;
  justify-content: space-between;
  width: 102.2px; /* Match the width of the slider */
  margin-top: 7px;
  padding: 0;
  position: relative;
}

/* Individual tick container - space them out evenly */
.five-step-ticks .tick-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 20px;
  position: relative; /* Add position relative to container */
}

/* Make the ticks thinner and taller */
.five-step-ticks .tick {
  width: 1.7px;
  height: 8px;
  background-color: #35100B;
  margin-bottom: 4px;
}

/* Adjust the labels */
.five-step-ticks .tick-label {
  position: relative;
  font-size: 8px;
  color: #35100B;
  text-align: center;
  white-space: nowrap;
  margin-top: 2px;
  width: 102.2px;
  right: 2.8px;
}
/* Wave shape class for the SVG icons - replace your CSS wave shape implementations */
.wave-shape {
  height: 14px;
  width: 18px;
  position: relative;
  display: inline-block;
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%)
}

.wave-shape img {
  max-width: 100%;
  max-height: 100%;
  display: block;
}
.destination-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  bottom: -17px;
  margin-left: -4px;
  right: 16px;

}
/* Container for bottom row controls */
.lfo-bottom-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-top: 13px;
  padding: 0 5px;
}

/* Depth Knob with double border */
.depth-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-right: 10px;
  margin-left: 10px;
}

.depth-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #4E658B;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  
  /* Double border effect */
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;
  
  /* Center point marker */
  transform-origin: center center;
}

/* Special tick style for depth knob - starts from center */
.depth-knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px; /* Longer line from center to edge */
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg); /* Center at origin */
}

.depth-knob-container label {
  margin-top: 8px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
}

/* Select button styling - make it square and match panel color */
.select-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
margin-top: 26px;
margin-bottom: 18px;
}

.select-button {
  position: relative;
  width: 41px; /* Match the knob width for consistency */
  height: 41px; /* Perfect square */
  background-color: #6B8F53; /* Match the synth panel color */
  border: 2.5px solid #35100B;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  margin-top: -3px;
  margin-bottom: 0px; /* Add space for label below */
  transition: background-color 0.2s, box-shadow 0.2s;
  margin-right: -10px;
  right: 5px;
}

.select-button:hover {
  background-color: #729759; /* Slightly darker on hover */
}

.select-button.active {
  background-color: #7da263;
  box-shadow: 0 0 8px #9ec681; /* Glow effect */
  transform: scale(0.98); /* Slight pressed effect */
}

/* Add icon styling */
.select-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.select-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.select-button.active .icon {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}

/* Remove the LED */
.select-button .select-led {
  display: none;
}

/* Add label under select button */
.select-button-container label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}
/* Styles for the additional buttons */
.reverse-button,
.keytrack-button {
  position: relative;
  width: 41px;
  height: 21px;
  background-color: #BA5446;
  border: 2.5px solid #35100B;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  margin-bottom: 5px;
  transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
  color: #35100B;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
}

.reverse-button:hover,
.keytrack-button:hover {
  background-color: #b85f53;
}

.reverse-button.active,
.keytrack-button.active {
  background-color: #d15f50;
  color: #f2eed3;
  box-shadow: 0 0 15px rgba(218, 92, 75, 0.7); /* Glow effect */
  transform: scale(0.98); /* Slight pressed effect */
}

/* Hide LEDs in these buttons too */
.reverse-button .select-led,
.keytrack-button .select-led {
  display: none;
}
.reverse-button {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.reverse-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.reverse-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.reverse-button.active .icon {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}
.keytrack-button {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.keytrack-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.keytrack-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.keytrack-button.active .icon {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}
/* Update Master Module Styling */
.module-title.master {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 9px;
  background-color: #BA5446; /* Same color as LFO/SAMPLER */
  padding: 5px 0;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px; /* Pull it up slightly to connect with top edge */
}

/* Make master module match LFO/SAMPLER module styling */
.module.master-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 75px;
  max-width: 75px;
  align-items: center;
  padding-top: 15px; /* Remove top padding */
  overflow: hidden; /* Ensure the header connects to edges */
  box-sizing: border-box; /* Include padding in width */
}

.vertical-switch {
  width: 20px;
  height: 40px;
  background: #E5AB5F;
  border: 2px solid #35100B;
  border-radius: 5px;
  position: relative;
  cursor: grab;
  margin-bottom: 5px;
  
}

.vertical-switch::after {
  content: '';
  position: absolute;
  width: 19px;
  height: 19.5px;
  background: #35100B;
  border: 1px solid #35100B;
  border-radius: 0px;
  left: -0.5px;
  top: 0px;
  transition: top 0.1s;
  
  /* Add the on.svg overlay as a background image */
  background-image: url("control icons/on.svg");
  background-position: center;
  background-repeat: no-repeat;
  background-size: 12px 12px; /* Adjust size to fit inside the handle */
  
  /* Filter to make the icon white */
}

.vertical-switch.active::after {
  top: 19px;
}
/* Add this CSS class for the porta button container */
.porta-button-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 16px;
  margin-bottom: 8.5px; /* Adjust this to your preference */
}

/* Ensure the button itself maintains consistent styling */
.porta-button-wrapper .porta-button {
  position: relative;
  width: 41px;
  height: 21px;
  background-color: #CF814D;
  border: 2.5px solid #35100B;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;

  transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
}

/* Ensure label styling is consistent */
.porta-button-wrapper label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;

}
.porta-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 4px;
  margin-top: -5px;

}

.porta-button {
  position: relative;
  width: 41px;
  height: 21px;
  background-color: #CF814D;
  border: 2.5px solid #35100B;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;

  transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
}

.porta-button:hover {
  background-color: #d69061;
}

.porta-button.active {
  background-color: #dc8953;
  color: #f2eed3;
  box-shadow: 0 0 8px #dc8953; /* Glow effect */
  transform: scale(0.98); /* Slight pressed effect */
}

/* Add icon styling */
.porta-button {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.porta-button .icon {
  position: absolute;
  width: 18px;
  height: 18px;
  opacity: 0.8;
  pointer-events: none;
}

/* Icon color changes with button state */
.porta-button .icon {
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
}

.porta-button.active .icon {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}

/* Remove the LED */
.porta-button .select-led {
  display: none;
}

/* Switch container styling */
.switch-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 10px 0;
}

.switch-label {
  position: relative;
  font-size: 10px;
  color: #35100B;
  text-align: center;
  width: 100%;
  margin: 0;
  padding: 0;
}

/* New class for labels above the switch */
.switch-label-top {
  margin-bottom: 3.5px;
}

/* New class for labels below the switch */
.switch-label-bottom {
  margin-top: 5px;
}

/* Master Volume Knob */
.master-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #BA5446;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  
  /* Double border effect - EXACT match to other knobs */
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;
  
  /* Center point marker */
  transform-origin: center center;
  margin: 10px 0;
}

/* Style knob indicator line */
.master-module .knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px; /* Longer line from center to edge */
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg); /* Center at origin */
}

/* Knob label style */
.master-module label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}

/* Control sections */
.mono-controls,
.legato-controls {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: opacity 0.3s;
}


.module-title.modulation {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 10px;
  background-color: #4E658B; /* Distinct color for MODULATION module */
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px;
}



#mod-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  z-index: 2;
}

.mod-grid-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: linear-gradient(to right, rgba(242, 238, 211, 0.1) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(242, 238, 211, 0.1) 1px, transparent 1px);
  background-size: 10px 10px;
  z-index: 1;
}
.modulation-module {
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  min-width: 145px;
  max-width: 145px;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}
.mod-mode-selector {
  display: flex;
  flex-direction: column;
  background-color: #E5AB5F;
  border: 2px solid #35100B;
  border-radius: 5px;
  overflow: visible; /* Changed from 'overflow: hidden' to allow glow to extend out */
  width: 45px;
  position: relative; /* Add this to establish stacking context */
  z-index: 1; /* Ensure it sits above other elements */
}


/* Default button styling */
.mode-option {
  padding: 6px;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  cursor: pointer;
  border-bottom: 1px solid #35100B;
  background-color: #f2eed3;
  transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
}

/* Remove border from last item */
.mode-option:last-child {
  border-bottom: none;
}

/* Individual color styling for each button */
.mode-option[data-mode="env"] {
  background-color: #E5AB5F;
}

.mode-option[data-mode="lfo"] {
  background-color: #CF814D;
}

.mode-option[data-mode="trig"] {
  background-color: #BA5446;
}

/* Hover states */
.mode-option[data-mode="env"]:hover {
  background-color: #e7b068;
}

.mode-option[data-mode="lfo"]:hover {
  background-color: #d69061;
}

.mode-option[data-mode="trig"]:hover {
  background-color: #b85f53;
}

/* Enhanced glow effects for active buttons */
.mode-option[data-mode="env"].active {
  background-color: #E5AB5F; /* Yellow */
  color: #f2eed3;
  box-shadow: 0 0 8px 1px #E5AB5F, 0 0 20px 5px rgba(229, 171, 95, 0.5); /* Multiple shadows for stronger effect */
  transform: scale(0.98); /* Slight pressed effect */
  position: relative;
  z-index: 2; /* Higher than container */
}

.mode-option[data-mode="lfo"].active {
  background-color: #dc8953; /* Orange */
  color: #f2eed3;
  box-shadow: 0 0 8px 1px #dc8953, 0 0 20px 5px rgba(220, 137, 83, 0.5); /* Multiple shadows */
  transform: scale(0.98);
  position: relative;
  z-index: 2;
}

.mode-option[data-mode="trig"].active {
  background-color: #d55d4d; /* Red */
  color: #f2eed3;
  box-shadow: 0 0 8px 1px #d55d4d, 0 0 25px 6px rgba(213, 93, 77, 0.6); /* Strongest glow */
  transform: scale(0.98);
  position: relative;
  z-index: 2;
}

/* Ensure hover states don't have overflow issues */
.mode-option:hover {
  overflow: visible;
}
/* Canvas container - now at the top of the module */
.mod-canvas-container {
  position: relative;
  width: 120px;
  height: 100px;
  background-color: #35100B;
  border: 2px solid #35100B;
  border-radius: 5px;
  margin-bottom: 13px;
  margin-top: 10px;
  overflow: hidden;
}

/* Two-column layout container below the canvas */
.mod-columns-container {
  display: flex;
  width: 92%;
  justify-content: space-between;
  margin-top: 5px;
  height: 191px;
}

/* Left column styling */
.mod-left-column {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  width: 65%;
  border: 1px solid #35100B;
  border-radius: 10px;
  padding-right: 5px;
    padding-left: 5px;
    margin-right: 5px;
    margin-left: -5px;
    right: 2px;
}

/* Right column styling */
.mod-right-column {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 45%;
}

/* Adjust spacing between items in left column */
.mod-left-column .mod-selector-container,
.mod-left-column .knob-container {
  margin-bottom: 0px;
}

/* Ensure mode selector is centered */
.mod-mode-selector {
  margin: 0 auto;
  margin-top: 10px;
}

/* Make destination container fit properly */
.mod-destination-container {
  height: 170px;
}
/* Three-way mode selector styling */
.mod-selector-container {
  display: flex;
  justify-content: center;
  margin-bottom: 10px;
  width: 100%;
}

.mod-mode-selector {
  display: flex;
  flex-direction: column;
  background-color: #E5AB5F;
  border: 2px solid #35100B;
  border-radius: 5px;
  overflow: hidden;
  width: 45px;
}

.mode-option {
  padding: 6px;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  cursor: pointer;
  border-bottom: 1px solid #35100B;
  background-color: #f2eed3;
}

.mode-option:last-child {
  border-bottom: none;
}

.mode-option.active {
  background-color: #35100B;
  color: #f2eed3;
}

/* Controls container */
.mod-controls-container {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 10px;
}

/* Knob styling (using existing knob styles) */
.modulation-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #CF814D;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;
  transform-origin: center center;
}

.modulation-module .knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}

/* Destination slider styling */
.mod-destination-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: 240px; /* Match LFO height */
  width: 81.95px; /* Match LFO width */
  margin-top: 10px;
  position: relative;
}

/* Vertical destination range slider */
.mod-destination-range {
  -webkit-appearance: none;
  appearance: none;
  width: 20px; /* Make the slider wider than standard */
  height: 100%;
  background: transparent;
  writing-mode: vertical-lr;
  direction: rtl; /* Bottom to top orientation */
  margin: 15px;
}

/* Custom track styling */
.mod-destination-range::-webkit-slider-runnable-track {
  width: 10px;
  height: 100%;
  background: #35100B;
  border-radius: 8px;
}

/* Custom thumb styling */
.mod-destination-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 24px; /* Make it wider than the track */
  height: 26px; /* Make it taller */
  cursor: pointer;
  border-radius: 5px; /* Rectangular shape with rounded corners */
  
  /* Center it on the track */
  margin-left: -6.8px; 
  
  /* Add a subtle shadow for depth */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  
  /* Optional: Add a small indicator line */
  background-image: linear-gradient(to right, #f2eed3 30%, transparent 30%, transparent 70%, #f2eed3 70%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}

/* Ticks container positioned to the right of the slider */
.mod-destination-ticks {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 100.3%;
  margin-left: -11px;
  pointer-events: none; /* Don't block interaction */
}

/* Individual tick with label container */
.mod-destination-tick {
  display: flex;
  align-items: center;
  height: calc(100% / 9);
}

/* Tick mark styling */
.mod-destination-tick .tick {
  width: 5px;
  height: 1.9px;
  background-color: #35100B;
}

/* Label styling */
.mod-destination-tick .tick-label {
  margin-left: 5px;
  font-size: 10px;
  white-space: nowrap;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  margin-bottom: 1.6px;
  color: #35100B;
}

/* Destination label */
.mod-destination-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  bottom: -21px;
  margin-left: -4px;
}
/* New class for the modulation module select button */
.mod-select-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  /* No right margin here, unlike the original */
  margin-bottom: 5px;
  margin-top: 12px;
}

/* Ensure the button itself is centered */
.mod-select-button-container .select-button {
  position: relative;
  width: 41px;
  height: 41px;
  background-color: #BA5446; /* Match the modulation module color */
  border: 2.5px solid #35100B;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  margin-top: -2px;
  margin-bottom: 0px;
  transition: background-color 0.2s, box-shadow 0.2s;
}

.mod-select-button-container .select-button:hover {
  background-color: #b85f53; /* Slightly darker on hover */
}

.mod-select-button-container .select-button.active {
  background-color: #d15f50;
  box-shadow: 0 0 15px rgba(218, 92, 75, 0.7); /* Glow effect */
  transform: scale(0.98); /* Slight pressed effect */
}
.mod-select-button-container label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  margin-top: 3px;
  display: block;
  width: 100%;
}
.oscillator-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 139px;
  max-width: 139px;
  align-items: center;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}

.module-title.oscillator {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 10px;
  background-color: #BA5446; /* Green color for OSCILLATOR */
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px;
}

/* Oscillator selector containers */
.osc-selector-container {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 17px;
  margin-bottom: 9.5px;
}

/* Add label for selectors */
.selector-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  margin-top: 3px;
}

/* Octave labels */
.octave-label {
  font-family: "Nunito", sans-serif;
  font-size: 16px; /* Reduced from 16px to match other labels */
  font-variant-caps: all-small-caps;
  font-weight: 625; /* Match other labels */
  color: #35100B;
  text-align: center;
  display: inline-block; /* Use inline-block instead of absolute */
  margin-top: 4px; /* Add spacing between tick and label */
  position: relative; /* Use relative positioning */
  width: auto; /* Let the text determine width */
}

/* Two-column layout */
.osc-columns-container {
  display: flex;
  width: 105%;
  justify-content: space-between;
  margin-top: 5px;
}

.osc-left-column, .osc-right-column {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 45%;
}

/* Oscillator knobs - using colors that match the module theme */
.oscillator-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #6B8F53;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
  transform-origin: center center;
}

.oscillator-module .knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}

/* Space knobs properly */
.oscillator-module .knob-container {
  margin-bottom: 9px;
}

/* Fix spacing for switch */
.oscillator-module .switch-container {
  margin-bottom: 15px;
  margin-top: 5px;
}
/* Oscillator-specific switch container styling */
.osc-switch-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 8px 0 -6.5px 0; /* Custom margins for oscillator switch */
}

/* Oscillator-specific switch labels */
.osc-switch-label {
  position: relative;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  margin: 0;
  padding: 0;
}

/* Oscillator-specific top label positioning */
.osc-switch-label-top {
  margin-bottom: 4px; /* Custom spacing above switch */
  bottom: 10px;
}

/* Oscillator-specific bottom label positioning */
.osc-switch-label-bottom {
  margin-top: 4px; /* Custom spacing below switch */
  bottom: 15.5px;
}

/* Oscillator-specific vertical switch */
.osc-vertical-switch {
  width: 20px;
  height: 40px;
  background: #6B8F53;
  border: 2px solid #35100B;
  border-radius: 5px;
  position: relative;
  cursor: grab;
  margin-bottom: 3px; /* Custom bottom margin */
  bottom: 11px;
}

/* Switch handle styling */
.osc-vertical-switch::after {
  content: '';
  position: absolute;
  width: 19px;
  height: 19.4px;
  background: #35100B;
  border: 1px solid #35100B;
  border-radius: 0px;
  left: -0.5px;
  top: 0px;
  transition: top 0.1s;
  
  /* Add the on.svg overlay as a background image */
  background-image: url("control icons/on.svg");
  background-position: center;
  background-repeat: no-repeat;
  background-size: 12px 12px;
}

.osc-vertical-switch.active::after {
  top: 19px;
}
.osc-vertical-switch {
  position: relative; /* Ensure it's a positioning context */
}

/* Top horizontal line from switch */
.osc-vertical-switch::before {
  content: '';
  position: absolute;
  top: 25%; /* Position in upper half */
  right: -13.9px; /* Extend 12px to the right */
  width: 13px;
  height: 2px;
  background-color: #35100B;
}

/* Bottom horizontal line from switch */


/* Connection line container */
.osc-switch-container {
  position: relative; /* Make it a positioning context */
}

/* Vertical connector line where the two horizontal lines meet */
.osc-switch-container::before {
  content: '';
  position: absolute;
  top: calc(25% - 1px); /* Align with top line */
  right: -12px; /* Position at the end of the horizontal lines */
  width: 2px;
  height: calc(23% + 2px); /* Connect between top and bottom lines */
  background-color: #35100B;
}

/* Final horizontal line to FM knob */
.osc-switch-container::after {
  content: '';
  position: absolute;
  top: 34%; /* Center vertically */
  right: -42px; /* Extend to the FM knob */
  width: 30px; /* Length of line to reach FM knob */
  height: 2px;
  background-color: #35100B;
}
/* Add this rule to make the horizontal line move with the switch handle */
.osc-vertical-switch::before {
  content: '';
  position: absolute;
  top: 25%; /* Position in upper half when inactive */
  right: -13.7px;
  width: 13px;
  height: 2px;
  background-color: #35100B;
}

/* Add this new rule to move the horizontal line when the switch is active */
.osc-vertical-switch.active::before {
  top: 75%; /* Move to lower half when active, matching the handle position */
}
/* Updated oscillator knob colors */
/* Default knob style (keeping the same structure) */
.oscillator-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  transform-origin: center center;
}

/* Red knobs: Pitch and Gain */
.oscillator-module #pitch-knob, 
.oscillator-module #gain-knob {
  background-color: #BA5446;
  box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;
}

/* Blue knobs: PWM and Quantize */
.oscillator-module #pwm-knob,
.oscillator-module #quantize-knob {
  background-color: #4E658B;
  box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;
}

/* Green knob: FM */
.oscillator-module #fm-knob {
  background-color: #6B8F53;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
}
/* FILTER Module styling */
.filter-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 169px;
  max-width: 169px;
  align-items: center;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}

.module-title.filter {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 10px;
  background-color: #BA5446; /* Blue color for FILTER */
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px;
}

/* Main controls container (sliders + type selector) */
.filter-controls-container {
  display: flex;
  width: 100%;
  justify-content: space-between;
  margin-bottom: 40px;
  height: 200px;
  padding-top: 7%;
  padding-bottom: 2%;
}

/* Left container for vertical sliders */
.filter-sliders-container {
  position: relative;
  display: flex;
  gap: 25px;
  height: 103.5%;
  margin-left: 4%;
  margin-right: 15px;
}

/* Vertical sliders: Freq and Res */
.freq-slider-range,
.res-slider-range {
  -webkit-appearance: none;
  appearance: none;
  width: 5px;
  height: 100%;
  background: transparent;
  writing-mode: vertical-lr;
  direction: rtl;
}

/* Filter type container */
.filter-type-container {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: 101.5%;
  margin-top: 2px;
  position: relative;
}

/* Vertical filter type slider */
.filter-type-range {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 100%;
  background: transparent;
  writing-mode: vertical-lr;
  direction: rtl;
  margin: 15px;
}

/* Custom track styling */
.filter-type-range::-webkit-slider-runnable-track {
  width: 10px;
  height: 100%;
  background: #35100B;
  border-radius: 8px;
}

/* Ticks container positioned to the right of the slider */
.filter-type-ticks {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 97.7%;
  margin-left: -11px;
  pointer-events: none;
}

/* Shared slider track styling */
.freq-slider-range::-webkit-slider-runnable-track,
.res-slider-range::-webkit-slider-runnable-track {
  background: #35100B;
  border-radius: 5px;
  width: 5px;
  border: none;
}

/* Shared slider thumb styling */
.freq-slider-range::-webkit-slider-thumb,
.res-slider-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  background: #35100B;
  width: 26px;
  height: 18px;
  cursor: pointer;
  margin-left: -10.6px;
  border-radius: 5px;
  background-image: linear-gradient(to right, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}

/* Filter type thumb styling */
.filter-type-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 24px;
  height: 26px;
  cursor: pointer;
  border-radius: 5px;
  margin-left: -6.8px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  background-image: linear-gradient(to right, #f2eed3 30%, transparent 30%, transparent 70%, #f2eed3 70%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}

/* Slider label styling */
.slider-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  margin-top: 10px;
  width: 100%;
  position: absolute;
  bottom: -24px;
  right: 5px;
}

/* Filter type label */
.filter-type-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  bottom: -22px;
  margin-left: -4px;
}

/* Horizontal sliders container */
.filter-horizontal-sliders {
  display: flex;
  flex-direction: column;
  width: 85%;
  margin-bottom: 15px;
}

/* Horizontal slider container */
.horizontal-slider-container {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 10px;
}

/* Horizontal slider styling */
.drive-slider-range,
.variant-slider-range {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 5px;
  background: transparent;
  margin: 0;
  padding: 0;
}

/* Horizontal slider track */
.drive-slider-range::-webkit-slider-runnable-track,
.variant-slider-range::-webkit-slider-runnable-track {
  background: #35100B;
  border-radius: 5px;
  height: 5px;
  border: none;
}

/* Horizontal slider thumb */
.drive-slider-range::-webkit-slider-thumb,
.variant-slider-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  background: #35100B;
  width: 18px;
  height: 24px;
  cursor: pointer;
  margin-top: -9.5px;
  border-radius: 5px;
  background-image: linear-gradient(to top, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center;
}

/* Horizontal slider ticks */
.horizontal-slider-ticks {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-top: 5px;
}

.horizontal-slider-ticks .tick {
  width: 1.7px;
  height: 8px;
  background-color: #35100B;
}

/* Horizontal slider label */
.horizontal-slider-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  margin-top: 5px;
}

/* Bottom knobs container */
.filter-bottom-controls {
  display: flex;
  justify-content: space-around;
  width: 90%;
  margin-top: 3px;
}

/* Knob container styling */
.filter-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Filter knobs */
.filter-module .knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #CF814D; /* Blue color matching filter module */
  position: relative;
  cursor: grab;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;
  transform-origin: center center;
}
.filter-module #keytrack-knob {
  background-color: #BA5446; /* Red color */
  box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;
}
/* Knob indicator styling */
.filter-module .knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}

/* Knob label styling */
.filter-knob-container label {
  margin-top: -3.5px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
}
/* Bottom knobs container */
.mod-bottom-controls {
  display: flex;
  justify-content: space-around;
  width: 92%;
padding-left: 6px;
  margin-left: 5px;
  margin-top: 7px;

}

/* Depth knob (regular styling) */
#mod-depth-knob {
  background-color: #BA5446; /* Blue color */
  box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;
  right: 3px;
}

/* Shape knob container with ticks */
.shape-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  width: 55px;
  left: 5px;

}

/* Ticks container positioned around the knob */
.shape-knob-ticks {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none; /* Don't block interactions */
  bottom: 9px;
  right: 0.5px;
}

/* Individual tick styling */
.shape-tick {
  position: absolute;
  width: 1px;
  height: 4px;
  background-color: #35100B;
  left: 50%;
  top: 50%;
  transform-origin: center bottom;
}

/* Discrete shape knob with 5 positions */
.shape-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #6B8F53; /* Green color */
  position: relative;
  cursor: pointer;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
  z-index: 1;
  top: 10px;
}

/* Shape knob indicator line */
.shape-indicator {
  content: '';
  position: absolute;
  top: 0;
  left: 50%;
  height: 45%;
  width: 3px;
  background-color: #f2eed3;
  transform: translateX(-50%);
}

/* Label styling */
.shape-knob-container label {
  margin-top: 26px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}
/* Add this to your CSS */
.shape-knob-ticks .wave-shape {
  position: absolute;
  height: 14px;
  width: 18px;
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
  pointer-events: none;
}
.mod-left-column {
  position: relative;
}

.mod-left-column::before {
  content: "^^MOD^^";
  position: absolute;
  top: -10px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #f2eed3;
  padding: 0 8px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  z-index: 1;
}
/* Make the shape ticks larger to accommodate the icons */
.shape-tick {
  position: absolute;
  width: 2px;
  height: 5px;
  background-color: #35100B;
  left: 50%;
  top: 50%;
  transform-origin: center bottom;
}

/* Update positioning for the shape knob container */
.shape-knob-container {
  margin-top: 5px;
  padding-top: 10px;
}

/* When active, make the wave shapes visible */
.shape-knob.active + .shape-knob-ticks .wave-shape img {
  filter: invert(94%) sepia(8%) saturate(289%) hue-rotate(347deg) brightness(105%) contrast(92%);
}
/* Shape knob container styling */
.shape-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  margin-top: 5px;
}

/* Container for the shape notches */
.shape-knob-notches {
  position: absolute;
  width: 150%;
  height: 18px;
  top: -22px;
  left: -25%;
  pointer-events: none;
}

/* Individual shape notch */
.shape-notch {
  position: absolute;
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
  pointer-events: none;
  transform: translateX(-50%);
}

/* Make the shape knob look like other knobs */
#mod-shape-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #E5AB5F; /* Green color */
  position: relative;
  cursor: pointer;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B;
  transform-origin: center center;
}

/* Add indicator line */
#mod-shape-knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}
/* Shape knob container */
.shape-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  margin-top: 5px;
  margin-bottom: 20px; /* Add space for label */
}

/* Container for the wave shape icons */
.shape-notches {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2;
}

/* Individual shape icon styling */
.shape-icon {
  position: absolute;
  width: 18px;
  height: 14px;
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
  pointer-events: none;
}

/* Shape knob styling (same as other knobs) */
#mod-shape-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #6B8F53; /* Green color */
  position: relative;
  cursor: pointer;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
  transform-origin: center center;
}

/* Indicator line */
#mod-shape-knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}
/* Shape knob container */
.shape-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  margin-top: 5px;
  margin-bottom: 28px;
  bottom: 6px;
}

/* Markers container */
.shape-markers {
  position: absolute;
  width: 100%;
  height: 85%;
  right: 7px;
  top: 5px;
  pointer-events: none;
}

/* Individual shape marker */
.shape-marker {
  position: absolute;
  width: 18px;
  height: 14px;
  top: 50%;
  left: 50%;
  transform-origin: center;
  filter: invert(8%) sepia(12%) saturate(6770%) hue-rotate(338deg) brightness(97%) contrast(99%);
  pointer-events: none;
}

/* Shape knob styling */
#mod-shape-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #E5AB5F;
  position: relative;
  cursor: pointer;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B;
  transform-origin: center center;
}

/* Indicator line */
#mod-shape-knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}

/* Label styling */
.shape-knob-container label {
  margin-top: 8px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
}
/* Shape knob styling */
.shape-knob {
  width: 35px;
  height: 35px;
  border-radius: 50%;
  background-color: #6B8F53; /* Green color */
  position: relative;
  cursor: pointer;
  box-sizing: border-box;
  border: 0.5px solid #35100B;
  box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;
  transform-origin: center center;
}

/* Shape knob indicator line */
.shape-knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}
.mod-horizontal-line {
  position: relative;
  width: 140%;
  height: 1px; /* Keep original height */
  min-height: 1px; /* Add min-height to prevent collapse */
  background-color: #35100B;
  margin: 10px auto 15px auto;
  opacity: 1;
  display: block;

  overflow: visible; /* Ensure it's not being cut off */
  right: 15.3px;
  bottom: 205px;
}
.mod-vertical-line {
  position: relative;
  width: 1px; /* Thin vertical line */
  min-height: 190px;
  min-width: 1px; /* Add min-width to prevent collapse */
  background-color: #35100B;
  opacity: 1;
  display: block;

  overflow: visible; /* Ensure it's not being cut off */
  bottom: 195px;
  left: 30px; /* Position to the right of the mod-rate-knob */
}
.slider-horizontal-line {
  position: absolute;
  width: 170%;
  height: 1px;
  min-height: 1px;
  background-color: #35100B;
  top: -8px;
  right: 10px;
  left: -13.9px;
  opacity: 1;
  display: block;
  z-index: 1;
}
.lfo-section-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
  width: 100%;
  position: absolute;
  top: -23px;
  left: 1px;
  z-index: 2;
}
/* Styling for macro knob columns */
.macro-column {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

/* Styling for bottom row of macros */
.bottom-macro-row {
  display: flex;
  gap: 15px;
  margin-top: 15px;
  width: 100%;
  justify-content: space-around;
}

/* Adjust mod-bottom-controls to support the new layout */
.mod-bottom-controls {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
  width: 96%;
  margin-top: 7px;

}

/* Ensure all knobs have the proper indicator line */
.knob::after {
  content: '';
  position: absolute;
  border-radius: 1px;
  top: 50%;
  left: 50%;
  width: 23.6px;
  height: 3px;
  background-color: #f2eed3;
  transform-origin: left center;
  transform: translate(-0px, -50%) rotate(270deg);
}
/* Styling for the button container */
.matrix-buttons-container {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin: 10px auto 5px auto;
  margin-top: 15px;
    margin-bottom: 0px;
}

/* Styling for the individual buttons */
.matrix-button {
  width: 21px;
  height: 21px;
  background-color: #f2eed3;
  border: 2.5px solid #35100B;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.matrix-button:hover {
  background-color: #e8e3c4;
}

.matrix-button.active {
  background-color: #BA5446;
  box-shadow: 0 0 8px rgba(186, 84, 70, 0.5);
}
/* Base colors for the six buttons */
.matrix-button:nth-child(1),
.matrix-button:nth-child(2) {
  background-color: #6B8F53; /* Green color */
}

.matrix-button:nth-child(3) {
  background-color: #4E658B; /* Blue color */
}

.matrix-button:nth-child(4) {
  background-color: #E5AB5F; /* Yellow color */
}

.matrix-button:nth-child(5) {
  background-color: #BA5446; /* Red color */
}

.matrix-button:nth-child(6) {
  background-color: #CF814D; /* Orange color */
}

/* Hover states - slightly brighter versions of each color */
.matrix-button:nth-child(1):hover,
.matrix-button:nth-child(2):hover {
  background-color: #7da263; /* Brighter green */
}

.matrix-button:nth-child(3):hover {
  background-color: #5a739a; /* Brighter blue */
}

.matrix-button:nth-child(4):hover {
  background-color: #e7b068; /* Brighter yellow */
}

.matrix-button:nth-child(5):hover {
  background-color: #c65f53; /* Brighter red */
}

.matrix-button:nth-child(6):hover {
  background-color: #d69061; /* Brighter orange */
}

/* Active state with glow effect */
.matrix-button:nth-child(1).active,
.matrix-button:nth-child(2).active {
  background-color: #7da263; /* Same as hover green */
  box-shadow: 0 0 8px rgba(107, 143, 83, 0.8); /* Green glow */
}

.matrix-button:nth-child(3).active {
  background-color: #5a739a; /* Same as hover blue */
  box-shadow: 0 0 8px rgba(78, 101, 139, 0.8); /* Blue glow */
}

.matrix-button:nth-child(4).active {
  background-color: #e7b068; /* Same as hover yellow */
  box-shadow: 0 0 8px rgba(229, 171, 95, 0.8); /* Yellow glow */
}

.matrix-button:nth-child(5).active {
  background-color: #c65f53; /* Same as hover red */
  box-shadow: 0 0 8px rgba(186, 84, 70, 0.8); /* Red glow */
}

.matrix-button:nth-child(6).active {
  background-color: #d69061; /* Same as hover orange */
  box-shadow: 0 0 8px rgba(207, 129, 77, 0.8); /* Orange glow */
}
/* Add this CSS to style the text in the matrix buttons */
.matrix-button {
  width: 21px;
  height: 21px;
  background-color: #f2eed3;
  border: 2.5px solid #35100B;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s;
  display: flex;           /* Add flex display to center text */
  justify-content: center; /* Center horizontally */
  align-items: center;     /* Center vertically */
  font-family: "Nunito", sans-serif;
  font-size: 8px;          /* Small font size for the small buttons */
  font-weight: 700;        /* Bold text for better visibility */
  color: #35100B;          /* Dark text color by default */
}

/* Make text white when button is active */
.matrix-button.active {
  background-color: #BA5446;
  box-shadow: 0 0 8px rgba(186, 84, 70, 0.5);
  color: #f2eed3;          /* Light text color when active */
}
/* LOOPER Module styling */
.looper-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 205px;
  max-width: 205px;
  align-items: center;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}

/* Module title */
.module-title.looper {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 5px;
  background-color: #CF814D;
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 150%;
  margin-top: -15px;
}

/* Top button container */
.looper-buttons-container {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 12px;
  margin-top: 15px;
}

/* Button styling */
.looper-button {
  width: 25px;
  height: 41px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Nunito", sans-serif;
  font-size: 8px;
  font-weight: 700;
  color: #35100B;
  border: 2.5px solid #35100B;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}

/* Red button styling (Record/Play/Additive) */
.record-button {
  background-color: #BA5446;
  color: #f2eed3;
}

.record-button:hover {
  background-color: #c65f53;
}

.record-button.active {
  background-color: #d15f50;
  box-shadow: 0 0 8px rgba(186, 84, 70, 0.8);
}

/* Orange button styling (Delete/Undo/Redo) */
.orange-button {
  background-color: #CF814D;
  color: #f2eed3;
}

.orange-button:hover {
  background-color: #d69061;
}

.orange-button:active {
  background-color: #dc8953;
  box-shadow: 0 0 8px rgba(207, 129, 77, 0.8);
}

/* Three column layout */
.looper-columns {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: 100%;
  margin-top: 50px;
  gap: 5px;
}

/* Individual column styling */
.looper-column {
  width: 33%;
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: -42px;
}

/* Layers knob with 8 positions */
.layers-knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  width: 55px;
  top: 6.5px;
  margin-bottom: 15px;
}

.layers-markers {
  position: relative;
  width: 70px;
  height: 0%;
  top: 23px;
  left: -7.4px;
  pointer-events: none;
}

.layer-marker {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 14px;
  height: 14px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Nunito", sans-serif;
  font-size: 9px;
  color: #35100B;
  font-weight: 600;
}
/* Button with label container */
.looper-button-with-label {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

/* Looper button without text */
.looper-button {
  width: 25px;
  height: 40px; /* Made slightly shorter without text */
  display: flex;
  justify-content: center;
  align-items: center;
  border: 2.5px solid #35100B;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}

/* Label styling */
.looper-label {
  font-family: "Nunito", sans-serif;
  font-size: 8px;
  font-weight: 700;
  color: #35100B;
  text-align: center;
  margin-top: 2px;
}

/* Update the container spacing */
.looper-buttons-container {
  display: flex;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 0px;
  margin-top: 15px;
}
/* Icon styling */
.looper-button .icon {
  width: 14px;
  height: 14px;
  filter: invert(9%) sepia(16%) saturate(5688%) hue-rotate(323deg) brightness(99%) contrast(78%);
  transition: filter 0.2s;
}

/* Active state for icons */
.looper-button.active .icon,
.looper-button:active .icon {
  filter: invert(93%) sepia(19%) saturate(320%) hue-rotate(358deg) brightness(103%) contrast(92%);
}
/* FX Module styling */
.fx-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  min-width: 75px;
  max-width: 75px;
  align-items: center;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}

/* Module title */
.module-title.fx {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 15px;
  background-color: #CF814D;
  padding: 5px 0;
  border-radius: 10px;
  border: 0px solid #35100B;
  width: 250%;
  margin-top: -15px;
}

/* Chorus button container */
.chorus-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 8px;
  margin-top: 5px;
}

/* Chorus button */
.chorus-button {
  width: 40px;
  height: 40px;
  background-color: #CF814D; /* Orange color */
  border: 2.5px solid #35100B;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

.chorus-button:hover {
  background-color: #d69061;
}

/* Chorus indicators */
.chorus-indicator {
  color: #35100B;
  font-family: "Nunito", sans-serif;
  font-weight: 800;
  font-size: 18px;
  transition: color 0.2s;
  position: absolute;
}

.chorus-indicator.first {
  left: 12px;
}

.chorus-indicator.second {
  right: 12px;
}

/* States for the chorus button */
.chorus-button.state-1 .chorus-indicator.first {
  color: #f2eed3;
}

.chorus-button.state-2 .chorus-indicator.first,
.chorus-button.state-2 .chorus-indicator.second {
  color: #f2eed3;
}

.chorus-button.state-1, 
.chorus-button.state-2 {
  box-shadow: 0 0 8px rgba(207, 129, 77, 0.8);
}

/* Chorus label */
.chorus-button-container label {
  margin-top: 5px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}

/* FX knobs column */
.fx-knobs-column {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

/* Knob containers */
.fx-module .knob-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Knob labels */
.fx-module .knob-container label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
}
/* DELAY Module styling */
.delay-module {
  border: 1px solid #35100B;
  background-color: #f2eed3;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  min-width: 260px;
  max-width: 260px;
  align-items: center;
  padding-top: 15px;
  overflow: hidden;
  box-sizing: border-box;
}

/* Module title */
.module-title.delay {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 0px;
  background-color: #CF814D; /* Blue title for DELAY */
  padding: 5px 0;
  border: 0px solid #35100B;
  width: 100%;
  margin-top: -15px;
}

/* Section container */
.delay-sections {
  display: flex;
  width: 100%;
  height: 433px;
}

/* Individual sections with color coding */
.delay-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 5px 0;
}

.red-section {
  background-color: #E5AB5F;
  width: 25%;
}

.orange-section {
  background-color: #CF814D;
  width: 25%;
}

.yellow-section {
  background-color: #BA5446;
  width: 25%;
}

.green-section {
  background-color: #6B8F53;
  width: 25%;
}

/* Slider container */
.delay-slider-container {
  height: 319px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  margin-bottom: 10px;
  margin-top: 15px;
  width: 25%;
}

/* Slider track */
.delay-slider-track {
  position: absolute;
  top: 0;
  height: 297px;
  width: 5px;
  background-color: #35100B;
  border-radius: 2.5px;
}

/* Vertical slider */
.delay-slider {
  -webkit-appearance: none;
  width: 33px;
  height: 297px;
  margin-top: 0px;
  background: transparent;
  transform-origin: center;
  writing-mode: vertical-lr; /* Modern vertical orientation */
  direction: rtl; /* Bottom to top orientation */
  z-index: 1;
}

/* Slider thumb */
.delay-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  background: #35100B;
  width: 26px;
  height: 18px;
  cursor: pointer;
  margin-left: 0.6px;
  border-radius: 5px;
  background-image: linear-gradient(to right, #f2eed3 35%, transparent 35%, transparent 65%, #f2eed3 65%);
  background-size: 100% 2px;
  background-repeat: no-repeat;
  background-position: center;
}

/* Firefox slider styling */
.delay-slider::-moz-range-track {
  width: 100%;
  height: 5px;
  background: transparent;
}

.delay-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background-color: #f2eed3;
  border: 1.5px solid #35100B;
  border-radius: 50%;
  cursor: pointer;
}

/* Slider labels */
.delay-slider-label {
  position: relative;
  bottom: 2px;
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}

/* Switches container in red section */
.delay-switches {
  display: flex;
  flex-direction: column;
  margin-top: 0px;
}

/* Side label for switches */
.side-label {
  position: absolute;
  right: -45px;
  top: 50%;
  transform: translateY(-50%);
  width: auto;
}

/* Knob positioning */
.delay-section .knob-container {
  margin-top: 0px;
}
/* Switches container in red section */
.delay-switches {
  display: flex;
  flex-direction: column;
  gap: 0px;
  margin-top: 0px;
  align-items: center;
}

/* Switch container with label */
.delay-switch-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1px;
}

/* Horizontal switch styling */
.horizontal-switch {
  width: 35px;
  height: 18px;
  background-color: #35100B;
  border-radius: 5px;
  border: 2px solid #35100B;
  position: relative;
  cursor: pointer;
  transition: background-color 0.2s;
}

/* Switch handle */
.horizontal-switch::after {
  content: '';
  position: absolute;
  top: 0px;
  left: 0.5px;
  width: 17px;
  height: 18px;
  border-radius: 3px;
  background-color: #E5AB5F;
  transition: transform 0.2s;
  background-image: url(control\ icons/on.svg);
  background-position: center;
    background-repeat: no-repeat;
    background-size: 12px 12px;
}

/* Active state moves handle to right */
.horizontal-switch.active::after {
  transform: translateX(17px);
}

/* Switch label */
.delay-switch-label {
  font-family: "Nunito", sans-serif;
  font-size: 10px;
  font-variant-caps: all-small-caps;
  font-weight: 750;
  color: #35100B;
  text-align: center;
}
/* Updated DELAY Module title styling with four colored rectangles */
.module-title.delay {
  color: #f2eed3;
  text-align: center;
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
  font-size: 16px;
  margin-bottom: 0px;
  background-color: transparent; /* Remove the solid background */
  padding: 5px 0;
  border: 0px solid #35100B;
  width: 100%;
  margin-top: -15px;
  position: relative;
  overflow: hidden;
  display: flex;
}

/* Individual colored sections of the title */
.delay-title-section {
  height: 100%;
  width: 25%;
  position: absolute;
  top: 0;
}

/* Position each section */
.red-title {
  background-color: #E5AB5F;
  left: 0;
}

.orange-title {
  background-color: #CF814D;
  left: 25%;
}

.yellow-title {
  background-color: #BA5446;
  left: 50%;
}

.green-title {
  background-color: #6B8F53;
  left: 75%;
}

/* Text positioning on top of the colored sections */
.delay-title-text {
  position: relative;
  z-index: 1;
  width: 100%;
  text-align: center;
  display: block;
  left: 2.5px;
}


    </style>
</head>
<body>
    <div class="container">
        
        <div class="synth-panel">
         
<!-- LFO Module -->
<div class="module LFO-Module" style="min-width: 205px; max-width: 205px;">
  <div class="lfo">MATRIX</div>
  <div class="matrix-buttons-container" style="position: relative; z-index: 10;">
    <div class="matrix-button">MOD</div>
    <div class="matrix-button">LFO</div>
    <div class="matrix-button">1</div>
    <div class="matrix-button">2</div>
    <div class="matrix-button">3</div>
    <div class="matrix-button">4</div>
  </div>
  <div class="lfo-controls-container" style="z-index: 5;">

    
<!-- Replace the button switches with a vertical 9-position slider -->
<div class="lfo-destination-container">
  <!-- Vertical slider with 9 notches -->
  <input type="range" class="lfo-destination-range" min="0" max="12" step="1" value="0" orient="vertical">
  
  <!-- Tick marks with labels -->
  <div class="lfo-destination-ticks">
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Sampler Pitch</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 1 Pitch</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 2 Pitch</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Sampler Gain</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 1 Gain</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 2 Gain</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 1 PWM</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 2 PWM</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 1 Quant</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 2 Quant</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 1 FM</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Osc 2 FM</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Overload</span>
    </div>
  </div>
  <div class="destination-label">Destination</div>
</div>
<div class="lfo-destination-container">
  <!-- Vertical slider with 9 notches -->
  <input type="range" class="lfo-destination-range" min="0" max="12" step="1" value="0" orient="vertical">
  
  <!-- Tick marks with labels -->
  <div class="lfo-destination-ticks">
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Lo-Fi</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Speed</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Jump</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Filter</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Stutter</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Pitch</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Delay Time</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Warp</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Feedback</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Cutoff</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Variant</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Resonance</span>
    </div>
    <div class="tick-with-label">
      <div class="tick"></div>
      <span class="tick-label">Lo-Fi Amt</span>
    </div>
    
  </div>
  <div class="destination-label">Destination</div>

</div>
</div>
<!-- New 3-column layout for knobs -->
<div class="matrix-knobs-container" style="display: flex; justify-content: space-between; margin-top: 15px; width: 94%;">
  <!-- Column 1 -->
  <div class="matrix-knob-column" style="flex-direction: column; align-items: center;">
    <div class="select-button-container">
      <div class="select-button" id="lfo-select-button">
        <img src="control icons/destination-select.svg" alt="Destination Select" class="icon">
        <div class="select-led"></div>
      </div>
      <label for="lfo-select-button"style="
      margin-top: 1px;
  ">Select</label>
    </div>
    <div class="knob-container">
      <div class="knob" id="matrix-depth-knob" style="background-color: #6B8F53; box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;"></div>
      <label for="matrix-depth-knob">Depth</label>
    </div>

    

  </div>
  
  <!-- Column 2 -->
    <div class="matrix-knob-column" style="flex-direction: column; align-items: center; margin-top: 9px;    display: flex
;">
      <div class="knob-container">
        <div class="knob" id="macro1-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
        <label for="macro1-knob">Macro 1</label>
      </div>
      <div class="knob-container">
        <div class="knob" id="macro3-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
        <label for="macro3-knob">Macro 3</label>
      </div>
    

  </div>
  
  <!-- Column 3 -->
  <div class="matrix-knob-column" style="flex-direction: column; align-items: center; margin-top: 9px;    display: flex
;">
  <div class="knob-container">
    <div class="knob" id="macro2-knob" style="background-color: #E5AB5F; box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B;"></div>
    <label for="macro2-knob">Macro 2</label>
  </div>

  <div class="knob-container">
    <div class="knob" id="macro4-knob" style="background-color: #CF814D; box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;"></div>
    <label for="macro4-knob">Macro 4</label>
  </div> 

</div>
</div>
</div>

<!-- Updated MODULATION Module with canvas at top and two-column layout below -->
<div class="module modulation-module">
  <div class="module-title modulation">MODULATION</div>
  
  <!-- Canvas at the top of the module -->
  <div class="mod-canvas-container">
    <canvas id="mod-canvas" width="120" height="100"></canvas>
    <div class="mod-grid-overlay"></div>
  </div>
  
  <!-- Two columns below the canvas -->
  <div class="mod-columns-container">
    <!-- Left column: controls stacked vertically -->
    <div class="mod-left-column" style="height: 191.400px;">
      <!-- Three-way vertical selector -->
      <div class="mod-selector-container">
        <div class="mod-mode-selector">
          <div class="mode-option" data-mode="env">ENV</div>
          <div class="mode-option active" data-mode="lfo">LFO</div>
          <div class="mode-option" data-mode="trig">TRIG</div>
        </div>
      </div>
      
      <!-- Rate Knob -->
      <div class="knob-container" style="
    margin-top: 31.5px;"> 
        <div class="knob" id="mod-rate-knob"></div>
        <label for="mod-rate-knob">Rate</label>
      </div>

      
      
    </div>
    
    <!-- Right column: destination slider -->
    <div class="mod-right-column">
      <!-- Left side: Vertical sliders -->
      <div class="lfo-sliders-container">


        
        <!-- Rate Slider -->
        <div class="slider-tick-container">
          <input type="range" class="rate-slider-range" min="0" max="1" step="0.01" value="0.5">
          <div class="slider-label"style="margin-top: 17px;">Rate</div>
        </div>

  <!-- Delay Slider (renamed to "Fade In") -->
  <div class="slider-tick-container">
    <input type="range" class="delay-slider-range" min="0" max="1" step="0.01" value="0.5">
    <div class="slider-label"style="margin-top: 17px;">Fade</div>
  </div>
</div>
    </div>
  </div>
  <div class="mod-bottom-controls">
    <div class="knob-container">
      <div class="knob" id="mod-depth-knob"></div>
      <label for="mod-depth-knob"style="
      margin-right: 6px;
  ">Depth</label>
    </div>
<!-- Update this line in the mod-bottom-controls section -->
<div class="shape-knob-container">
  <!-- Fixed position shape markers at exact angles -->
  <div class="shape-markers">
    <!-- -150 degrees -->
    <div class="shape-marker" style="transform: rotate(-150deg) translateY(-30px) rotate(150deg);">
      <img src="SHAPES/wave-sine.svg" alt="Sine" width="13" height="9">
    </div>
    <!-- -75 degrees -->
    <div class="shape-marker" style="transform: rotate(-75deg) translateY(-30px) rotate(75deg);">
      <img src="SHAPES/sawtooth-wave.svg" alt="Sawtooth" width="13" height="9">
    </div>
    <!-- 0 degrees -->
    <div class="shape-marker" style="transform: rotate(0deg) translateY(-30px) rotate(0deg);">
      <img src="SHAPES/triangle-shape.svg" alt="Triangle" width="13" height="9">
    </div>
    <!-- 75 degrees -->
    <div class="shape-marker" style="transform: rotate(75deg) translateY(-30px) rotate(-75deg);">
      <img src="SHAPES/square-wave.svg" alt="Square" width="13" height="9">
    </div>
    <!-- 150 degrees -->
    <div class="shape-marker" style="transform: rotate(150deg) translateY(-30px) rotate(-150deg);">
      <img src="SHAPES/mod-random.svg" alt="Random" width="13" height="9">
    </div>
  </div>
  
  <!-- The knob itself - UPDATED with shape-knob class -->
  <div class="shape-knob" id="mod-shape-knob"></div>

</div>
  </div>
</div>

<!-- Updated SAMPLER Module with matching styling -->
<div class="module sampler-module">
  <div class="module-title sampler">SAMPLER</div>
  
  <!-- Two-column layout container -->
  <div class="sampler-columns">
    <!-- Left Column -->
    <div class="sampler-column">
<!-- Completely revised HTML for the file input -->
<div class="sample-selector-container">
  <div class="sample-selector-container">
    <label for="audio-file" id="load-sample-label" class="custom-file-button">Load</label>
    <input type="file" id="audio-file" accept="audio/*" class="hidden-file-input">
  </div>
</div>
      
<div class="switch-container lofi-button-container">
  <div class="lofi-button" id="emu-mode-switch">
    <img src="control icons/lo-fi.svg" alt="Lo-Fi" class="icon">
  </div>
  <label for="emu-mode-switch">Lo-Fi</label>
</div>
      <div class="switch-container reverse-button-container">
        <div class="reverse-button" id="reverse-button">
          <img src="control icons/reverse.svg" alt="Reverse" class="icon">
        </div>
        <label for="reverse-button">Reverse</label>
      </div>
      <div class="knob-container">
        <div class="knob" id="sample-volume-knob"></div>
        <label for="sample-volume-knob">Volume</label>
      </div>
      
      <div class="knob-container">
        <div class="knob" id="sample-pitch-knob"></div>
        <label for="sample-pitch-knob">Pitch</label>
      </div>
      
      <div class="knob-container">
        <div class="knob" id="sample-fade-knob"></div>
        <label for="sample-fade-knob">Fade</label>
      </div>
    </div>
    
    <!-- Right Column -->
    <div class="sampler-column">
      <!-- Sample selector dropdown -->
      <div class="sample-selector-container">
        <button id="sample-selector-btn">Presets</button>
        <div id="sample-dropdown" class="sample-dropdown">
          <div class="dropdown-item" data-sample="Dirty Bass.wav">Dirty Bass</div>
          <div class="dropdown-item" data-sample="Keys - Piano.wav">Piano</div>
          <div class="dropdown-item" data-sample="Noise.wav">Noise</div>
          <div class="dropdown-item" data-sample="Saw.wav">Saw</div>
          <div class="dropdown-item" data-sample="Mallet.wav">Mallet</div>
        </div>
      </div>
      
      <div class="switch-container rec-button-container">
        <div class="rec-button" id="mic-record-button">
          <img src="control icons/record.svg" alt="Record" class="icon">
        </div>
        <label for="mic-record-button">Rec</label>
      </div>
      <div class="switch-container keytrack-button-container">
        <div class="keytrack-button active" id="keytrack-button">
          <img src="control icons/keyboard.svg" alt="Keyboard" class="icon">

          <div class="select-led" style="background-color: #c52a18; box-shadow: 0 0 4px #ff0000;"></div>
        </div>
        <label for="keytrack-button">Key-Track</label>
      </div>
      <div class="knob-container">
        <div class="knob" id="sample-start-knob"></div>
        <label for="sample-start-knob">Start</label>
      </div>
      
      <div class="knob-container">
        <div class="knob" id="sample-end-knob"></div>
        <label for="sample-end-knob">End</label>
      </div>
      
      <div class="knob-container">
        <div class="knob" id="sample-crossfade-knob"></div>
        <label for="sample-crossfade-knob">Crossfade</label>
      </div>
    </div>
  </div>
</div>

<!-- OSCILLATOR 2 Module -->
<div class="module oscillator-module">
  <div class="module-title oscillator">OSCILLATOR</div>
  
  <!-- Wave Shape Selector (similar to LFO but with pulse instead of random) -->
  <div class="osc-selector-container">
    <input type="range" class="five-step-selector-range" min="0" max="4" step="1" value="2">
    <div class="five-step-ticks">
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/wave-sine.svg" alt="Sine" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/sawtooth-wave.svg" alt="Sawtooth" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/triangle-shape.svg" alt="Triangle" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/square-wave.svg" alt="Square" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/pulse.svg" alt="Pulse" width="18" height="14">
        </div>
      </div>
    </div>

  </div>
  
  <!-- Octave Selector -->
  <div class="osc-selector-container">
    <input type="range" class="five-step-selector-range" min="0" max="4" step="1" value="2">
    <div class="five-step-ticks">
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">-2</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">-1</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">0</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">+1</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">+2</span>
      </div>
    </div>

  </div>

  <!-- Two columns for controls -->
  <div class="osc-columns-container">
    <!-- Left column -->
    <div class="osc-left-column">
      <!-- FM Source Switch -->
      <div class="osc-switch-container">
        <label class="osc-switch-label osc-switch-label-top">Noise</label>
        <div class="osc-vertical-switch" id="fm-source-switch"></div>
        <label class="osc-switch-label osc-switch-label-bottom">Osc 1</label>
      </div>
      
      <!-- PWM Knob -->
      <div class="knob-container">
        <div class="knob" id="pwm-knob"></div>
        <label for="pwm-knob">PWM</label>
      </div>
      
      <!-- Pitch Knob -->
      <div class="knob-container">
        <div class="knob" id="pitch-knob"></div>
        <label for="pitch-knob">Pitch</label>
      </div>
    </div>
    
    <!-- Right column -->
    <div class="osc-right-column">
      <!-- FM Knob -->
      <div class="knob-container">
        <div class="knob" id="fm-knob"></div>
        <label for="fm-knob">FM</label>
      </div>
      
      <!-- Quantize Knob -->
      <div class="knob-container">
        <div class="knob" id="quantize-knob"></div>
        <label for="quantize-knob">Quantize</label>
      </div>
      
      <!-- Gain Knob -->
      <div class="knob-container">
        <div class="knob" id="gain-knob"></div>
        <label for="gain-knob">Gain</label>
      </div>
    </div>
  </div>
</div>
<!-- OSCILLATOR Module -->
<div class="module oscillator-module">
  <div class="module-title oscillator">OSCILLATOR 2</div>
  
  <!-- Wave Shape Selector (similar to LFO but with pulse instead of random) -->
  <div class="osc-selector-container">
    <input type="range" class="five-step-selector-range" min="0" max="4" step="1" value="2">
    <div class="five-step-ticks">
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/wave-sine.svg" alt="Sine" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/sawtooth-wave.svg" alt="Sawtooth" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/triangle-shape.svg" alt="Triangle" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/square-wave.svg" alt="Square" width="18" height="14">
        </div>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <div class="wave-shape">
          <img src="SHAPES/pulse.svg" alt="Pulse" width="18" height="14">
        </div>
      </div>
    </div>

  </div>
  
  <!-- Octave Selector -->
  <div class="osc-selector-container">
    <input type="range" class="five-step-selector-range" min="0" max="4" step="1" value="2">
    <div class="five-step-ticks">
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">-2</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">-1</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">0</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">+1</span>
      </div>
      <div class="tick-container">
        <div class="tick"></div>
        <span class="octave-label">+2</span>
      </div>
    </div>

  </div>

  <!-- Two columns for controls -->
  <div class="osc-columns-container">
    <!-- Left column -->
    <div class="osc-left-column">
      <!-- FM Source Switch -->
      <div class="osc-switch-container">
        <label class="osc-switch-label osc-switch-label-top">Noise</label>
        <div class="osc-vertical-switch" id="fm-source-switch"></div>
        <label class="osc-switch-label osc-switch-label-bottom">Osc 2</label>
      </div>
      
      <!-- PWM Knob -->
      <div class="knob-container">
        <div class="knob" id="pwm-knob"></div>
        <label for="pwm-knob">PWM</label>
      </div>
      
      <!-- Pitch Knob -->
      <div class="knob-container">
        <div class="knob" id="pitch-knob"></div>
        <label for="pitch-knob">Pitch</label>
      </div>
    </div>
    
    <!-- Right column -->
    <div class="osc-right-column">
      <!-- FM Knob -->
      <div class="knob-container">
        <div class="knob" id="fm-knob"></div>
        <label for="fm-knob">FM</label>
      </div>
      
      <!-- Quantize Knob -->
      <div class="knob-container">
        <div class="knob" id="quantize-knob"></div>
        <label for="quantize-knob">Quantize</label>
      </div>
      
      <!-- Gain Knob -->
      <div class="knob-container">
        <div class="knob" id="gain-knob"></div>
        <label for="gain-knob">Gain</label>
      </div>
    </div>
  </div>
</div>
<!-- FILTER Module -->
<div class="module filter-module">
  <div class="module-title filter">FILTER</div>
  
  <div class="filter-controls-container">
    <!-- Left side: Vertical sliders -->
    <div class="filter-sliders-container">
      <!-- Frequency Slider -->
      <div class="slider-tick-container">
        <input type="range" class="freq-slider-range" min="0" max="1" step="0.01" value="0.5">
        <div class="filter-slider-label"style="margin-top: 23px;">Freq</div>
      </div>
      
      <div class="slider-tick-container">
        <input type="range" class="res-slider-range" min="0" max="1" step="0.01" value="0.5">
        <div class="filter-slider-label"style="margin-top: 23px;">Res</div>
      </div>
    </div>
    
    <!-- Right side: Filter Type Selector (vertical) -->
    <div class="filter-type-container">
      <!-- Vertical slider with 5 notches -->
      <input type="range" class="filter-type-range" min="0" max="4" step="1" value="0" orient="vertical">
      
      <!-- Tick marks with labels -->
      <div class="filter-type-ticks">
        <div class="tick-with-label">
          <div class="tick"></div>
          <span class="tick-label">LP 12</span>
        </div>
        <div class="tick-with-label">
          <div class="tick"></div>
          <span class="tick-label">LP 24</span>
        </div>
        <div class="tick-with-label">
          <div class="tick"></div>
          <span class="tick-label">Phase</span>
        </div>
        <div class="tick-with-label">
          <div class="tick"></div>
          <span class="tick-label">Comb</span>
        </div>
        <div class="tick-with-label">
          <div class="tick"></div>
          <span class="tick-label">Dist</span>
        </div>
      </div>
      <div class="filter-type-label">Type</div>
    </div>
  </div>
  
  <!-- Horizontal sliders container -->
  <div class="filter-horizontal-sliders">
    <!-- Drive slider -->
    <div class="horizontal-slider-container">
      <input type="range" class="drive-slider-range" min="0" max="1" step="0.01" value="0">

      <div class="horizontal-slider-label">Drive</div>
    </div>
    
    <!-- Variant slider -->
    <div class="horizontal-slider-container">
      <input type="range" class="variant-slider-range" min="0" max="1" step="0.01" value="0">

      <div class="horizontal-slider-label">Variant</div>
    </div>
  </div>
  
  <!-- Bottom knobs -->
  <div class="filter-bottom-controls">
    <div class="filter-knob-container">
      <div class="knob" id="adsr-knob"></div>
      <label for="adsr-knob">ADSR</label>
    </div>
    <div class="filter-knob-container">
      <div class="knob" id="keytrack-knob"></div>
      <label for="keytrack-knob">Key-Track</label>
    </div>
  </div>
</div>
            <!-- ADSR Module -->
            <div class="module" style="grid-column: span 2;">
              <div class="module-title adsr">ADSR Envelope</div>
              
              <div class="adsr-graph" id="adsr-visualization">
                <div class="adsr-line"></div>
              </div>
            
              <div class="slider-group">
                <div class="slider-attack">
                  <span id="attack-value">0</span>
                  <input type="range" id="attack" min="0" max="5" step="0.001" value="0">
                </div>
                <div class="slider-decay">
                  <span id="decay-value">0.1</span>
                  <input type="range" id="decay" min="0" max="5" step="0.01" value="0.1">
                </div>
                <div class="slider-sustain">
                  <span id="sustain-value">0.7</span>
                  <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
                </div>
                <div class="slider-release">
                  <span id="release-value">0.01</span>
                  <input type="range" id="release" min="0" max="5" step="0.001" value="0.001">
                </div>
              </div>
              
              <div class="slider-labels">
                <label>A</label>
                <label>D</label>
                <label>S</label>
                <label>R</label>
              </div>
            </div>
            

            <div class="module master-module">
              <div class="module-title master">MASTER</div>
              
<!-- Updated POLY/MONO switch with split labels -->
<div class="switch-container">
  <label class="switch-label switch-label-top">POLY</label>
  <div class="vertical-switch" id="voice-mode-switch"></div>
  <label class="switch-label switch-label-bottom">MONO</label>
</div>

<!-- Updated MULTI/LEGATO switch with split labels -->
<div class="switch-container">
  <label class="switch-label switch-label-top">MULTI</label>
  <div class="vertical-switch" id="trigger-mode-switch"></div>
  <label class="switch-label switch-label-bottom">LEGATO</label>
</div>
                
                <!-- Portamento controls -->
                <div class="legato-controls">
                  <div class="porta-button-wrapper">
                    <div class="porta-button" id="portamento-switch">
                      <img src="control icons/portamento.svg" alt="Portamento" class="icon">
                    </div>
                    <label for="portamento-switch">PORTA</label>
                  </div>
                  
                  <!-- Glide Time Knob (unchanged) -->
                  <div class="knob-container">
                    <div class="knob" id="glide-time-knob"></div>
                    <label for="glide-time-knob">Glide</label>
                  </div>
                </div>

              
              <!-- Master Volume -->
              <div class="knob-container">
                <div class="knob" id="master-volume-knob"></div>
                <label for="master-volume-knob">Volume</label>
              </div>
            </div>
    
   
      
<!-- LOOPER Module -->
<div class="module looper-module">
  <div class="module-title looper">LOOPER</div>
  
  <!-- Updated looper buttons container with icons -->
<div class="looper-buttons-container">
  <div class="looper-button-with-label">
    <div class="looper-button record-button" id="looper-record-button">
      <img src="looper button icons/record 2.svg" alt="Record" class="icon">
    </div>
    <label for="looper-record-button" class="looper-label">REC</label>
  </div>
  
  <div class="looper-button-with-label">
    <div class="looper-button record-button" id="looper-play-button">
      <img src="looper button icons/play 1.svg" alt="Play" class="icon">
    </div>
    <label for="looper-play-button" class="looper-label">PLAY</label>
  </div>
  
  <div class="looper-button-with-label">
    <div class="looper-button record-button" id="looper-additive-button">
      <img src="looper button icons/add 1.svg" alt="Add" class="icon">
    </div>
    <label for="looper-additive-button" class="looper-label">ADD</label>
  </div>
  
  <div class="looper-button-with-label">
    <div class="looper-button orange-button" id="looper-delete-button">
      <img src="looper button icons/delete.svg" alt="Delete" class="icon">
    </div>
    <label for="looper-delete-button" class="looper-label">DEL</label>
  </div>
  
  <div class="looper-button-with-label">
    <div class="looper-button orange-button" id="looper-undo-button">
      <img src="looper button icons/undo 1.svg" alt="Undo" class="icon">
    </div>
    <label for="looper-undo-button" class="looper-label">UNDO</label>
  </div>
  
  <div class="looper-button-with-label">
    <div class="looper-button orange-button" id="looper-redo-button">
      <img src="looper button icons/redo 1.svg" alt="Redo" class="icon">
    </div>
    <label for="looper-redo-button" class="looper-label">REDO</label>
  </div>
</div>
  
  <div class="looper-columns">
    <!-- Column 1 -->
    <div class="looper-column">
      <!-- Layers knob (yellow, 8 notches) -->
      <div class="layers-knob-container">
        <div class="layers-markers">
          <div class="layer-marker" style="transform: rotate(-150deg) translateY(-30px) rotate(150deg);">1</div>
          <div class="layer-marker" style="transform: rotate(-107.14deg) translateY(-30px) rotate(107.14deg);">2</div>
          <div class="layer-marker" style="transform: rotate(-64.29deg) translateY(-30px) rotate(64.29deg);">3</div>
          <div class="layer-marker" style="transform: rotate(-21.43deg) translateY(-30px) rotate(21.43deg);">4</div>
          <div class="layer-marker" style="transform: rotate(21.43deg) translateY(-30px) rotate(-21.43deg);">5</div>
          <div class="layer-marker" style="transform: rotate(64.29deg) translateY(-30px) rotate(-64.29deg);">6</div>
          <div class="layer-marker" style="transform: rotate(107.14deg) translateY(-30px) rotate(-107.14deg);">7</div>
          <div class="layer-marker" style="transform: rotate(150deg) translateY(-30px) rotate(-150deg);">8</div>
        </div>
        <div class="shape-knob" id="looper-layers-knob" style="background-color: #E5AB5F; box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B; bottom: 0px; margin-bottom: 17px; margin-top: 2px;"></div>
        <label for="looper-layers-knob"style="
        margin-bottom: 0px; font-size: 10px; font-weight: 750; font-variant-caps: all-small-caps;">Layers</label>
      </div>
      
      <!-- Start knob (red) -->
      <div class="knob-container">
        <div class="knob" id="looper-start-knob" style="background-color: #CF814D; box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;"></div>
        <label for="looper-start-knob">Start</label>
      </div>
      
      <!-- Speed knob (blue) -->
      <div class="knob-container">
        <div class="knob" id="looper-speed-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
        <label for="looper-speed-knob">Speed</label>
      </div>
      
      <!-- Filter knob (green) -->
      <div class="knob-container">
        <div class="knob" id="looper-filter-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
        <label for="looper-filter-knob">Filter</label>
      </div>
    </div>
    
    <!-- Column 2 -->
    <div class="looper-column">
      <!-- Volume knob (yellow) -->
      <div class="knob-container">
        <div class="knob" id="looper-volume-knob" style="background-color: #E5AB5F; box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B;"></div>
        <label for="looper-volume-knob">Volume</label>
      </div>
      
      <!-- End knob (red) -->
      <div class="knob-container">
        <div class="knob" id="looper-end-knob" style="background-color: #CF814D; box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;"></div>
        <label for="looper-end-knob">End</label>
      </div>
      
      <!-- Dropouts knob (blue) -->
      <div class="knob-container">
        <div class="knob" id="looper-dropouts-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
        <label for="looper-dropouts-knob">Dropouts</label>
      </div>
      
      <!-- Stutter knob (green) -->
      <div class="knob-container">
        <div class="knob" id="looper-stutter-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
        <label for="looper-stutter-knob">Stutter</label>
      </div>
    </div>
    
    <!-- Column 3 -->
    <div class="looper-column">
      <!-- Lo-Fi knob (yellow) -->
      <div class="knob-container">
        <div class="knob" id="looper-lofi-knob" style="background-color: #E5AB5F; box-shadow: 0 0 0 4.2px #E5AB5F, 0 0 0 6px #35100B;"></div>
        <label for="looper-lofi-knob">Lo-Fi</label>
      </div>
      
      <!-- Repeats knob (red) -->
      <div class="knob-container">
        <div class="knob" id="looper-repeats-knob" style="background-color: #CF814D; box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;"></div>
        <label for="looper-repeats-knob">Repeats</label>
      </div>
      
      <!-- Jump knob (blue) -->
      <div class="knob-container">
        <div class="knob" id="looper-jump-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
        <label for="looper-jump-knob">Jump</label>
      </div>
      
      <!-- Pitch knob (green) -->
      <div class="knob-container">
        <div class="knob" id="looper-pitch-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
        <label for="looper-pitch-knob">Pitch</label>
      </div>
    </div>
  </div>
</div>

<!-- FX Module -->
<div class="module fx-module">
  <div class="module-title fx">FX</div>
  
  <!-- Chorus Button -->
  <div class="chorus-button-container">
    <div class="chorus-button" id="chorus-button">
      <span class="chorus-indicator first">I</span>
      <span class="chorus-indicator second">I</span>
    </div>
    <label for="chorus-button" style="margin-top: 4.5px;">Chorus</label>
  </div>
  
  <!-- Knob Column -->
  <div class="fx-knobs-column">
    <!-- Overload knob (yellow) -->
    <div class="knob-container">
      <div class="knob" id="overload-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
      <label for="overload-knob">Overload</label>
    </div>
    
    <!-- Cabinet knob (yellow) -->
    <div class="knob-container">
      <div class="knob" id="cabinet-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
      <label for="cabinet-knob">Cabinet</label>
    </div>
    
    <!-- Loss knob (blue) -->
    <div class="knob-container">
      <div class="knob" id="loss-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
      <label for="loss-knob">Loss</label>
    </div>
    
    <!-- Artifacts knob (blue) -->
    <div class="knob-container">
      <div class="knob" id="artifacts-knob" style="background-color: #4E658B; box-shadow: 0 0 0 4.2px #4E658B, 0 0 0 6px #35100B;"></div>
      <label for="artifacts-knob">Artifacts</label>
    </div>
  </div>
</div>
<!-- DELAY Module -->
<div class="module delay-module">
  <div class="module-title delay">
    <div class="delay-title-section red-title"></div>
    <div class="delay-title-section orange-title"></div>
    <div class="delay-title-section yellow-title"></div>
    <div class="delay-title-section green-title"></div>
    <span class="delay-title-text">DELAY</span>
  </div>
  
  <div class="delay-sections">
    <!-- Red Section (Time) -->
    <div class="delay-section red-section">
      <div class="delay-slider-container">
        <div class="delay-slider-track"></div>
        <input type="range" class="delay-slider" min="0" max="100" value="50" orient="vertical">
        <label class="delay-slider-label">Time</label>
      </div>
      
      <!-- Switches for Reverse and Freeze -->
      <div class="delay-switches"style="
      margin-bottom: 21px;
  ">
        <div class="delay-switch-container">
          <div class="horizontal-switch" id="reverse-switch"></div>
          <label for="reverse-switch" class="delay-switch-label">Reverse</label>
        </div>
        
        <div class="delay-switch-container">
          <div class="horizontal-switch" id="freeze-switch"></div>
          <label for="freeze-switch" class="delay-switch-label">Freeze</label>
        </div>
      </div>
    </div>
    
    <!-- Orange Section (Length) -->
    <div class="delay-section orange-section">
      <div class="delay-slider-container">
        <div class="delay-slider-track"></div>
        <input type="range" class="delay-slider" min="0" max="100" value="50" orient="vertical">
        <label class="delay-slider-label">Length</label>
      </div>
      
      <!-- Low Cut knob -->
      <div class="knob-container">
        <div class="knob" id="low-cut-knob" style="background-color: #CF814D; box-shadow: 0 0 0 4.2px #CF814D, 0 0 0 6px #35100B;"></div>
        <label for="low-cut-knob">Low Cut</label>
      </div>
    </div>
    
    <!-- Yellow Section (Feedback) -->
    <div class="delay-section yellow-section">
      <div class="delay-slider-container">
        <div class="delay-slider-track"></div>
        <input type="range" class="delay-slider" min="0" max="100" value="50" orient="vertical">
        <label class="delay-slider-label">Feedback</label>
      </div>
      
      <!-- High Cut knob -->
      <div class="knob-container">
        <div class="knob" id="high-cut-knob" style="background-color: #BA5446; box-shadow: 0 0 0 4.2px #BA5446, 0 0 0 6px #35100B;"></div>
        <label for="high-cut-knob">High Cut</label>
      </div>
    </div>
    
    <!-- Green Section (Density) -->
    <div class="delay-section green-section">
      <div class="delay-slider-container">
        <div class="delay-slider-track"></div>
        <input type="range" class="delay-slider" min="0" max="100" value="50" orient="vertical">
        <label class="delay-slider-label">Density</label>
      </div>
      
      <!-- Mix knob -->
      <div class="knob-container">
        <div class="knob" id="mix-knob" style="background-color: #6B8F53; box-shadow: 0 0 0 4.2px #6B8F53, 0 0 0 6px #35100B;"></div>
        <label for="mix-knob">Mix</label>
      </div>
    </div>
  </div>
</div>
        </div> <!-- End of synth-panel -->
        
        <!-- Keyboard -->
        <div class="keyboard" id="keyboard">
            <!-- Keys will be generated by JavaScript -->
        </div>
        
        <div class="voice-monitor">
            <h3>Active Voices: <span id="voice-count">0</span>/6</h3>
            <div id="voice-display"></div>
        </div>
    </div>

    <script>
      
        const D = x => document.getElementById(x);
        const TR2 = 2 ** (1.0 / 12.0);
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        masterGain.connect(audioCtx.destination);


// Main keys (first + second octave)
const keys = [
  'Z','S','X','D','C','V','G','B','H','N','J','M',  // First octave
  'Q','2','W','3','E','R','5','T','6','Y','7','U'   // Second octave
];

// Extra punctuation  note index mapping (second octave)
const specialKeyMap = {
  ',': 12, // C
  '.': 14, // D
  '/': 16, // E
  'L': 13, // C#
  'l': 13, // Handle lowercase L
  ';': 15,  // D#
    // Third octave (C through G):
    'I': 24, // C
    "i": 24, // Handle lowercase I
  '9': 25, // C#
  'O': 26, // D
  "o": 26, // Handle lowercase O
  '0': 27, // D#
  'P': 28, // E
  "p": 28, // Handle lowercase P
  '[': 29, // F
  '=': 30, // F#
  ']': 31  // G
};

// Add this after the masterGain initialization
let currentVolume = 0.5; // Initial volume
masterGain.gain.setValueAtTime(currentVolume, audioCtx.currentTime, 0.01);
// Add these global variables at the top with other audio-related variables
// Add to your global variables
let currentSampleDetune = 0; // Range will be -1200 to +1200 cents
let isEmuModeOn = false;
let isSampleKeyTrackingOn = true;
let mediaRecorder = null;
let isSampleReversed = false;
let originalBuffer = null;
let recordedChunks = [];
let isRecording = false;
let recordingStartTime = null;
let fadedBufferOriginalDuration = null;
let emuFilterNode = null;
let lastPlayedNote = null;
let sampleSource = null;
let isPlaying = false;
let sampleStartPosition = 0; // 0-1 range representing portion of audio file
let sampleEndPosition = 1;   // 0-1 range (default to full sample)
let sampleCrossfadeAmount = 0; // 0-1 range for crossfade percentage
let isSampleLoopOn = false; // Will now be controlled by crossfade knob
let cachedCrossfadedBuffer = null;
let crossfadeUpdateTimer = null;
let sampleFadeInAmount = 0;
let sampleFadeOutAmount = 0;
let fadeProcessTimer = null;
let fadedBuffer = null;
let startUpdateTimer = null;
let endUpdateTimer = null;
let lastCachedStartPos = null;
let lastCachedEndPos = null;
let lastCachedCrossfade = null;
// Add at top with other global variables
sampleGainNode = audioCtx.createGain();
sampleGainNode.gain.value = 0.5;
// Update the createNote function to use a reference to the current gain value
let currentSampleGain = 0.5; // Add this with other global variables
let currentSamplePosition = 0; // Add this with other global variables
const knobDefaults = {
  'sample-start-knob': 0.0,     // Start at beginning of sample
  'sample-end-knob': 1.0,       // End at end of sample
  'sample-crossfade-knob': 0.0, // No crossfade initially
  'glide-time-knob': 0.05,      // 100ms (5% of 2000ms)
  // All other knobs default to 0.5
};
// Replace all knob-related code with this single implementation
// Add touch support for knobs and keyboard
// Create a startup overlay for iOS devices
function createiOSStartupOverlay() {
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.backgroundColor = 'rgba(245, 245, 220, 0.95)';
  overlay.style.zIndex = '9999';
  overlay.style.display = 'flex';
  overlay.style.flexDirection = 'column';
  overlay.style.justifyContent = 'center';
  overlay.style.alignItems = 'center';
  overlay.style.textAlign = 'center';
  
  const heading = document.createElement('h2');
  heading.textContent = 'THULE Sampler';
  heading.style.color = '#8b4513';
  heading.style.marginBottom = '20px';
  
  const message = document.createElement('p');
  message.textContent = 'Tap anywhere to enable audio';
  message.style.marginBottom = '30px';
  message.style.color = '#35100B';
  
  const button = document.createElement('button');
  button.textContent = 'Start Synth';
  button.style.padding = '15px 30px';
  button.style.fontSize = '18px';
  button.style.backgroundColor = '#e6e6e6';
  button.style.border = '1px solid #35100B';
  button.style.borderRadius = '8px';
  button.style.color = '#35100B';
  button.style.cursor = 'pointer';
  
  overlay.appendChild(heading);
  overlay.appendChild(message);
  overlay.appendChild(button);
  
  // Make sure overlay is in the DOM before adding audio context
  document.body.appendChild(overlay);
  
// Prepare the audio context but don't resume yet
if (window.AudioContext || window.webkitAudioContext) {
    // Use your own silent audio file
    const silentAudio = document.createElement('audio');
    silentAudio.src = 'silence.mp3'; // Path to your silent audio file
    silentAudio.setAttribute('loop', 'loop');
    silentAudio.setAttribute('preload', 'auto');
    silentAudio.style.display = 'none';
    document.body.appendChild(silentAudio);
    
    function unlockAudio(event) {
      // This is the key change: multiple unlock methods in a synchronous user event handler
      
      // 1. Play the silent audio element first (this works for iOS Chrome)
      const playPromise = silentAudio.play();
      
      // 2. Resume the AudioContext
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      
      // 3. Create and play an immediate oscillator (works in Safari)
      try {
        const oscillator = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.001; // Nearly silent
        oscillator.connect(gain);
        gain.connect(audioCtx.destination);
        oscillator.start(0);
        oscillator.stop(0.5);
      } catch(e) {
        console.log("Error creating oscillator:", e);
      }
      
      // 4. Create and play a buffer source (alternative method)
      try {
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0);
      } catch(e) {
        console.log("Error playing buffer:", e);
      }
      
      console.log("Audio unlock attempts complete, removing overlay");
      
      // Remove the overlay with slight delay
      setTimeout(() => {
        document.body.removeChild(overlay);
        // Keep the silent audio element playing in the background
      }, 50);
      
      // Clean up event listeners
      overlay.removeEventListener('touchstart', unlockAudio);
      button.removeEventListener('touchstart', unlockAudio);
      overlay.removeEventListener('click', unlockAudio);
      
      // Prevent default
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    
    // Add event listeners for both touch and click
    overlay.addEventListener('touchstart', unlockAudio, { passive: false });
    button.addEventListener('touchstart', unlockAudio, { passive: false });
    overlay.addEventListener('click', unlockAudio);
  }
}

// Initialize for all mobile devices to be safe
if (/iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  // Use DOMContentLoaded for more reliable initialization
  document.addEventListener('DOMContentLoaded', () => {
    createiOSStartupOverlay();
  });
}
// Add this function at the beginning of your script
function createIOSChromeAudioUnlocker() {
  // Create a special overlay for Chrome on iOS
  const overlay = document.createElement('div');
  overlay.innerHTML = `
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
         background: rgba(245, 245, 220, 0.95); z-index: 99999; display: flex; 
         flex-direction: column; justify-content: center; align-items: center; text-align: center;">
      <h2 style="color: #8b4513;">THULE Sampler</h2>
      <p style="margin: 20px 0;">Tap the button below to enable audio</p>
      <button id="ios-chrome-audio-unlock" style="padding: 16px 32px; font-size: 18px; 
              background: #e6e6e6; border: 1px solid #35100B; border-radius: 8px; 
              color: #35100B; cursor: pointer;">START SYNTHESIZER</button>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Create a hidden HTML5 audio element (crucial for Chrome on iOS)
  const audioElement = document.createElement('audio');
  audioElement.setAttribute('src', 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABIgD///////////////////////////////////////////8AAAA8TEFNRTMuMTAwAQAAAAAAAAAAABUgJAMGQQABmgAAIicg4EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=');
  audioElement.setAttribute('playsinline', '');
  audioElement.setAttribute('preload', 'auto');
  audioElement.setAttribute('loop', 'loop');
  audioElement.style.display = 'none';
  document.body.appendChild(audioElement);
  
  // Function to unlock audio with special handling for Chrome on iOS
  function unlockAudioForChromeIOS() {
    console.log("Attempting to unlock audio for Chrome on iOS");
    
    // 1. First, try to play the HTML5 audio element
    const playPromise = audioElement.play();
    
    if (playPromise !== undefined) {
      playPromise.then(() => {
        console.log("Audio element playback successful");
        
        // 2. After successful audio element play, resume AudioContext
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => {
            console.log("AudioContext resumed");
          }).catch(err => {
            console.error("Failed to resume AudioContext:", err);
          });
        }
        
        // 3. Create a silent oscillator (important for iOS Chrome)
        try {
          const oscillator = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          gain.gain.value = 0.001;
          oscillator.connect(gain);
          gain.connect(audioCtx.destination);
          oscillator.start(0);
          oscillator.stop(audioCtx.currentTime + 0.5);
          console.log("Created silent oscillator");
        } catch(e) {
          console.error("Failed to create oscillator:", e);
        }
        
        // Remove the overlay
        setTimeout(() => {
          document.body.removeChild(overlay);
        }, 100);
        
      }).catch(err => {
        console.error("Audio playback failed:", err);
        // Show a more direct error message to the user
        alert("Audio couldn't be enabled. Please reload and try again, making sure to tap directly on the button.");
      });
    }
  }
  
  // Add event listener directly to the button
  document.getElementById('ios-chrome-audio-unlock').addEventListener('click', unlockAudioForChromeIOS);
  document.getElementById('ios-chrome-audio-unlock').addEventListener('touchend', unlockAudioForChromeIOS);
}
// Function to detect Chrome on iOS specifically
function isChromeOnIOS() {
  const userAgent = navigator.userAgent;
  return /iPad|iPhone|iPod/.test(userAgent) && /CriOS/.test(userAgent);
}

// Show the special Chrome iOS unlocker only when needed
document.addEventListener('DOMContentLoaded', function() {
  if (isChromeOnIOS()) {
    console.log("Detected Chrome on iOS - showing special audio unlock UI");
    createIOSChromeAudioUnlocker();
  } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
    // Use your original iOS unlocker for Safari
    createiOSStartupOverlay();
  }
});
// Detect if the device is a touch device
function isTouchDevice() {
  return ('ontouchstart' in window) || 
         (navigator.maxTouchPoints > 0) || 
         (navigator.msMaxTouchPoints > 0);
}

function initializeKnob(knob, onChange) {
  // Remove any existing event listeners first
  const newKnob = knob.cloneNode(true);
  knob.parentNode.replaceChild(newKnob, knob);
  knob = newKnob;
  
  // Use default value from knobDefaults if available, otherwise 0.5
  const defaultValue = knobDefaults[knob.id] !== undefined ? knobDefaults[knob.id] : 0.5;
  
  // Set initial rotation based on default value WITHOUT triggering tooltip
  let rotation = -150 + (defaultValue * 300);
  let isDragging = false;
  let lastY;
  let initialMovement = true;  // Flag to track first movement

  // Set the initial visual rotation
  knob.style.transform = `rotate(${rotation}deg)`;

  function resetToDefault() {
    rotation = -150 + (defaultValue * 300);
    knob.style.transform = `rotate(${rotation}deg)`;
    if (onChange) {
      onChange(defaultValue);
    }
  }

  function handleMove(y) {
    const sensitivity = 1.0;
    const deltaY = (lastY - y) * sensitivity;
    
    if (initialMovement) {
      // On first movement, just record the position but don't apply the delta
      initialMovement = false;
      lastY = y;
      return;
    }

    lastY = y;
    
    const newRotation = Math.min(150, Math.max(-150, rotation + deltaY));
    
    if (newRotation !== rotation) {
      rotation = newRotation;
      knob.style.transform = `rotate(${rotation}deg)`;
      
      if (onChange) {
        const normalizedValue = (rotation + 150) / 300;
        onChange(normalizedValue);
      }
    }
  }

  function handleMouseMove(e) {
    if (!isDragging) return;
    handleMove(e.clientY);
    e.preventDefault();
    e.stopPropagation();
  }

  function handleTouchMove(e) {
    if (!isDragging || !e.touches[0]) return;
    handleMove(e.touches[0].clientY);
    
    // Critical: prevent default to stop page scrolling while turning knobs
    e.preventDefault();
    e.stopPropagation();
  }

  function handleEnd() {
    isDragging = false;
    initialMovement = true; // Reset for next drag
    knob.style.cursor = 'grab';
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleEnd);
    document.removeEventListener('touchcancel', handleEnd);
  }

  knob.addEventListener('click', (e) => {
    if (e.altKey) {
      resetToDefault();
    }
  });

  knob.addEventListener('dblclick', () => {
    resetToDefault();
  });

  knob.addEventListener('mousedown', (e) => {
    if (!e.altKey) {
      isDragging = true;
      initialMovement = true; // Reset flag on new drag
      lastY = e.clientY;
      knob.style.cursor = 'grabbing';
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleEnd);
    }
    e.preventDefault();
  });

  // Add touch support with proper scroll prevention
  knob.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      initialMovement = true;
      lastY = e.touches[0].clientY;
      
      // Critical: add touchmove listener with passive: false to allow preventDefault
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleEnd);
      document.addEventListener('touchcancel', handleEnd);
    }
    e.preventDefault();
  }, { passive: false });

  // Also update the parameters directly when the default is applied
  if (knob.id === 'sample-start-knob') {
    sampleStartPosition = defaultValue;
  } else if (knob.id === 'sample-end-knob') {
    sampleEndPosition = defaultValue;
  } else if (knob.id === 'sample-crossfade-knob') {
    sampleCrossfadeAmount = defaultValue;
    isSampleLoopOn = defaultValue > 0.01;
  } else if (knob.id === 'glide-time-knob') {
    glideTime = defaultValue * 2; // 0-2 seconds range
  }

  return {
    getValue: () => (rotation + 150) / 300,
    setValue: (value, triggerOnChange = false) => {
      const newRotation = (value * 300) - 150;
      rotation = Math.min(150, Math.max(-150, newRotation));
      knob.style.transform = `rotate(${rotation}deg)`;
      
      // Only trigger onChange if explicitly requested
      if (onChange && triggerOnChange) {
        onChange(value);
      }
    }
  };
}
function reverseBufferIfNeeded() {
  if (!originalBuffer) return;
  
  if (isSampleReversed) {
    // Create reversed version of the buffer
    const reversedBuffer = audioCtx.createBuffer(
      originalBuffer.numberOfChannels,
      originalBuffer.length,
      originalBuffer.sampleRate
    );
    
    // Copy and reverse each channel
    for (let channel = 0; channel < originalBuffer.numberOfChannels; channel++) {
      const originalData = originalBuffer.getChannelData(channel);
      const reversedData = reversedBuffer.getChannelData(channel);
      
      for (let i = 0; i < originalBuffer.length; i++) {
        reversedData[i] = originalData[originalBuffer.length - 1 - i];
      }
    }
    
    // Use the reversed buffer for processing
    audioBuffer = reversedBuffer;
  } else {
    // Use the original buffer
    audioBuffer = originalBuffer.slice();
  }
}
if (!AudioBuffer.prototype.slice) {
  AudioBuffer.prototype.slice = function() {
    const newBuffer = audioCtx.createBuffer(
      this.numberOfChannels,
      this.length,
      this.sampleRate
    );
    
    for (let channel = 0; channel < this.numberOfChannels; channel++) {
      const originalData = this.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      for (let i = 0; i < this.length; i++) {
        newData[i] = originalData[i];
      }
    }
    
    return newBuffer;
  };
}
// FIXED VERSION
function fixMicRecording() {
  // Get button reference FIRST
  const recButton = document.getElementById('mic-record-button');
  if (!recButton) return;
  
  // Then clone it
  const newRecButton = recButton.cloneNode(true);
  recButton.parentNode.replaceChild(newRecButton, recButton);
  
  // NOW you can safely access elements inside it
  const recLed = newRecButton.querySelector('.led-indicator');
  
  // Global state
  let localIsRecording = false;
  let processingLock = false;
  let audioInputStream = null;
  let audioInputNode = null;
  let recordingChunks = [];
  let recorderWorklet = null;
  
  // First, create and register the AudioWorklet processor
  const workletCode = `
  class RecorderWorkletProcessor extends AudioWorkletProcessor {
    constructor() {
      super();
      this.isRecording = false;
      
      // ADD THIS HANDLER - it was completely missing!
      this.port.onmessage = (event) => {
        if (event.data.command === 'setRecording') {
          console.log("RecorderWorklet: Set recording to", event.data.value);
          this.isRecording = event.data.value;
        }
      };
    }
    
    process(inputs, outputs, parameters) {
      if (!this.isRecording || !inputs[0] || !inputs[0][0]) return true;
      
      // Clone the input data to send to main thread
      const inputData = inputs[0][0];
      const buffer = new Float32Array(inputData.length);
      buffer.set(inputData);
      
      // Send buffer to main thread
      this.port.postMessage({ type: 'chunk', data: buffer });
      
      return true;
    }
  }
  
  registerProcessor('recorder-processor', RecorderWorkletProcessor);
`;
  // Create a Blob URL for the worklet code
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const workletUrl = URL.createObjectURL(blob);
  
  // Register the worklet with the audio context
  let workletReady = false;
  
  audioCtx.audioWorklet.addModule(workletUrl).then(() => {
    workletReady = true;
    console.log("Audio worklet ready for recording");
  }).catch(err => {
    console.error("Error loading audio worklet:", err);
  });
  
  newRecButton.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (processingLock) return;
    processingLock = true;
    setTimeout(() => { processingLock = false; }, 300);
    
    if (localIsRecording) {
      stopRecording();
    } else {
      startRecording();
    }
  });
  
  async function startRecording() {
    try {
      if (!workletReady) {
        console.error("Audio worklet not ready yet");
        return;
      }
      
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Update UI
      newRecButton.classList.add('recording');
      if (recLed) recLed.classList.add('on');
      localIsRecording = true;
      
      // Reset recording chunks
      recordingChunks = [];
      
      // Create audio input source
      audioInputStream = stream;
      audioInputNode = audioCtx.createMediaStreamSource(stream);
      
      // Create and connect the AudioWorkletNode for recording
      recorderWorklet = new AudioWorkletNode(audioCtx, 'recorder-processor');
      
      // Set up message handling to collect audio chunks
      recorderWorklet.port.onmessage = (event) => {
        if (event.data.type === 'chunk') {
          recordingChunks.push(event.data.data);
        }
      };
      
      // Tell the worklet to start recording
      recorderWorklet.port.postMessage({ command: 'setRecording', value: true });
      
      // Connect the nodes
      audioInputNode.connect(recorderWorklet);
      recorderWorklet.connect(audioCtx.destination);
      
      console.log("Recording started with AudioWorkletNode");
    } catch (err) {
      console.error("Error starting recording:", err);
    }
  }
  
  function stopRecording() {
    
    // Clean up BEFORE updating UI
    if (audioInputStream) {
      try {
        audioInputStream.getTracks().forEach(track => track.stop());
      } catch(e) {
        console.error("Error stopping tracks:", e);
      }
    }
    
    // Handle each node individually
    if (audioInputNode) {
      try {
        audioInputNode.disconnect();
      } catch(e) {
        console.error("Error disconnecting input node:", e);
      }
    }
    
    if (recorderWorklet) {
      try {
        // Tell the worklet to stop recording
        recorderWorklet.port.postMessage({ command: 'setRecording', value: false });
        recorderWorklet.disconnect();
      } catch(e) {
        console.error("Error disconnecting recorder worklet:", e);
      }
    }
    
    // NOW update UI
    newRecButton.classList.remove('recording');
    if (recLed) recLed.classList.remove('on');
    localIsRecording = false;
    
    // Process the recording chunks if we have any
    if (recordingChunks && recordingChunks.length > 0) {
      processRecording(recordingChunks);
    }
  }

  function processRecording(chunks) {
  console.log("Processing recorded audio...");

  // 1) Build one buffer from the recorded chunks
  let totalLength = 0;
  for (let i = 0; i < chunks.length; i++) {
    totalLength += chunks[i].length;
  }
  const newBuffer = audioCtx.createBuffer(1, totalLength, audioCtx.sampleRate);
  const channelData = newBuffer.getChannelData(0);
  let offset = 0;
  for (let i = 0; i < chunks.length; i++) {
    channelData.set(chunks[i], offset);
    offset += chunks[i].length;
  }

  // 2) Use the same global audioBuffer
  audioBuffer = newBuffer; 
  console.log("Recording loaded as sample with duration:", audioBuffer.duration);
  originalBuffer = newBuffer.slice(); // Store the original buffer
      
      // Apply reverse if needed
      if (isSampleReversed) {
        reverseBufferIfNeeded();
      }
  // 3) Process fades and crossfades using the same function
  updateSampleProcessing();

  // 4) Reset crossfade data to match loadPresetSample approach
  cachedCrossfadedBuffer = null;
  lastCachedStartPos = null;
  lastCachedEndPos = null;
  lastCachedCrossfade = null;

  // 5) Create and connect a new source node, just like in loadPresetSample
  if (sampleSource) {
    sampleSource.stop();
  }
  sampleSource = audioCtx.createBufferSource();
  sampleSource.buffer = audioBuffer;
  sampleSource.connect(sampleGainNode);
  sampleSource.start();

  // 6) Set UI label (equivalent to showing loaded sample name)
  const fileLabel = document.querySelector('label[for="audio-file"]');
  if (fileLabel) {
    fileLabel.textContent = 'Recording (mic)';
  }

  // 7) Create crossfaded buffer if needed
  if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
    console.log("Creating crossfaded buffer for recorded sample");
    const result = createCrossfadedBuffer(
      audioBuffer,
      sampleStartPosition,
      sampleEndPosition,
      sampleCrossfadeAmount
    );
    if (result && result.buffer) {
      console.log("Successfully created crossfaded buffer for recorded sample");
      cachedCrossfadedBuffer = result.buffer;
      lastCachedStartPos = sampleStartPosition;
      lastCachedEndPos = sampleEndPosition;
      lastCachedCrossfade = sampleCrossfadeAmount;
    }
  }

  // 8) Update any active notes to use the new buffer, same as loadPresetSample
  Object.values(activeNotes).forEach(note => {
    if (note && note.source) {
      // Skip held notes
      if (heldNotes.includes(note.noteNumber)) {
        console.log(`Note ${note.id} is held; will update on release.`);
        return;
      }
      console.log(`Updating note ${note.id} to use recorded sample`);
      note.usesProcessedBuffer = false;
      note.crossfadeActive = false;
      if (isSampleLoopOn) {
        note.looping = true;
        setupLoopCrossfade(note);
      }
      updateSamplePlaybackParameters(note);
    }
  });
}
}
function preventScrollOnControls() {
  // More targeted approach - add touch event handlers to each UI control type individually
  
  
  
  // 2. Fix sliders
  document.querySelectorAll('input[type="range"]').forEach(slider => {
    slider.addEventListener('touchstart', function(e) {
      // Don't prevent default on sliders to allow native handling
    }, { passive: false });
  });
  

  

  
  // 5. Fix special buttons (emu mode and rec button)
  document.querySelectorAll('.lofi-button, .rec-button').forEach(button => {
    button.addEventListener('touchstart', function(e) {
      e.preventDefault();
      // Simulate a click
      button.click();
    }, { passive: false });
  });
  
  
}
/**
 * Creates a properly loopable buffer with crossfades baked in.
 */

 function createCrossfadedBuffer(originalBuffer, startFraction, endFraction, crossfadeAmount) {
  try {
    // Basic parameter checks
    if (!originalBuffer || originalBuffer.length === 0) {
      console.log("No buffer provided or empty buffer");
      return null;
    }
    
    if (crossfadeAmount <= 0.00001) {
      console.log("Crossfade amount too small");
      return null;
    }
    
    // IMPORTANT: Use the original buffer for consistency 
    // This ensures the lead-in audio matches the main loop content
    const sourceBuffer = originalBuffer; 
    const sampleRate = sourceBuffer.sampleRate;
    const channels = sourceBuffer.numberOfChannels;
    const totalSamples = sourceBuffer.length;
    const channel0Data = sourceBuffer.getChannelData(0);
    
    // Calculate sample indices and loop length
    let startSamplePos = Math.floor(startFraction * totalSamples);
    const endSamplePos = Math.floor(endFraction * totalSamples);
    let loopLength = endSamplePos - startSamplePos;
    
    // Check for minimum viable loop length
    const minimumSamples = Math.max(100, Math.floor(totalSamples * 0.001));
    if (loopLength < minimumSamples) {
      console.log(`Loop length (${loopLength} samples) is too short for crossfading. Minimum: ${minimumSamples}`);
      return { buffer: fadedBuffer || originalBuffer, adjustedStartFraction: startFraction };
    }
    
    // For very small crossfades (<20%), we just use zero-crossing alignment without crossfade
    if (crossfadeAmount < 0.20) {
      console.log("Using pure zero-crossing alignment for small crossfade");
      
      // Zero crossing detection code (unchanged)
      const searchWindowSamples = Math.ceil(sampleRate * 0.01);
      const startCrossings = [];
      const startMin = Math.max(0, startSamplePos - searchWindowSamples);
      const startMax = Math.min(totalSamples - 2, startSamplePos + searchWindowSamples);
      
      for (let i = startMin; i < startMax; i++) {
        if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
          startCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'rising'
          });
        }
        else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
          startCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'falling'
          });
        }
      }
      
      const endCrossings = [];
      const endMin = Math.max(0, endSamplePos - searchWindowSamples);
      const endMax = Math.min(totalSamples - 2, endSamplePos + searchWindowSamples);
      
      for (let i = endMin; i < endMax; i++) {
        if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
          endCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'rising'
          });
        }
        else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
          endCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'falling'
          });
        }
      }
      
      console.log(`Found ${startCrossings.length} start and ${endCrossings.length} end zero crossings`);
      
      if (startCrossings.length > 0 && endCrossings.length > 0) {
        let bestMatch = { score: -Infinity, start: startSamplePos, end: endSamplePos };
        
        for (const start of startCrossings) {
          for (const end of endCrossings) {
            const typeScore = (start.type === end.type) ? 5 : -2;
            const slopeScore = 5 - Math.min(5, Math.abs(start.slope - end.slope) * 20);
            const distanceScore = 3 - Math.min(3, 
              (Math.abs(start.index - startSamplePos) + 
               Math.abs(end.index - endSamplePos)) / (searchWindowSamples * 2) * 3);
            
            const score = typeScore + slopeScore + distanceScore;
            
            if (score > bestMatch.score) {
              bestMatch = {
                score,
                start: start.index,
                end: end.index
              };
            }
          }
        }
        
        if (bestMatch.score > 0) {
          console.log(`Using zero crossings: start=${bestMatch.start}, end=${bestMatch.end}, score=${bestMatch.score.toFixed(2)}`);
          startSamplePos = bestMatch.start;
          endSamplePos = bestMatch.end;
          loopLength = endSamplePos - startSamplePos;
        }
      }
      
      const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
      
      for (let channel = 0; channel < channels; channel++) {
        const origData = sourceBuffer.getChannelData(channel);
        const newData = newBuffer.getChannelData(channel);
        
        for (let i = 0; i < loopLength; i++) {
          newData[i] = origData[startSamplePos + i];
        }
      }
      
      return { buffer: newBuffer, adjustedStartFraction: startSamplePos / totalSamples };
    }
    
    // For larger crossfades (20%), implement a robust crossfade with phase alignment
    console.log("Using enhanced phase-aligned crossfade for larger fade amount");

    // IMPROVED CROSSFADE LENGTH CALCULATION
    // This is a critical part for consistent results
    const minFadeSamples = Math.max(Math.round(sampleRate * 0.015), 100); // minimum 15ms fade
    const maxFadeSamples = Math.floor(loopLength * 0.4); // maximum 40% of loop length

    // Calculate fade length based on crossfade amount with better scaling
    let fadeLengthSamples;
    if (crossfadeAmount >= 0.95) {
      // Near 100% - use most of the available loop length
      fadeLengthSamples = maxFadeSamples;
    } else if (crossfadeAmount < 0.3) {
      // Small crossfades (20-30%) - use fixed duration
      fadeLengthSamples = Math.max(minFadeSamples, Math.round(sampleRate * 0.035)); // 35ms minimum
    } else {
      // Mid-range crossfades - use balanced approach with cubic easing
      // This easing function provides smoother scaling across percentage ranges
      const t = crossfadeAmount;
      const easedT = t * t * (3 - 2 * t); // Smooth step function
      fadeLengthSamples = Math.floor(minFadeSamples + (maxFadeSamples - minFadeSamples) * easedT);
    }

    console.log(`Fade length: ${fadeLengthSamples} samples (${fadeLengthSamples/sampleRate}s), ${(fadeLengthSamples/loopLength*100).toFixed(1)}% of loop`);
    
    // Ensure we have enough samples before start for lead-in
    if (startSamplePos < fadeLengthSamples) {
      startSamplePos = fadeLengthSamples;
      loopLength = endSamplePos - startSamplePos;
    }
    
    // ENHANCED CROSSFADE REGION ANALYSIS
    // Find the best matching lead-in segment with multiple criteria
    
    // First analyze the crossfade region characteristics
    const crossfadeStartPos = endSamplePos - fadeLengthSamples;
    
    // Multiple analysis points for better matching - analyze the ENTIRE crossfade region
    const analysisPoints = 5; // Sample 5 points across the crossfade region
    const crossfadeCharacteristics = [];
    
    for (let i = 0; i < analysisPoints; i++) {
      const position = crossfadeStartPos + Math.floor(i * fadeLengthSamples / (analysisPoints - 1));
      
      // Detect zero-crossing near this position
      let crossType = null;
      let isRising = false;
      
      // Check 3 samples before and after
      for (let j = -3; j <= 2; j++) {
        const idx = Math.max(0, Math.min(position + j, totalSamples - 2));
        if (channel0Data[idx] <= 0 && channel0Data[idx + 1] > 0) {
          crossType = 'rising';
          isRising = true;
          break;
        } else if (channel0Data[idx] >= 0 && channel0Data[idx + 1] < 0) {
          crossType = 'falling';
          isRising = false;
          break;
        }
      }
      
      // If no zero crossing, analyze slope and polarity
      if (!crossType) {
        const p0 = channel0Data[Math.max(0, position - 3)];
        const p1 = channel0Data[position];
        const p2 = channel0Data[Math.min(totalSamples - 1, position + 3)];
        
        isRising = (p2 > p0);
        crossType = p1 >= 0 ? 'positive' : 'negative';
      }
      
      // Calculate local amplitude
      const amplitude = Math.abs(channel0Data[position]);
      
      // Calculate local frequency using zero-crossing rate
      let localFreq = 0;
      const freqWindow = 20;
      let crossings = 0;
      
      for (let j = Math.max(0, position - freqWindow); j < Math.min(totalSamples - 1, position + freqWindow); j++) {
        if ((channel0Data[j] <= 0 && channel0Data[j + 1] > 0) || 
            (channel0Data[j] >= 0 && channel0Data[j + 1] < 0)) {
          crossings++;
        }
      }
      
      localFreq = crossings / (freqWindow * 2);
      
      // Store the characteristics at this point
      crossfadeCharacteristics.push({
        position,
        crossType,
        isRising,
        amplitude,
        localFreq
      });
    }
    
    // Now find the best matching lead-in section
    const searchWindow = Math.min(Math.floor(sampleRate * 0.1), Math.floor(loopLength * 0.3)); // 100ms or 30% of loop
    const searchStartPoint = startSamplePos - fadeLengthSamples;
    let bestLeadInPos = searchStartPoint;
    let bestScore = -1000;
    
    // Try different potential lead-in positions and score them
    for (let offset = -searchWindow; offset <= searchWindow; offset += 5) { // Step by 5 samples for efficiency
      const testPos = searchStartPoint + offset;
      if (testPos < 0 || testPos + fadeLengthSamples >= crossfadeStartPos) {
        continue;
      }
      
      let totalScore = 0;
      
      // Score based on matching the characteristics at each analysis point
      for (let i = 0; i < analysisPoints; i++) {
        const targetChar = crossfadeCharacteristics[i];
        const relativePos = Math.floor(i * fadeLengthSamples / (analysisPoints - 1));
        const testSamplePos = testPos + relativePos;
        
        let pointScore = 0;
        
        // Check for matching zero crossing type
        let testCrossType = null;
        let testIsRising = false;
        
        // Look for zero crossing near this test position
        for (let j = -3; j <= 2; j++) {
          const idx = Math.max(0, Math.min(testSamplePos + j, totalSamples - 2));
          if (channel0Data[idx] <= 0 && channel0Data[idx + 1] > 0) {
            testCrossType = 'rising';
            testIsRising = true;
            break;
          } else if (channel0Data[idx] >= 0 && channel0Data[idx + 1] < 0) {
            testCrossType = 'falling';
            testIsRising = false;
            break;
          }
        }
        
        if (!testCrossType) {
          const p0 = channel0Data[Math.max(0, testSamplePos - 3)];
          const p1 = channel0Data[testSamplePos];
          const p2 = channel0Data[Math.min(totalSamples - 1, testSamplePos + 3)];
          
          testIsRising = (p2 > p0);
          testCrossType = p1 >= 0 ? 'positive' : 'negative';
        }
        
        // Score matching characteristics
        if (testCrossType === targetChar.crossType) {
          pointScore += 30;
        }
        
        if (testIsRising === targetChar.isRising) {
          pointScore += 20;
        }
        
        // Calculate amplitude similarity
        const testAmplitude = Math.abs(channel0Data[testSamplePos]);
        const ampDiff = Math.abs(targetChar.amplitude - testAmplitude);
        pointScore += 20 - Math.min(20, ampDiff * 40);
        
        // Calculate local frequency
        let testCrossings = 0;
        const freqWindow = 20;
        
        for (let j = Math.max(0, testSamplePos - freqWindow); j < Math.min(totalSamples - 1, testSamplePos + freqWindow); j++) {
          if ((channel0Data[j] <= 0 && channel0Data[j + 1] > 0) || 
              (channel0Data[j] >= 0 && channel0Data[j + 1] < 0)) {
            testCrossings++;
          }
        }
        
        const testLocalFreq = testCrossings / (freqWindow * 2);
        const freqDiff = Math.abs(targetChar.localFreq - testLocalFreq);
        pointScore += 20 - Math.min(20, freqDiff * 100);
        
        // Add to total score (weight later points slightly more)
        totalScore += pointScore * (0.8 + 0.2 * i / analysisPoints);
      }
      
      // Additional score for proximity to original position
      totalScore += 50 - Math.min(50, Math.abs(offset) / searchWindow * 50);
      
      // Check for best score
      if (totalScore > bestScore) {
        bestScore = totalScore;
        bestLeadInPos = testPos;
      }
    }
    
    console.log(`Selected lead-in position: ${bestLeadInPos}, score: ${bestScore.toFixed(1)}`);
    
    // FINE-TUNE THE LEAD-IN POSITION FOR PRECISE PHASE ALIGNMENT
    // Once we have the approximate best position, do a fine-grained search for perfect phase alignment
    let fineTunedLeadIn = bestLeadInPos;
    let fineTuneScore = -1000;
    
    for (let fineOffset = -10; fineOffset <= 10; fineOffset++) {
      const testPos = bestLeadInPos + fineOffset;
      if (testPos < 0) continue;
      
      // Focus on precise alignment at the start of crossfade region
      const endPhase = channel0Data[crossfadeStartPos];
      const endSlope = channel0Data[crossfadeStartPos + 1] - channel0Data[crossfadeStartPos];
      
      const testPhase = channel0Data[testPos];
      const testSlope = channel0Data[testPos + 1] - channel0Data[testPos];
      
      // Score based on phase alignment and slope matching
      const phaseScore = 50 - Math.min(50, Math.abs(endPhase - testPhase) * 100);
      const slopeScore = 50 - Math.min(50, Math.abs(endSlope - testSlope) * 200);
      
      const score = phaseScore + slopeScore;
      
      if (score > fineTuneScore) {
        fineTuneScore = score;
        fineTunedLeadIn = testPos;
      }
    }
    
    console.log(`Fine-tuned lead-in position: ${fineTunedLeadIn}, improvement: ${(fineTuneScore/100).toFixed(1)}`);
    
    // Create the final buffer with the best phase alignment
    const adjustedStart = startSamplePos;
    const fadeInStart = fineTunedLeadIn;
    
    const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
    
    // Apply improved crossfade technique
    for (let channel = 0; channel < channels; channel++) {
      const origData = sourceBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // First copy the main loop content
      for (let i = 0; i < loopLength; i++) {
        newData[i] = origData[adjustedStart + i];
      }
      
      // APPLY ENHANCED EQUAL-POWER CROSSFADE CURVE
      // This is critical for eliminating clicks and glitches
      for (let i = 0; i < fadeLengthSamples; i++) {
        const idx = loopLength - fadeLengthSamples + i;
        if (idx >= 0) {
          // Use optimized crossfade ratio with slight modification to ensure 
          // the fade out goes completely to zero at the midpoint
          const ratio = i / fadeLengthSamples;
          
          // Equal power crossfade curve (quarter-circle) provides the smoothest transition
          // Apply a very slight bias (0.02) to ensure the fadeOut curve reaches complete zero
          const fadeOutFactor = Math.cos(ratio * Math.PI/2) - Math.max(0, 0.02 - ratio * 0.04);
          const fadeInFactor = Math.sin(ratio * Math.PI/2);
          
          const loopEndSample = newData[idx];
          const leadInSample = origData[fadeInStart + i];
          
          // Apply the crossfade with perfect phase alignment
          newData[idx] = (loopEndSample * fadeOutFactor) + (leadInSample * fadeInFactor);
        }
      }
      
      // Apply a tiny smoothing at the loop transition point to eliminate any remaining discontinuities
      const smoothSamples = Math.min(24, Math.ceil(sampleRate * 0.0005)); // 0.5ms or 24 samples, whichever is smaller
      
      // Smooth the transition at the very end of the buffer (loop point)
      for (let i = 1; i <= smoothSamples; i++) {
        const idx = loopLength - i;
        if (idx >= 0 && idx < loopLength - 1) {
          const weight = i / smoothSamples;
          newData[idx] = newData[idx] * (1 - weight * 0.1) + newData[idx + 1] * (weight * 0.1);
        }
      }
    }
    
    console.log(`Created enhanced crossfaded buffer: ${(loopLength / sampleRate).toFixed(3)}s loop`);
    return { buffer: newBuffer, adjustedStartFraction: adjustedStart / totalSamples };
    
  } catch (e) {
    console.error("Error creating crossfaded buffer:", e);
    return { buffer: fadedBuffer || originalBuffer, adjustedStartFraction: startFraction };
  }
}
// Knob initializations (only one set)
const knobInitializations = {
      

    'master-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('master-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        masterGain.gain.setTargetAtTime(value, audioCtx.currentTime, 0.01);
        console.log('Master Volume:', value.toFixed(2));
    },
    'sample-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('sample-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        currentSampleGain = value;
        // Update all active notes' sample gain
        Object.values(activeNotes).forEach(note => {
            if (note && note.sampleNode) {
                note.sampleNode.gain.value = currentSampleGain;
            }
        });
        console.log('Sample Gain:', value.toFixed(2));
    },
    // ... existing knobs ...
    'sample-pitch-knob': (value) => {
        // Convert 0-1 range to -1200 to +1200 cents
        currentSampleDetune = (value * 2400) - 1200;
    
    // Show and update tooltip
    const tooltip = document.getElementById('pitch-tooltip') || createTooltip();
    tooltip.textContent = `${currentSampleDetune.toFixed(0)} cents`;
    tooltip.style.opacity = '1';
    
    // Update all active notes' sample pitch
    Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
            note.source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
        }
    });
    
    console.log('Sample Pitch:', currentSampleDetune.toFixed(0) + ' cents');
},

// Add these new knob initializations in the knobInitializations object
'sample-start-knob': (value) => {
    // Ensure start position is always less than end position
    const maxStart = Math.min(value, sampleEndPosition - 0.01);
    sampleStartPosition = maxStart;
    
    // Update processing with new start position
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-start-knob', value);
    tooltip.textContent = `Start: ${(sampleStartPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample Start:', (sampleStartPosition * 100).toFixed(0) + '%');
    
    // Instead of direct creation, ensure we wait for updateSampleProcessing to finish
    if (startUpdateTimer) { clearTimeout(startUpdateTimer); }
    startUpdateTimer = setTimeout(() => {
        if (audioBuffer && sampleCrossfadeAmount > 0.01 && isSampleLoopOn) {
            console.log("Creating new crossfaded buffer after start position settled");
            // Use the processed buffer that includes fades
            const result = createCrossfadedBuffer(
                fadedBuffer || audioBuffer, 
                0,   // Use entire processed buffer 
                1,   // Use entire processed buffer
                sampleCrossfadeAmount
            );
            
            if (result && result.buffer) {
                cachedCrossfadedBuffer = result.buffer;
                lastCachedStartPos = sampleStartPosition;
                lastCachedEndPos = sampleEndPosition;
                lastCachedCrossfade = sampleCrossfadeAmount;
            }
        }
        
        // Update any active notes
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping start update.`);
                    return;
                }
                
                // Force re-processing
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                if (isSampleLoopOn) {
                    note.looping = true;
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        startUpdateTimer = null;
    }, 150);  // Longer delay to ensure processing completes
},

'sample-end-knob': (value) => {
    // Ensure end position is always greater than start position
    const minEnd = Math.max(value, sampleStartPosition + 0.01);
    sampleEndPosition = minEnd;
    
    // Add this line to process fades when end position changes
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-end-knob', value);
    tooltip.textContent = `End: ${(sampleEndPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample End:', (sampleEndPosition * 100).toFixed(0) + '%');
    
    // Instead of direct creation, ensure we wait for updateSampleProcessing to finish
    if (endUpdateTimer) { clearTimeout(endUpdateTimer); }
    endUpdateTimer = setTimeout(() => {
        if (audioBuffer && sampleCrossfadeAmount > 0.01 && isSampleLoopOn) {
            console.log("Creating new crossfaded buffer after end position settled");
            // Use the processed buffer that includes fades
            const result = createCrossfadedBuffer(
                fadedBuffer || audioBuffer, 
                0,   // Use entire processed buffer 
                1,   // Use entire processed buffer
                sampleCrossfadeAmount
            );
            
            if (result && result.buffer) {
                cachedCrossfadedBuffer = result.buffer;
                lastCachedStartPos = sampleStartPosition;
                lastCachedEndPos = sampleEndPosition;
                lastCachedCrossfade = sampleCrossfadeAmount;
            }
        }
        
        // Update any active notes
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping end update.`);
                    return;
                }
                
                // Force re-processing
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                if (isSampleLoopOn) {
                    note.looping = true;
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        endUpdateTimer = null;
    }, 150);  // Longer delay to ensure processing completes
},
'sample-crossfade-knob': (value) => {
    const tooltip = createTooltipForKnob('sample-crossfade-knob', value);
    tooltip.textContent = `Crossfade: ${(value * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    // Store previous values
    const prevCrossfade = sampleCrossfadeAmount;
    const prevLoopState = isSampleLoopOn;
    
    // Update values
    sampleCrossfadeAmount = value;
    isSampleLoopOn = value > 0.01;
    
    // If enabling crossfade, clear any existing fades
    if (value > 0.01) {
        // Reset fade values when enabling crossfade
        sampleFadeInAmount = 0;
        sampleFadeOutAmount = 0;
        
        // Update the fade knob position to center (no fade)
        const fadeKnob = D('sample-fade-knob');
        if (fadeKnob) {
            const control = initializeKnob(fadeKnob, knobInitializations['sample-fade-knob']);
            control.setValue(0.5);
        }
    }
    
    // CRITICAL FIX: When crossfade amount changes significantly, recalculate zero-crossing alignment
    if (Math.abs(prevCrossfade - value) > 0.02 || prevLoopState !== isSampleLoopOn) {
        console.log("Crossfade changed significantly - recalculating zero crossings");
        
        if (audioBuffer) {
            // Similar to what happens in updateSampleProcessing but just for zero crossing
            const totalSamples = audioBuffer.length;
            const rawStartSample = Math.floor(sampleStartPosition * totalSamples);
            const rawEndSample = Math.floor(sampleEndPosition * totalSamples);
            
            // Find zero-crossings near the start and end points
            const alignedPoints = findBestZeroCrossings(
                audioBuffer, 
                rawStartSample, 
                rawEndSample
            );
            
            // Update the start and end positions with aligned zero crossings
            sampleStartPosition = alignedPoints.start / totalSamples;
            sampleEndPosition = alignedPoints.end / totalSamples;
            
            console.log(`Zero-crossings recalculated: start=${sampleStartPosition.toFixed(4)}, end=${sampleEndPosition.toFixed(4)}`);
            
            // // Update knob positions to reflect new values
            // const startKnob = D('sample-start-knob');
            // const endKnob = D('sample-end-knob');
            
            // if (startKnob) {
            //     const control = initializeKnob(startKnob, knobInitializations['sample-start-knob']);
            //     control.setValue(sampleStartPosition);
            // }
            
            // if (endKnob) {
            //     const control = initializeKnob(endKnob, knobInitializations['sample-end-knob']);
            //     control.setValue(sampleEndPosition);
            // }
        }
    }
    
    // Process with any updated settings
    updateSampleProcessing();

    // Regular debounced update
    if (crossfadeUpdateTimer) { clearTimeout(crossfadeUpdateTimer); }
    crossfadeUpdateTimer = setTimeout(() => {
        console.log("CROSSFADE UPDATE TIMER FIRED with", Object.keys(activeNotes).length, "active notes");
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                console.log(`Processing note ${note.id}, held: ${heldNotes.includes(note.noteNumber)}`);
                // Skip held notes
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping crossfade update.`);
                    return;
                }
                
                console.log(`Forcing re-processing for note ${note.id}`);
                // Force re-processing - important!
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                // This is crucial: first create the crossfaded buffer, then update the note
                if (isSampleLoopOn) {
                    note.looping = true; // Force looping flag to true!
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        crossfadeUpdateTimer = null;
    }, 100);
},
'sample-fade-knob': (value) => {
    // Convert 0-1 range to -0.5 to 0.5 range
    const fadeValue = value * 2 - 1;
    
    // Create tooltip
    const tooltip = createTooltipForKnob('sample-fade-knob', value);
    
    // If crossfade/loop is on, disable fade functionality completely
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        tooltip.textContent = `Fade (disabled)`;
        tooltip.style.opacity = '1';
        console.log("Fade knob ignored - crossfade is active");
        return; // Exit early - don't process fades when crossfade is active
    }
    
    // Different text based on direction
    if (fadeValue < 0) {
        // Fade out (left side)
        const fadeOutPercent = Math.abs(fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade Out: ${fadeOutPercent}%`;
        console.log(`Setting fade OUT to ${fadeOutPercent}%`);
    } else if (fadeValue > 0) {
        // Fade in (right side)
        const fadeInPercent = (fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade In: ${fadeInPercent}%`;
        console.log(`Setting fade IN to ${fadeInPercent}%`);
    } else {
        // Center position
        tooltip.textContent = `No Fade`;
        console.log("Resetting fades to 0");
    }
    tooltip.style.opacity = '1';
    
    // Store values for processing
    sampleFadeInAmount = Math.max(0, fadeValue);
    sampleFadeOutAmount = Math.abs(Math.min(0, fadeValue));
    
    console.log(`Fade control values: fadeIn=${sampleFadeInAmount.toFixed(2)}, fadeOut=${sampleFadeOutAmount.toFixed(2)}`);
    
    // Process the fade changes
    updateSampleProcessing();
},
'glide-time-knob': (value) => {
    const tooltip = createTooltipForKnob('glide-time-knob', value);
    tooltip.textContent = `${(value * 2000).toFixed(0)}ms`;
    tooltip.style.opacity = '1';
    glideTime = value * 2; // 0-2 seconds range
    console.log('Glide Time:', (value * 2000).toFixed(0) + 'ms');
},
};
/**
 * Updates existing note playback parameters.
 * For crossfaded loops, if not already using the processed buffer,
 * this will create a new note and fade out the old one.
 */
 function updateSamplePlaybackParameters(note) {
  if (!note || !audioBuffer) return note;
  if (note.isBeingUpdated) return note;
  if (note.state === "releasing") {
    console.log("updateSamplePlaybackParameters: Note", note.id, "is releasing; skipping update.");
    return note;
  }
  note.isBeingUpdated = true;
  
  // Reset flags to force new settings to take hold
  note.crossfadeActive = false;
  note.usesProcessedBuffer = false;
  
  try {
    if (sampleCrossfadeAmount > 0.01) {
      console.log("updateSamplePlaybackParameters: Creating replacement note with crossfade for note", note.id);
      const replacementNote = createNote(
        note.noteNumber,
        audioBuffer,
        audioCtx,
        masterGain
      );
      if (replacementNote) {
        replacementNote.gainNode.gain.value = note.gainNode.gain.value;
        quickFadeOut(note, 0.03);
        note = replacementNote;
        console.log("updateSamplePlaybackParameters: Replaced note", note.id, "with crossfaded version");
      }
    } else {
      if (note.source && note.looping) {
        note.source.loop = isSampleLoopOn;
        note.source.loopStart = sampleStartPosition * audioBuffer.duration;
        note.source.loopEnd = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: Updated loop points for note", note.id);
      }
      if (
        !note.looping ||
        Math.abs(note.sampleStartPosition - sampleStartPosition * audioBuffer.duration) > 0.01
      ) {
        console.log("updateSamplePlaybackParameters: Creating new source for note", note.id);
        const newSource = audioCtx.createBufferSource();
        newSource.buffer = audioBuffer;
        newSource.loop = isSampleLoopOn;
        newSource.playbackRate.value = note.source.playbackRate.value;
        newSource.detune.value = currentSampleDetune;
        if (isSampleLoopOn) {
          newSource.loopStart = sampleStartPosition * audioBuffer.duration;
          newSource.loopEnd = sampleEndPosition * audioBuffer.duration;
        }
        note.source.disconnect();
        newSource.connect(note.sampleNode);
        newSource.start(0, sampleStartPosition * audioBuffer.duration);
        setTimeout(() => { 
          try { note.source.stop(); } catch (e) {} 
        }, 30);
        note.source = newSource;
        note.sampleStartPosition = sampleStartPosition * audioBuffer.duration;
        note.sampleEndPosition = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: New source set for note", note.id);
      }
    }
  } finally {
    note.isBeingUpdated = false;
  }
  return note;
}
// Replace the entire createNote function with this fixed version
function createNote(noteNumber, buffer, audioCtx, destination) {
    const noteId = `${noteNumber}_${Date.now()}`;
    
    // Create gain nodes
    const gainNode = audioCtx.createGain();
    const sampleNode = audioCtx.createGain();
    gainNode.gain.value = 0.5;
    sampleNode.gain.value = currentSampleGain;
    
    const source = audioCtx.createBufferSource();
    
    // IMPORTANT: Select the correct buffer to use
    let useOriginalBuffer = true;
    let sourceBuffer = buffer; // Default to original buffer
    
    // If we have a crossfaded buffer and looping is on, use that
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01 && cachedCrossfadedBuffer) {
        sourceBuffer = cachedCrossfadedBuffer;
        useOriginalBuffer = false;
        console.log("Creating note using crossfaded buffer");
    } 
    // If we have a faded buffer and crossfade is not active, use the faded buffer
    else if (fadedBuffer && (!isSampleLoopOn || sampleCrossfadeAmount <= 0.01)) {
        sourceBuffer = fadedBuffer;
        useOriginalBuffer = false;
        console.log("Creating note using faded buffer");
    }
    
    // Set the buffer
    source.buffer = sourceBuffer;
    
    // Set playback speed for note pitch

        // Apply key tracking only if enabled
        if (isSampleKeyTrackingOn) {
      // Calculate semitone difference from middle C (note 60)
      source.playbackRate.value = TR2 ** (noteNumber - 12);
      source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
    } else {
      // Just use the knob value without key tracking
      source.detune.value = currentSampleDetune;
    }
    // Connect nodes
    source.connect(sampleNode);
    sampleNode.connect(gainNode);
    gainNode.connect(destination);
    
    // Set exact loop points if using original buffer
    if (useOriginalBuffer) {
        if (isSampleLoopOn) {
            source.loop = true;
            source.loopStart = sampleStartPosition * buffer.duration;
            source.loopEnd = sampleEndPosition * buffer.duration;
            console.log(`Setting loop points: ${source.loopStart.toFixed(3)}s to ${source.loopEnd.toFixed(3)}s`);
        }
    } else {
        // For processed buffer, loop the entire thing if looping is on
        source.loop = isSampleLoopOn;
    }
    
    // Create note object
    const note = {
        id: noteId,
        noteNumber,
        source,
        gainNode,
        sampleNode,
        startTime: audioCtx.currentTime,
        state: "starting",
        scheduledEvents: [],
        sampleStartPosition: useOriginalBuffer ? sampleStartPosition * buffer.duration : 0,
        sampleEndPosition: useOriginalBuffer ? sampleEndPosition * buffer.duration : sourceBuffer.duration,
        looping: isSampleLoopOn,
        usesProcessedBuffer: !useOriginalBuffer,
        crossfadeActive: !useOriginalBuffer && isSampleLoopOn && sampleCrossfadeAmount > 0.01
    };
    
    // Start playback
    source.start(0);
    
    if (!isSampleLoopOn) {
    let originalDuration;
    
    // Duration calculation logic (unchanged)
    if (fadedBuffer && sourceBuffer === fadedBuffer && fadedBufferOriginalDuration) {
        originalDuration = fadedBufferOriginalDuration;
        console.log(`Using stored fadedBufferOriginalDuration: ${originalDuration.toFixed(3)}s`);
    }
    else if (!useOriginalBuffer && sourceBuffer === cachedCrossfadedBuffer) {
        originalDuration = sourceBuffer.duration;
        console.log(`Using crossfaded buffer duration: ${originalDuration.toFixed(3)}s`);
    }
    else {
        originalDuration = (sampleEndPosition - sampleStartPosition) * buffer.duration;
        console.log(`Calculating original duration: ${originalDuration.toFixed(3)}s`);
    }
    
    const now = audioCtx.currentTime;
    sampleNode.gain.setValueAtTime(currentSampleGain, now);
    
    // CRITICAL FIX: Adjust duration based on playback rate
    // Lower pitches = longer duration
    const playbackRate = source.playbackRate.value;
    const adjustedDuration = originalDuration / playbackRate;
    
    // Apply safety margin
    const safetyMargin = 0.05;
    source.stop(now + adjustedDuration + safetyMargin);
    
    console.log(`Note scheduled to play for adjusted duration: ${adjustedDuration.toFixed(3)}s (original: ${originalDuration.toFixed(3)}s) at rate ${playbackRate.toFixed(2)} + ${safetyMargin}s margin`);
}
    
    // Store the note
    activeNotes[noteId] = note;
    
    return note;
}
/**
 * Sets up loop crossfade without recursion.
 * (Do not call updateSamplePlaybackParameters or createNote here.)
 */


// Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', () => {
  // Initialize all regular knobs
  Object.entries(knobInitializations).forEach(([id, callback]) => {
    const knob = D(id);
    if (knob) {
      const defaultValue = knobDefaults[id] !== undefined ? knobDefaults[id] : 0.5;
      const control = initializeKnob(knob, callback);
    }
  });


  
  // Initialize any remaining parameters
  updateSampleProcessing();
});

// Remove any other knob initialization code
        const keyStates = {};
        keys.forEach(key => keyStates[key] = false);
// Add to global variables

const MAX_MONO = 1;
        let audioBuffer = null;
        const MAX_POLYPHONY = 6;
        const activeVoices = []; // FIFO queue of active notes with their key info
        const activeNotes = {}; // Stores active notes
        const playingNotes = [];
        let playingNoteCount = 0;

        // Generate piano keyboard
        function generateKeyboard() {
            
    const keyboard = D('keyboard');
    keyboard.innerHTML = '';
    
    // Create white keys first
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                      'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
    
    for (let i = 0; i < whiteKeys.length; i++) {
        const key = document.createElement('div');
        key.className = 'key';
        // Map to the correct index in the keys array
        const keyIndex = getWhiteKeyIndex(i);
        key.dataset.noteIndex = keyIndex;
        keyboard.appendChild(key);
        
        // Add mouse events
        key.addEventListener('mousedown', () => {
            noteOn(parseInt(key.dataset.noteIndex));
            key.classList.add('pressed');
        });
        
        key.addEventListener('mouseup', () => {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        });
        
        key.addEventListener('mouseleave', () => {
            if (key.classList.contains('pressed')) {
                noteOff(parseInt(key.dataset.noteIndex));
                key.classList.remove('pressed');
            }
        });
    }
        


// Update the black keys creation in generateKeyboard
const blackKeys = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // Positions for all black keys

blackKeys.forEach((position) => {
    const key = document.createElement('div');
    key.className = 'key black';
    const keyIndex = getBlackKeyIndex(position);
    key.dataset.noteIndex = keyIndex;
    keyboard.appendChild(key);
    
    // Add mouse events
    key.addEventListener('mousedown', () => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
    });
    
    key.addEventListener('mouseup', () => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
    });
    
    key.addEventListener('mouseleave', () => {
        if (key.classList.contains('pressed')) {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        }
    });
})};

// Helper functions to map key positions to note indices
function getWhiteKeyIndex(position) {
    // Maps white key position to the corresponding index in the keys array
    const whiteKeyMap = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B positions
    const octave = Math.floor(position / 7);
    const noteInOctave = position % 7;
    return whiteKeyMap[noteInOctave] + (octave * 12);
}

function getBlackKeyIndex(position) {
    // Black key mapping for the entire keyboard
    const blackKeyIndices = [
        1,  // C#
        3,  // D#
        6,  // F#
        8,  // G#
        10, // A#
        13, // C# (second octave)
        15, // D# (second octave)
        18, // F# (second octave)
        20, // G# (second octave)
        22  // A# (second octave)
    ];
    
    return blackKeyIndices[position];
}

        // Add interface updating functions
        function updateSliderValues() {
  // Always format to 2 decimal places for consistent width
  D('attack-value').textContent = parseFloat(D('attack').value).toFixed(3);
  D('decay-value').textContent = parseFloat(D('decay').value).toFixed(2);
  D('sustain-value').textContent = parseFloat(D('sustain').value).toFixed(2);
  D('release-value').textContent = parseFloat(D('release').value).toFixed(3);
  
  updateADSRVisualization();
}

        // ADSR visualization
        function updateADSRVisualization() {
          const attack = parseFloat(D('attack').value);
    const decay = parseFloat(D('decay').value);
    const sustain = parseFloat(D('sustain').value);
    const release = parseFloat(D('release').value);
    
    const graph = D('adsr-visualization');
    const totalTime = attack + decay + 2 + release; // 2 seconds for sustain
    
    // Get actual display dimensions
    const width = graph.offsetWidth;
    const height = graph.offsetHeight;
            
            // Calculate points for ADSR envelope
            const attackX = (attack / totalTime) * width;
            const decayX = attackX + ((decay / totalTime) * width);
            const releaseStartX = decayX + ((2 / totalTime) * width); // 2 seconds sustain
            const releaseEndX = width;
            
    // Create canvas at exact display size
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    // Make sure lines are drawn with proper alignment
    ctx.imageSmoothingEnabled = false;
    ctx.translate(0.5, 0.5);
    ctx.strokeStyle = '#f2eed3';
    ctx.lineWidth = 2.5; // Make the line thickness 3px
  
  // Set line join style for smoother corners
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
    // Clear canvas
    ctx.clearRect(-1, -1, width + 1, height + 1);

            
    // Draw ADSR path
    ctx.beginPath();
    ctx.moveTo(0, height - 1); // Start at bottom left
    ctx.lineTo(attackX, 1); // Attack to peak
    ctx.lineTo(decayX, height - (sustain * height)); // Decay to sustain level
    ctx.lineTo(releaseStartX, height - (sustain * height)); // Sustain
    ctx.lineTo(releaseEndX, height - 1); // Release
    ctx.stroke();
    
    // Update visualization
    graph.innerHTML = '';
    graph.appendChild(canvas);
}
    
        // Update the voice monitoring display
        // Update the voice display function to handle releasing state
// Update the updateVoiceDisplay function
// Update the updateVoiceDisplay function to also update keyboard
function updateVoiceDisplay() {
    const displayEl = D('voice-display');
    displayEl.innerHTML = '';
    
    // Only count and display notes that are in "playing" state
    const playingNotes = Object.values(activeNotes).filter(
        note => note && note.state === "playing"
    );
    
    // Update count first
    const activeNoteCount = Math.min(playingNotes.length, MAX_POLYPHONY);
    D('voice-count').textContent = activeNoteCount;
    
    // Create display items for keyboard keys
    keys.forEach((key, index) => {
        const voiceItem = document.createElement('div');
        voiceItem.className = 'voice-item';
        voiceItem.textContent = key;
        
        // Only show as active if the note is actually playing
        const isPlaying = playingNotes.some(
            note => note.noteNumber === index
        );
        
        if (isPlaying) {
            voiceItem.classList.add('active-voice');
        }
        
        displayEl.appendChild(voiceItem);
    });

    // Update keyboard visual state
    updateKeyboardDisplay();
}

// you're the best <3 and you should put french fries in my car so that my car smells like fries forever :) - from Asher to Faith
        // Add event listeners for sliders
        D('attack').addEventListener('input', updateSliderValues);
        D('decay').addEventListener('input', updateSliderValues);
        D('sustain').addEventListener('input', updateSliderValues);
        D('release').addEventListener('input', updateSliderValues);

        // Update createNote to use unique IDs instead of note numbers as keys
       

       // Update releaseNote to properly handle keyboard display

    function startNote(noteNumber, audioCtx, destination, buffer) {
    // Create new note
    const note = createNote(noteNumber, buffer, audioCtx, destination);
    
    // Apply ADSR envelope
    const attack = parseFloat(D('attack').value);
    const decay = parseFloat(D('decay').value);
    const sustain = parseFloat(D('sustain').value);
    const now = audioCtx.currentTime;
    
    note.gainNode.gain.setValueAtTime(0, now);
    note.gainNode.gain.linearRampToValueAtTime(1, now + attack);
    note.gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    
    note.state = "playing";
    updateVoiceDisplay();
    return note;
}
// Update releaseNote function to use noteId instead of noteNumber
function releaseNote(noteId, audioCtx) {
  const note = activeNotes[noteId];
  if (!note || note.state !== "playing") {
    console.log("releaseNote: Note", noteId, "is not playing. Skipping release.");
    return;
  }
  
  // If the note is using the processed (crossfaded) buffer, disable looping
  if (note.usesProcessedBuffer) {
    note.looping = false;
    console.log("releaseNote: Disabling looping for processed note", noteId);
  }
  
  note.state = "releasing";
  const release = parseFloat(D('release').value);
  const now = audioCtx.currentTime;
  
  note.gainNode.gain.cancelScheduledValues(now);
  const currentGain = note.gainNode.gain.value;
  note.gainNode.gain.setValueAtTime(currentGain, now);
  note.gainNode.gain.linearRampToValueAtTime(0, now + release);
  
  try {
    note.source.stop(now + release + 0.05);
    console.log("releaseNote: Scheduling stop for note", noteId, "at", now + release + 0.05);
  } catch (e) {
    console.log("releaseNote: Error stopping source for note", noteId, e);
  }
  
  const releaseTimer = setTimeout(() => {
    if (note.state === "releasing") {
      killNote(note.id);
      updateVoiceDisplay();
      console.log("releaseNote: Note", noteId, "has been cleaned up.");
    }
  }, (release * 1000) + 100);
  
  note.releaseTimer = releaseTimer;
  note.scheduledEvents.push({ type: "timeout", id: releaseTimer });
  
  updateVoiceDisplay();
}
// Rename existing noteOn/noteOff to these:
// Update handlePolyNoteOn function
// Update handlePolyNoteOn function
function handlePolyNoteOn(noteNumber) {
    if (!heldNotes.includes(noteNumber)) {
    heldNotes.push(noteNumber);
}

// Gather all notes that are still alive (playing or releasing)
let active = Object.values(activeNotes).filter(
    n => n.state === "playing" || n.state === "releasing"
);

// While we are at or above the poly limit,
// kill the oldest note to free a slot
while (active.length >= MAX_POLYPHONY) {
    // Sort oldest first
    active.sort((a, b) => a.startTime - b.startTime);
    const oldest = active[0];

    // Mark it as "fadingOut" so it won't be counted in active[] next loop
    oldest.state = "fadingOut";
    quickFadeOut(oldest, 0.15); // short forced fade

    // Re-check the active list
    active = Object.values(activeNotes).filter(
        n => n.state === "playing" || n.state === "releasing"
    );
}

// Now that we freed up a slot, start the new note
startNewPolyNote(noteNumber);
updateVoiceDisplay();
}
// Helper to start a note with portamento if needed
function startNewPolyNote(noteNumber) {
    if (isPortamentoOn && lastPlayedNote !== null) {
        const note = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        const startRate = TR2 ** (lastPlayedNote - 12);
        const targetRate = TR2 ** (noteNumber - 12);

        note.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
        note.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    } else {
        startNote(noteNumber, audioCtx, masterGain, audioBuffer);
    }
    lastPlayedNote = noteNumber;
}
// Fix handlePolyNoteOff function
function handlePolyNoteOff(noteNumber) {
    // Remove from held notes
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    // Release all instances of this note
    Object.values(activeNotes).forEach(note => {
        if (note.noteNumber === noteNumber && note.state === "playing") {
            releaseNote(note.id, audioCtx);
        }
    });
    updateVoiceDisplay();
}updateVoiceDisplay();


// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
/**
 * Quickly fades out a note and cleans it up.
 * @param {Object} note - The note object to fade out
 * @param {number} fadeTime - Fade time in seconds (default: 0.05)
 * @returns {Object} - The same note for chaining
 */
 function quickFadeOut(note, fadeTime = 0.05) {
  if (!note || !note.gainNode) return note;
  
  // Update state
  note.state = "fadingOut";
  
  try {
    // Get current time and gain value
    const now = audioCtx.currentTime;
    const currentGain = note.gainNode.gain.value;
    
    // Cancel any scheduled values and set current value
    note.gainNode.gain.cancelScheduledValues(now);
    note.gainNode.gain.setValueAtTime(currentGain, now);
    
    // Ramp down to zero
    note.gainNode.gain.linearRampToValueAtTime(0, now + fadeTime);
    
    // Schedule the note to be killed after the fade
    const killTimer = setTimeout(() => {
      killNote(note.id);
    }, fadeTime * 1000 + 10); // Add 10ms buffer
    
    // Register this timeout in the note's scheduled events
    note.scheduledEvents.push({ type: 'timeout', id: killTimer });
  } 
  catch (e) {
    console.error("Error in quickFadeOut:", e);
    killNote(note.id); // Clean up immediately on error
  }
  
  return note;
}
        // Fix the killNote function
        function killNote(noteId) {
    const note = activeNotes[noteId];
    if (!note) return false;

    // Clean up scheduled events
    note.scheduledEvents.forEach(event => {
        if (event.type === "timeout") {
            clearTimeout(event.id);
        }
    });

    // Stop the source and disconnect nodes
    try {
        note.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
        note.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        if (note.source) {
            note.source.stop(audioCtx.currentTime);
        }
    } catch (e) {
        console.log("Error during cleanup:", e);
    }

    // Remove note from active notes
    delete activeNotes[noteId];
    return true;
}

function updateKeyboardDisplay() {
    // Update all keyboard keys based on active notes
    document.querySelectorAll('.key').forEach(keyElement => {
        const noteIndex = parseInt(keyElement.dataset.noteIndex);
        const isNotePlaying = Object.values(activeNotes).some(
            note => note.noteNumber === noteIndex && note.state === "playing"
        );
        
        keyElement.classList.toggle('pressed', isNotePlaying);
    });
}

// Update noteOn to handle polyphony with unique note instances
// Update noteOn to ensure proper mode handling
function noteOn(noteNumber) {
    if (!audioBuffer) {
        console.error("No audio buffer available!");
        return;
    }

    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
    updateKeyboardDisplay();
}

function noteOff(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOff(noteNumber);
    } else {
        handlePolyNoteOff(noteNumber);
    }
    updateKeyboardDisplay();
}

document.onkeydown = function(e) {
  // Stop repeated keydown events
  if (e.repeat) return;

  const upperKey = e.key.toUpperCase();
  console.log("Key pressed:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && !keyStates[upperKey]) {
    console.log("Mapped to note index:", keys.indexOf(upperKey));
    keyStates[upperKey] = true;
    noteOn(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && !keyStates[e.key]) {
    console.log("Special key pressed:", e.key, "=> Note index:", specialKeyMap[e.key]);
    keyStates[e.key] = true;
    noteOn(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

document.onkeyup = function(e) {
  const upperKey = e.key.toUpperCase();
  console.log("Key released:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && keyStates[upperKey]) {
    console.log("Released from array:", upperKey);
    keyStates[upperKey] = false;
    noteOff(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && keyStates[e.key]) {
    console.log("Released special key:", e.key);
    keyStates[e.key] = false;
    noteOff(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

// Update the keyboard generation to use correct note triggering
// Update generateKeyboard to add touch support
function generateKeyboard() {
  const keyboard = D('keyboard');
  keyboard.innerHTML = '';

  // Create white keys first
  const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                    'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
  
  for (let i = 0; i < whiteKeys.length; i++) {
      const key = document.createElement('div');
      key.className = 'key';
      // Map to the correct index in the keys array
      const keyIndex = getWhiteKeyIndex(i);
      key.dataset.noteIndex = keyIndex;
      keyboard.appendChild(key);
      
      // Add mouse events
      key.addEventListener('mousedown', () => {
          noteOn(parseInt(key.dataset.noteIndex));
          key.classList.add('pressed');
      });
      
      key.addEventListener('mouseup', () => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
      });
      
      key.addEventListener('mouseleave', () => {
          if (key.classList.contains('pressed')) {
              noteOff(parseInt(key.dataset.noteIndex));
              key.classList.remove('pressed');
          }
      });
      
      // Add touch events
      key.addEventListener('touchstart', (e) => {
          noteOn(parseInt(key.dataset.noteIndex));
          key.classList.add('pressed');
          e.preventDefault(); // Prevent double-triggering
      }, { passive: false });
      
      key.addEventListener('touchend', (e) => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
          e.preventDefault();
      }, { passive: false });
      
      key.addEventListener('touchcancel', (e) => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
          e.preventDefault();
      }, { passive: false });
  }

  // Create black keys
  for (let i = 0; i < 10; i++) { // 5 black keys per octave, 2 octaves
    const key = document.createElement('div');
    key.className = 'key black';
    const keyIndex = getBlackKeyIndex(i);
    key.dataset.noteIndex = keyIndex;
    
    key.addEventListener('mousedown', () => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
    });
    
    key.addEventListener('mouseup', () => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
    });
    
    key.addEventListener('mouseleave', () => {
        if (key.classList.contains('pressed')) {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        }
    });
    
    // Add touch events
    key.addEventListener('touchstart', (e) => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
        e.preventDefault(); // Prevent double-triggering
    }, { passive: false });
    
    key.addEventListener('touchend', (e) => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
        e.preventDefault();
    }, { passive: false });
    
    key.addEventListener('touchcancel', (e) => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
        e.preventDefault();
    }, { passive: false });
    
    keyboard.appendChild(key);
  }
}

 
function handleFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const arrayBuffer = e.target.result;
    audioCtx.decodeAudioData(arrayBuffer).then(buffer => {
      audioBuffer = buffer;
      originalBuffer = buffer.slice(); // Store the original buffer
      
      // Apply reverse if needed
      if (isSampleReversed) {
        reverseBufferIfNeeded();
      }
                
                // Process fades and crossfades whenever a new sample is loaded
                updateSampleProcessing();
                
                // Reset cached crossfade buffer when loading a new sample
                cachedCrossfadedBuffer = null;
                lastCachedStartPos = null;
                lastCachedEndPos = null;
                lastCachedCrossfade = null;
                
                // Create new source node
                if (sampleSource) {
                    sampleSource.stop();
                }
                sampleSource = audioCtx.createBufferSource();
                sampleSource.buffer = buffer;
                
                // Connect the audio chain
                sampleSource.connect(sampleGainNode);
                sampleSource.start();
                
                // Update the label text to show the file name
                const fileLabel = document.querySelector('label[for="audio-file"]');
                if (fileLabel) {
                    // Truncate filename if too long
                    const maxLength = 12;
                    const displayName = file.name.length > maxLength ? 
                        file.name.substring(0, maxLength-3) + '...' : 
                        file.name;
                    fileLabel.textContent = displayName;
                }
                
                // Create crossfaded buffer if needed
                if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
                    console.log("Creating crossfaded buffer for newly loaded sample");
                    const result = createCrossfadedBuffer(
                        buffer, 
                        sampleStartPosition, 
                        sampleEndPosition, 
                        sampleCrossfadeAmount
                    );
                    
                    if (result && result.buffer) {
                        console.log("Successfully created crossfaded buffer for new sample");
                        cachedCrossfadedBuffer = result.buffer;
                        lastCachedStartPos = sampleStartPosition;
                        lastCachedEndPos = sampleEndPosition;
                        lastCachedCrossfade = sampleCrossfadeAmount;
                    }
                }
                
                // Update any active notes to use the new buffer
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        // Skip held notes to avoid interruption
                        if (heldNotes.includes(note.noteNumber)) {
                            console.log(`Note ${note.id} is held; will update on release.`);
                            return;
                        }
                        
                        console.log(`Updating note ${note.id} to use new sample`);
                        note.usesProcessedBuffer = false;
                        note.crossfadeActive = false;
                        
                        if (isSampleLoopOn) {
                            note.looping = true; 
                            setupLoopCrossfade(note);
                        }
                        updateSamplePlaybackParameters(note);
                    }
                });
            });
        };
        reader.readAsArrayBuffer(file);
    }


function checkAudioAvailable() {
    if (!audioBuffer) {
        console.warn("No audio buffer available - load a sample first!");
        return false;
    }
    return true;
}

        D('audio-file').addEventListener('change', handleFileSelect);
        
        // Clean up everything
        function cleanupAllNotes() {
            for (const noteNum in activeNotes) {
                killNote(parseInt(noteNum));
            }
            
            // Reset all key states
            for (const key in keyStates) {
                keyStates[key] = false;
            }
            
            updateVoiceDisplay();
        }

        // Add additional safety with blur/focus event handling
        window.addEventListener('blur', cleanupAllNotes);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cleanupAllNotes();
            }
        });

        // Initialize interface
        generateKeyboard();
        updateSliderValues();
        updateVoiceDisplay();
        updateADSRVisualization();

        document.addEventListener('DOMContentLoaded', () => {
    // Initialize all knobs with placeholder functionality
    const knobInitializations = {
        'sample-volume-knob': (value) => {
            if (sampleGainNode) {
                sampleGainNode.gain.setValueAtTime(value, audioCtx.currentTime);
                console.log('Sample Gain:', value.toFixed(2));
            }
        }
    };
});



// Add tooltip creation function
function createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'pitch-tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    // Position tooltip near the pitch knob
    const knob = D('sample-pitch-knob');
    const knobRect = knob.getBoundingClientRect();
    tooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
    tooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
    
    return tooltip;
}
function createTooltipForKnob(knobId, value) {
    const tooltip = document.getElementById(`${knobId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${knobId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        
        // Position tooltip near its knob
        const knob = D(knobId);
        const knobRect = knob.getBoundingClientRect();
        newTooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
        newTooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
        
        return newTooltip;
    })();
    
    return tooltip;
}
function initializeOctaveSlider(slider, onChange) {
    const handle = slider.querySelector('.octave-slider-handle');
    const sliderHeight = slider.offsetHeight - handle.offsetHeight;
    const positions = 5; // -2 to +2
    const stepSize = sliderHeight / (positions - 1);
    let currentPosition = 2; // Start at middle (0)
    
    // Set initial position
    handle.style.top = (currentPosition * stepSize) + 'px';
    
    function snapToPosition(y) {
        const relativeY = y - slider.getBoundingClientRect().top;
        let position = Math.round(relativeY / stepSize);
        position = Math.max(0, Math.min(positions - 1, position));
        return position;
    }
    
    function updatePosition(position) {
        handle.style.top = (position * stepSize) + 'px';
        const value = 2 - position; // Convert position to octave value
        if (onChange) onChange(value);
    }
    
    let isDragging = false;
    
    handle.addEventListener('mousedown', (e) => {
        isDragging = true;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const position = snapToPosition(e.clientY);
        updatePosition(position);
        currentPosition = position;
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
        }
    });
    
    // Initialize at center position (0 octave)
    updatePosition(2);
    
    return {
        setValue: (octave) => {
            const position = 2 - octave; // Convert octave value to position
            updatePosition(Math.max(0, Math.min(positions - 1, position)));
        }
    };
}
// Update the document mouseup handler to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});

function initializePrecisionSlider(slider) {
    let lastY;
    let isDragging = false;
    const range = parseFloat(slider.max) - parseFloat(slider.min);
    const totalHeight = 230; // Height of slider in pixels
    
    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Calculate sensitivity based on shift key
        const sensitivity = e.shiftKey ? 0.2 : 1.0;
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        // Calculate value change
        const valueChange = (deltaY / totalHeight) * range;
        const currentValue = parseFloat(slider.value);
        let newValue = currentValue + valueChange;
        
        // Clamp to min/max
        newValue = Math.min(Math.max(newValue, slider.min), slider.max);
        
        // Update slider value
        slider.value = newValue;
        
        // Trigger input event for ADSR visualization
        slider.dispatchEvent(new Event('input'));
        
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }
    
    slider.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });
}

// Initialize precision control for ADSR sliders
document.addEventListener('DOMContentLoaded', () => {
    ['attack', 'decay', 'sustain', 'release'].forEach(id => {
        const slider = D(id);
        if (slider) {
            initializePrecisionSlider(slider);
        }
    });
});

// Add to your global variables
let isMonoMode = false;
let isLegatoMode = false;
let isPortamentoOn = false;
let glideTime = 0.1; // seconds
let heldNotes = []; // Keep track of held notes in mono mode
let currentNote = null; // Currently sounding note in mono mode


// Add to initializeSwitch function
function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
    let isDragging = false;
    let isActive = false;
    
    // Create tooltip for this switch
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    function updateTooltip() {
        const switchRect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${switchRect.left + switchRect.width + 5}px`;
        tooltip.style.top = `${switchRect.top + (switchRect.height / 2) - 10}px`;
        tooltip.textContent = isActive ? options.onText : options.offText;
        tooltip.style.opacity = '1';
    }
    
    function handleMouseDown(e) {
        isDragging = true;
        switchEl.style.cursor = 'grabbing';
        updateTooltip();
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        switchEl.style.cursor = 'grab';
        tooltip.style.opacity = '0';
    }
    
    function handleClick() {
        isActive = !isActive;
        switchEl.classList.toggle('active');
        updateTooltip();
        return isActive;
    }
    
    switchEl.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    switchEl.addEventListener('click', handleClick);
    
    return {
        getValue: () => isActive,
        setValue: (value) => {
            isActive = value;
            switchEl.classList.toggle('active', isActive);
            updateTooltip();
        }
    };
}

// Update switch initialization with custom text
function initializeSwitches() {
    // Initialize all switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
    const switches = {
        'voice-mode-switch': {
            // ... existing code ...
        },
        'trigger-mode-switch': {
            // ... existing code ...
        },
        'portamento-switch': {
            // ... existing code ...
        },
        'sample-loop-switch': {
            onText: 'LOOP ON',
            offText: 'LOOP OFF',
            onChange: (active) => {
                isSampleLoopOn = active;
                
                // Update any playing samples
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        updateSamplePlaybackParameters(note);
                    }
                });
                
                console.log('Sample Loop:', active ? 'ON' : 'OFF');
            }
        }
    };
    // Rest of the initialization code remains the same...
}

// Initialize the switches
function initializeSwitches() {
    function initializeSwitch(switchEl) {
        let isDragging = false;
        let isActive = false;
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
            }
        };
    }
    
    // Initialize all switches
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'));
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'));
    const portamentoSwitch = initializeSwitch(D('portamento-switch'));
    
    // Handle voice mode changes
    voiceModeSwitch.onChange = (isActive) => {
        isMonoMode = isActive;
        cleanupAllNotes();
    };
    
    // Handle trigger mode changes
    triggerModeSwitch.onChange = (isActive) => {
        isLegatoMode = isActive;
    };
    
    // Handle portamento changes
    portamentoSwitch.onChange = (isActive) => {
        isPortamentoOn = isActive;
    };
}

// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});

        // Update noteOn function to handle mono mode
function noteOn(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
}
// Fix for voice limiting in mono mode
function handleMonoNoteOn(noteNumber) {
    if (!checkAudioAvailable()) return;
    
    // Add note to held notes
    if (!heldNotes.includes(noteNumber)) {
        heldNotes.push(noteNumber);
    }
    
    // Clean up any stale notes that aren't the current note
    Object.values(activeNotes).forEach(note => {
        if (note !== currentNote && note.state === "releasing") {
            quickFadeOut(note, 0.015);
        }
    });

    const shouldTrigger = !isLegatoMode || !currentNote;
    const shouldGlide = isPortamentoOn && lastPlayedNote !== null;

    if (shouldTrigger) {
        if (currentNote) {
            const prevNote = currentNote;
            quickFadeOut(prevNote, 0.015);
            setTimeout(() => {
                // Make sure we're really in mono mode - kill any remaining notes
                Object.values(activeNotes).forEach(note => {
                    if (note !== prevNote) {
                        killNote(note.id);
                    }
                });
                
                currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
                
                if (shouldGlide) {
                    const startRate = TR2 ** (lastPlayedNote - 12);
                    const targetRate = TR2 ** (noteNumber - 12);
                    currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
                    currentNote.source.playbackRate.linearRampToValueAtTime(
                        targetRate,
                        audioCtx.currentTime + glideTime
                    );
                }
                updateVoiceDisplay();
            }, 20);
            return;
        }
        
        currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        if (shouldGlide) {
            const startRate = TR2 ** (lastPlayedNote - 12);
            const targetRate = TR2 ** (noteNumber - 12);
            currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
            currentNote.source.playbackRate.linearRampToValueAtTime(
                targetRate,
                audioCtx.currentTime + glideTime
            );
        }
    } else if (currentNote) {
        // Handle pitch changes in legato mode
        currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
        const currentRate = currentNote.source.playbackRate.value;
        const targetRate = TR2 ** (noteNumber - 12);
        
        currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
        currentNote.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    }

    lastPlayedNote = noteNumber;
    updateVoiceDisplay();
}

// Update handleMonoNoteOff function
function handleMonoNoteOff(noteNumber) {
    // Remove note from held notes array
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    if (heldNotes.length > 0) {
        // If there are still held notes, move to the last pressed note
        const lastNote = heldNotes[heldNotes.length - 1];

        if (!isLegatoMode) {
            // In multi-trigger mode, only retrigger if we're releasing the currently playing note
            if (currentNote && currentNote.noteNumber === noteNumber) {
                quickFadeOut(currentNote);
                setTimeout(() => {
                    currentNote = startNote(lastNote, audioCtx, masterGain, audioBuffer);
                    updateVoiceDisplay();
                }, 20);
            }
        } else {
            // In legato mode, glide if needed
            if (currentNote) {
                currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
                const currentRate = currentNote.source.playbackRate.value;
                const targetRate = TR2 ** (lastNote - 12);
                
                currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
                currentNote.source.playbackRate.linearRampToValueAtTime(
                    targetRate,
                    audioCtx.currentTime + glideTime
                );
            }
        }
    } else {
        if (currentNote) {
            releaseNote(currentNote.id, audioCtx);
            currentNote = null;
        }
    }

    updateVoiceDisplay();
}
// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
function initializeSampleLoopSwitch() {
  const loopSwitch = document.getElementById('sample-loop-switch');
  if (!loopSwitch) return;

  // Toggle active class on click
  loopSwitch.addEventListener('click', () => {
    loopSwitch.classList.toggle('active');
    isSampleLoopOn = loopSwitch.classList.contains('active');
    // Update any playing samples
    Object.values(activeNotes).forEach(note => {
      if (note.source) updateSamplePlaybackParameters(note);
    });
    console.log('Sample Loop:', isSampleLoopOn ? 'ON' : 'OFF');
  });
}
document.addEventListener('DOMContentLoaded', () => {
  // Call this after other setup
  initializeSampleLoopSwitch();
});
// Add this function for switch tooltips
function createTooltipForSwitch(switchId, options = { onText: 'ON', offText: 'OFF' }) {
    const tooltip = document.getElementById(`${switchId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${switchId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        return newTooltip;
    })();
    
    // Position tooltip near its switch
    const switchEl = D(switchId);
    if (switchEl) {
        const rect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width + 5}px`;
        tooltip.style.top = `${rect.top + (rect.height / 2) - 10}px`;
    }
    
    return tooltip;
}

function initializeSwitches() {
    function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
        let isDragging = false;
        let isActive = false;
        
        function updateTooltip() {
            const tooltip = createTooltipForSwitch(switchEl.id, options);
            tooltip.textContent = isActive ? options.onText : options.offText;
            tooltip.style.opacity = '1';
        }
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            updateTooltip();
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            updateTooltip();
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
                updateTooltip();
            }
        };
    }
    
    // Initialize switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
}
// Call this function during initialization instead of setupMicRecording

// Update document mouseup to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});
// Auto-hide tooltips after inactivity
function setupAutoHideTooltips() {
  let tooltipHideTimers = {}; // Track timers per tooltip
  const tooltipHideDelay = 250; // 2 seconds
  
  // Function to hide all tooltips
  function hideAllTooltips() {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.style.opacity = '0';
    });
  }
  
  // Function to schedule hiding a specific tooltip
  function scheduleTooltipHide(tooltipId) {
    // Clear any existing timer for this tooltip
    if (tooltipHideTimers[tooltipId]) {
      clearTimeout(tooltipHideTimers[tooltipId]);
    }
    
    // Set new timer
    tooltipHideTimers[tooltipId] = setTimeout(() => {
      const tooltip = document.getElementById(tooltipId);
      if (tooltip) tooltip.style.opacity = '0';
      delete tooltipHideTimers[tooltipId];
    }, tooltipHideDelay);
  }
  
  // When any touch interaction ends, schedule hiding all tooltips
  document.addEventListener('touchend', () => {
    setTimeout(hideAllTooltips, tooltipHideDelay);
  });
  
  // Force hide tooltips when leaving the page or switching tabs
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      hideAllTooltips();
    }
  });
  
  // Ensure tooltips hide after inactivity
  let globalInactivityTimer = null;
  
  function resetInactivityTimer() {
    if (globalInactivityTimer) clearTimeout(globalInactivityTimer);
    globalInactivityTimer = setTimeout(hideAllTooltips, tooltipHideDelay);
  }
  
  // Reset the timer on any touch event
  ['touchstart', 'touchmove', 'touchend'].forEach(eventName => {
    document.addEventListener(eventName, resetInactivityTimer, { passive: true });
  });
  
  // Initially reset timer
  resetInactivityTimer();
}
function initializeSwitches() {
    const switches = {
        'voice-mode-switch': {
            onText: 'MONO',
            offText: 'POLY',
            onChange: (active) => {
                isMonoMode = active;
                cleanupAllNotes();
                console.log('Voice Mode:', active ? 'MONO' : 'POLY');
            }
        },
        'trigger-mode-switch': {
            offText: 'MULTI',
            onText: 'LEGATO',
            onChange: (active) => {
                isLegatoMode = active;
                console.log('Trigger Mode:', active ? 'LEGATO' : 'MULTI');
            }
        },
        'portamento-switch': {
            onText: 'PORTA ON',
            offText: 'PORTA OFF',
            onChange: (active) => {
                isPortamentoOn = active;
                console.log('Portamento:', active ? 'ON' : 'OFF');
            }
        }
    };

    Object.entries(switches).forEach(([id, config]) => {
        const switchEl = D(id);
        if (!switchEl) return;

        let isActive = false;
        
        function updateSwitch() {
            switchEl.classList.toggle('active', isActive);
            
            // Skip tooltip creation completely for emu-mode-switch
            if (id !== 'emu-mode-switch') {
                const tooltip = createTooltipForSwitch(id);
                tooltip.textContent = isActive ? config.onText : config.offText;
                tooltip.style.opacity = '1';
            }
            
            config.onChange(isActive);
        }

        switchEl.addEventListener('click', () => {
            isActive = !isActive;
            updateSwitch();
        });

        // Don't add tooltip events to emu-mode-switch
        if (id !== 'emu-mode-switch') {
            switchEl.addEventListener('mousedown', (e) => {
                const tooltip = createTooltipForSwitch(id);
                tooltip.textContent = isActive ? config.onText : config.offText;
                tooltip.style.opacity = '1';
                e.preventDefault();
            });
        }
    });
    
    // Add special handling for emu-mode-switch
    const emuModeSwitch = D('emu-mode-switch');
    if (emuModeSwitch) {
        emuModeSwitch.addEventListener('click', () => {
            const isActive = emuModeSwitch.classList.contains('active');
            isEmuModeOn = !isActive; // Toggle the state
            
            // Update LED indicator
            const led = document.getElementById('emu-led');
            if (led) {
                led.classList.toggle('on', !isActive);
            }
            
            // Toggle active class
            emuModeSwitch.classList.toggle('active', !isActive);
            
            // Process with E-mu mode
            updateSampleProcessing();
            
            // Update any playing notes
            Object.values(activeNotes).forEach(note => {
                if (note && note.source && !heldNotes.includes(note.noteNumber)) {
                    updateSamplePlaybackParameters(note);
                }
            });
            
            console.log('Lo-Fi Mode:', !isActive ? 'ON' : 'OFF');
        });
    }
}
// JavaScript for sample selector dropdown
document.addEventListener('DOMContentLoaded', function() {
  const selectorBtn = document.getElementById('sample-selector-btn');
  const dropdown = document.getElementById('sample-dropdown');
  const dropdownItems = document.querySelectorAll('.dropdown-item');
  
  // Toggle dropdown when clicking the button
  selectorBtn.addEventListener('click', function() {
    dropdown.classList.toggle('show');
    event.stopPropagation();
  });
  
  // Close dropdown when clicking outside
  window.addEventListener('click', function() {
    if (dropdown.classList.contains('show')) {
      dropdown.classList.remove('show');
    }
  });
  
  // Handle preset sample selection
  dropdownItems.forEach(item => {
    item.addEventListener('click', function() {
      const sampleName = this.getAttribute('data-sample');
      loadPresetSample(sampleName);
      dropdown.classList.remove('show');
    });
  });
});

// Function to load preset samples
function loadPresetSample(filename) {
  console.log(`Loading preset sample: ${filename}`);
  
  // Build the URL to the sample file
  const sampleUrl = `samples/${filename}`;
  
  // Fetch the sample file
  fetch(sampleUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load sample: ${response.status} ${response.statusText}`);
      }
      return response.arrayBuffer();
    })
    .then(arrayBuffer => {
      // Decode the audio data
      return audioCtx.decodeAudioData(arrayBuffer);
    })
    .then(buffer => {
    // Use the buffer as the sample
    audioBuffer = buffer;
    originalBuffer = buffer.slice(); // Store the original buffer
      
      // Apply reverse if needed
      if (isSampleReversed) {
        reverseBufferIfNeeded();
      }
    // Process fades and crossfades whenever a new preset is loaded
    updateSampleProcessing();
    
    // Rest of the function...
      
      // Reset cached crossfade buffer when loading a new sample
      cachedCrossfadedBuffer = null;
      lastCachedStartPos = null;
      lastCachedEndPos = null;
      lastCachedCrossfade = null;
      
      // Create new source node
      if (sampleSource) {
        sampleSource.stop();
      }
      sampleSource = audioCtx.createBufferSource();
      sampleSource.buffer = buffer;
      
      // Connect the audio chain
      sampleSource.connect(sampleGainNode);
      sampleSource.start();
      
      // Update the label to show the loaded sample name
      const fileLabel = document.querySelector('label[for="audio-file"]');
      if (fileLabel) {
        fileLabel.textContent = filename.substring(0, 10) + (filename.length > 10 ? '...' : '');
      }
      
      // Create crossfaded buffer if needed
      if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        console.log("Creating crossfaded buffer for preset sample");
        const result = createCrossfadedBuffer(
          buffer, 
          sampleStartPosition, 
          sampleEndPosition, 
          sampleCrossfadeAmount
        );
        
        if (result && result.buffer) {
          console.log("Successfully created crossfaded buffer for preset sample");
          cachedCrossfadedBuffer = result.buffer;
          lastCachedStartPos = sampleStartPosition;
          lastCachedEndPos = sampleEndPosition;
          lastCachedCrossfade = sampleCrossfadeAmount;
        }
      }
      
      // Update any active notes to use the new buffer
      Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
          // Skip held notes to avoid interruption
          if (heldNotes.includes(note.noteNumber)) {
            console.log(`Note ${note.id} is held; will update on release.`);
            return;
          }
          
          console.log(`Updating note ${note.id} to use new preset sample`);
          note.usesProcessedBuffer = false;
          note.crossfadeActive = false;
          
          if (isSampleLoopOn) {
            note.looping = true; 
            setupLoopCrossfade(note);
          }
          updateSamplePlaybackParameters(note);
        }
      });
    })
    .catch(error => {
      console.error('Error loading preset sample:', error);
      alert(`Failed to load sample: ${filename}`);
    });
}
// In your processBufferWithFades function:
function processBufferWithFades(buffer) {
    if (!buffer) return null;

    // Skip processing if no fades needed
    if (sampleFadeInAmount < 0.01 && sampleFadeOutAmount < 0.01) {
        console.log("No fades to apply, returning original buffer");
        return buffer;
    }

    console.log("Applying fade to trimmed buffer...");
    const length = buffer.length;
    if (length < 2) return buffer;

    // Create the faded buffer
    const newFadedBuffer = audioCtx.createBuffer(
        buffer.numberOfChannels, 
        length, 
        buffer.sampleRate
    );
    
    // Calculate fade samples OUTSIDE the channel loop
    const fadeInSamples = Math.floor(length * sampleFadeInAmount);
    const fadeOutSamples = Math.floor(length * sampleFadeOutAmount);
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
        const inputData = buffer.getChannelData(c);
        const outputData = newFadedBuffer.getChannelData(c);
        
        // First copy all samples
        for (let i = 0; i < length; i++) {
            outputData[i] = inputData[i];
        }
        
        // Apply fade in (first part of buffer)
        for (let i = 0; i < fadeInSamples; i++) {
            outputData[i] *= i / fadeInSamples;
        }
        
        // Apply fade out (last part of buffer)
        for (let i = 0; i < fadeOutSamples; i++) {
            const idx = length - 1 - i;
            outputData[idx] *= i / fadeOutSamples;
        }
    }
    
    // CRITICAL FIX: Store the processed buffer in the global fadedBuffer variable
    fadedBuffer = newFadedBuffer;
    
    // Store the original duration for correct playback
    fadedBufferOriginalDuration = (sampleEndPosition - sampleStartPosition) * audioBuffer.duration;
    console.log(`Created faded buffer with ${fadeInSamples} fade in samples and ${fadeOutSamples} fade out samples`);
    console.log(`Original duration: ${fadedBufferOriginalDuration}s`);
    
    return newFadedBuffer;
}
function applyEmuProcessing(buffer) {
  if (!buffer) return null;
  
  const ctx = audioCtx;
  const sampleRate = buffer.sampleRate;
  const channels = buffer.numberOfChannels;
  const length = buffer.length;
  
  // Create a new buffer for the processed audio
  const processedBuffer = ctx.createBuffer(channels, length, sampleRate);
  
  // Process each channel
  for (let channel = 0; channel < channels; channel++) {
    const inputData = buffer.getChannelData(channel);
    const outputData = processedBuffer.getChannelData(channel);
    
    // First simply copy all data
    for (let i = 0; i < length; i++) {
      outputData[i] = inputData[i];
    }
    
    // Apply 8-bit mu-law companding simulation 
    for (let i = 0; i < length; i++) {
      // 1. Compress (simulate mu-law encoding)
      const compressed = Math.sign(outputData[i]) * 
                      Math.log(1 + 255 * Math.abs(outputData[i])) / Math.log(256);
      
      // 2. Simulate quantization (8-bit)
      const quantized = Math.round(compressed * 255) / 255;
      
      // 3. Decompress (simulate mu-law decoding)
      outputData[i] = Math.sign(quantized) * 
                   (Math.pow(256, Math.abs(quantized)) - 1) / 255;
    }
    
    // Apply extremely subtle noise (0.05% amplitude)
    for (let i = 0; i < length; i++) {
      outputData[i] += (Math.random() * 2 - 1) * 0.0005;
    }
    
    // Apply gentle low-pass filter
    let prevSample = outputData[0];
    const alpha = 0.20; // Filter strength
    
    for (let i = 0; i < length; i++) {
      prevSample = outputData[i] = prevSample + alpha * (outputData[i] - prevSample);
    }
  }
  
  return processedBuffer;
}
// Add this helper function to find zero crossings
function findBestZeroCrossings(buffer, rawStartSample, rawEndSample) {
    const searchWindowSamples = Math.ceil(buffer.sampleRate * 0.01); // 10ms search window
    let startSample = rawStartSample;
    let endSample = rawEndSample;
    
    try {
        // Get first channel data for analysis
        const data = buffer.getChannelData(0);
        const totalSamples = buffer.length;
        
        // Find zero crossings near start position
        const startCrossings = [];
        const startMin = Math.max(0, rawStartSample - searchWindowSamples);
        const startMax = Math.min(totalSamples - 2, rawStartSample + searchWindowSamples);
        
        for (let i = startMin; i < startMax; i++) {
            // Detect rising zero crossing (negative to positive)
            if (data[i] <= 0 && data[i + 1] > 0) {
                startCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'rising'
                });
            }
            // Detect falling zero crossing (positive to negative)
            else if (data[i] >= 0 && data[i + 1] < 0) {
                startCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'falling'
                });
            }
        }
        
        // Find zero crossings near end position
        const endCrossings = [];
        const endMin = Math.max(0, rawEndSample - searchWindowSamples);
        const endMax = Math.min(totalSamples - 2, rawEndSample + searchWindowSamples);
        
        for (let i = endMin; i < endMax; i++) {
            if (data[i] <= 0 && data[i + 1] > 0) {
                endCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'rising'
                });
            }
            else if (data[i] >= 0 && data[i + 1] < 0) {
                endCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'falling'
                });
            }
        }
        
        console.log(`Found ${startCrossings.length} start and ${endCrossings.length} end zero crossings`);
        
        // If we found zero crossings, match them by type and slope
        if (startCrossings.length > 0 && endCrossings.length > 0) {
            let bestMatch = { score: -Infinity, start: rawStartSample, end: rawEndSample };
            
            for (const start of startCrossings) {
                for (const end of endCrossings) {
                    // Score based on matching type and similar slope
                    const typeScore = (start.type === end.type) ? 5 : -2;
                    const slopeScore = 5 - Math.min(5, Math.abs(start.slope - end.slope) * 20);
                    const distanceScore = 3 - Math.min(3, 
                        (Math.abs(start.index - rawStartSample) + 
                         Math.abs(end.index - rawEndSample)) / (searchWindowSamples * 2) * 3);
                    
                    const score = typeScore + slopeScore + distanceScore;
                    
                    if (score > bestMatch.score) {
                        bestMatch = {
                            score,
                            start: start.index,
                            end: end.index
                        };
                    }
                }
            }
            
            if (bestMatch.score > 0) {
                console.log(`Using zero crossings: start=${bestMatch.start}, end=${bestMatch.end}, score=${bestMatch.score.toFixed(2)}`);
                startSample = bestMatch.start;
                endSample = bestMatch.end;
            }
        }
    } catch (e) {
        console.error("Error finding zero crossings:", e);
    }
    
    return { start: startSample, end: endSample };
}
function updateSampleProcessing() {
    console.log("Updating sample processing...");
    
    // Reset cached buffers
    fadedBuffer = null;
    cachedCrossfadedBuffer = null;
    lastCachedStartPos = null;
    lastCachedEndPos = null;
    lastCachedCrossfade = null;
    
    setTimeout(() => {
        if (audioBuffer) {
            // STEP 1: First trim to the desired region WITH ZERO-CROSSING ALIGNMENT
            const totalSamples = audioBuffer.length;
            const rawStartSample = Math.floor(sampleStartPosition * totalSamples);
            const rawEndSample = Math.floor(sampleEndPosition * totalSamples);
            
            // Find zero-crossings near the start and end points
            const alignedPoints = findBestZeroCrossings(
                audioBuffer, 
                rawStartSample, 
                rawEndSample
            );
            
            const startSample = alignedPoints.start;
            const endSample = alignedPoints.end;
            const trimmedLength = Math.max(2, endSample - startSample);
            
            // Store original duration for accurate playback timing
            fadedBufferOriginalDuration = (endSample - startSample) / audioBuffer.sampleRate;
            
            const trimmedBuffer = audioCtx.createBuffer(
                audioBuffer.numberOfChannels,
                trimmedLength,
                audioBuffer.sampleRate
            );
            
            // Copy the trimmed section
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const origData = audioBuffer.getChannelData(channel);
                const newData = trimmedBuffer.getChannelData(channel);
                for (let i = 0; i < trimmedLength; i++) {
                    newData[i] = origData[startSample + i];
                }
            }
            
            // STEP 2: Apply fades to the trimmed buffer
            let processedBuffer = trimmedBuffer;
            
            // Only apply fades if needed 
            if (sampleFadeInAmount > 0.01 || sampleFadeOutAmount > 0.01) {
                processedBuffer = audioCtx.createBuffer(
                    trimmedBuffer.numberOfChannels,
                    trimmedBuffer.length,
                    trimmedBuffer.sampleRate
                );
                
                // Calculate fade lengths once
                const fadeInSamples = Math.floor(trimmedLength * sampleFadeInAmount);
                const fadeOutSamples = Math.floor(trimmedLength * sampleFadeOutAmount);
                
                for (let c = 0; c < trimmedBuffer.numberOfChannels; c++) {
                    const inputData = trimmedBuffer.getChannelData(c);
                    const outputData = processedBuffer.getChannelData(c);
                    
                    // Copy all samples first
                    for (let i = 0; i < trimmedLength; i++) {
                        outputData[i] = inputData[i];
                    }
                    
                    // Apply fade in
                    for (let i = 0; i < fadeInSamples; i++) {
                        outputData[i] *= i / fadeInSamples;
                    }
                    
                    // Apply fade out
                    for (let i = 0; i < fadeOutSamples; i++) {
                        const idx = trimmedLength - 1 - i;
                        outputData[idx] *= i / fadeOutSamples;
                    }
                }
            }
            
            // Store the processed buffer (pre-lofi)
            let finalBuffer = processedBuffer;
            
            // STEP 3: Handle crossfade for looping (before applying Lo-Fi)
            if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
                setTimeout(() => {
                    const result = createCrossfadedBuffer(
                        processedBuffer,
                        0,  // Start from beginning of the processed buffer
                        1,  // Use entire processed buffer
                        sampleCrossfadeAmount
                    );
                    
                    if (result && result.buffer) {
                        let crossfadedBuffer = result.buffer;
                        
                        // STEP 4: Apply E-mu processing AFTER crossfade if enabled
                        if (isEmuModeOn) {
                            crossfadedBuffer = applyEmuProcessing(crossfadedBuffer);
                        }
                        
                        cachedCrossfadedBuffer = crossfadedBuffer;
                        lastCachedStartPos = sampleStartPosition;
                        lastCachedEndPos = sampleEndPosition;
                        lastCachedCrossfade = sampleCrossfadeAmount;
                    }
                }, 10);
            }
            
            // STEP 4: Apply E-mu processing at the very end for non-crossfaded cases
            if (isEmuModeOn) {
                finalBuffer = applyEmuProcessing(processedBuffer);
            }
            
            // Store the final processed buffer
            fadedBuffer = finalBuffer;
        }
    }, 10);
}
// Add MIDI controller support to overcome keyboard limitations
function setupMIDIAccess() {
  if (!navigator.requestMIDIAccess) {
    console.log("WebMIDI not supported in this browser");
    return;
  }

  navigator.requestMIDIAccess()
    .then(onMIDISuccess, onMIDIFailure);

  function onMIDISuccess(midiAccess) {
    console.log("MIDI access obtained");
    
    // Get lists of available MIDI controllers
    const inputs = midiAccess.inputs.values();
    
    // Connect to all available inputs
    for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
      input.value.onmidimessage = onMIDIMessage;
      console.log("Connected to MIDI device: " + input.value.name);
    }
    
    // Listen for new devices being connected
    midiAccess.onstatechange = function(e) {
      if (e.port.type === "input" && e.port.state === "connected") {
        e.port.onmidimessage = onMIDIMessage;
        console.log("Connected to MIDI device: " + e.port.name);
      }
    };
  }

  function onMIDIFailure(msg) {
    console.error("Failed to get MIDI access - " + msg);
  }

  function onMIDIMessage(event) {
    // Extract MIDI data
    const [command, note, velocity] = event.data;
    
    // Note on (144-159) with velocity > 0
    if ((command >= 144 && command <= 159) && velocity > 0) {
      // Convert MIDI note numbers (starts at 21 for A0) to our note system (starts at 0)
      const ourNoteNumber = Math.max(0, note - 36); // Adjust offset as needed
      noteOn(ourNoteNumber);
    } 
    // Note off (128-143) or note on with velocity 0
    else if ((command >= 128 && command <= 143) || 
             (command >= 144 && command <= 159 && velocity === 0)) {
      const ourNoteNumber = Math.max(0, note - 36); // Adjust offset as needed
      noteOff(ourNoteNumber);
    }
  }
}
// Detect iOS device
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

// Only show the unlock overlay on iOS devices
if (isIOS()) {
  // Wait a moment for everything else to initialize
  setTimeout(() => {
    createiOSStartupOverlay();
  }, 100);
}
// Add explicit touch handling for iOS throughout your UI
function addIOSTouchHandlers() {
  // Add touch handlers to all interactive elements
  const touchElements = document.querySelectorAll('.key, .knob, .button, .switch-container, .vertical-switch');
  
  touchElements.forEach(el => {
    el.addEventListener('touchstart', function(e) {
      // Ensure audio context is resumed on any touch
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          console.log('AudioContext resumed by user interaction');
        });
      }
      // Don't prevent default here to allow the original handlers to work
    });
  });
}
// Comprehensive fix for knobs and controls on both desktop and mobile
function fixAllControls() {
  // Fix desktop and mobile knob interaction
  document.querySelectorAll('.knob').forEach(knob => {
    // Create a completely fresh knob without any event listeners
    const newKnob = knob.cloneNode(true);
    knob.parentNode.replaceChild(newKnob, knob);
    
    // Extract ID and initial state
    const knobId = newKnob.id;
    const callback = knobInitializations[knobId];
    const defaultValue = knobDefaults[knobId] !== undefined ? knobDefaults[knobId] : 0.5;
    
    // Set up initial rotation
    let rotation = -150 + (defaultValue * 300);
    newKnob.style.transform = `rotate(${rotation}deg)`;
    
    // Track interaction state
    let isDragging = false;
    let startY, lastY;
    
    // Double-click/tap detection
    let lastClickTime = 0;
    
    // Desktop mouse handling
    newKnob.addEventListener('mousedown', function(e) {
      // Check for double-click
      const now = new Date().getTime();
      const timeSinceLastClick = now - lastClickTime;
      
      if (timeSinceLastClick < 350 && timeSinceLastClick > 0) {
        // Double-click - reset to default
        resetToDefault();
        e.preventDefault();
        return;
      }
      
      lastClickTime = now;
      
      // Start dragging
      isDragging = true;
      startY = e.clientY;
      lastY = startY;
      this.style.cursor = 'grabbing';
      
      // Set up document-level handlers
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      e.preventDefault();
    });
    
    function handleMouseMove(e) {
      if (!isDragging) return;
      
      // Calculate movement
      const deltaY = lastY - e.clientY;
      lastY = e.clientY;
      
      updateKnob(deltaY);
      e.preventDefault();
    }
    
    function handleMouseUp() {
      if (isDragging) {
        isDragging = false;
        newKnob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
    }
    
    // Touch handling
    newKnob.addEventListener('touchstart', function(e) {
      // Check for double-tap
      const now = new Date().getTime();
      const timeSinceLastClick = now - lastClickTime;
      
      if (timeSinceLastClick < 350 && timeSinceLastClick > 0) {
        // Double-tap - reset to default
        resetToDefault();
        e.preventDefault();
        return;
      }
      
      lastClickTime = now;
      
      // Only handle single touches
      if (e.touches.length !== 1) return;
      
      isDragging = true;
      startY = e.touches[0].clientY;
      lastY = startY;
      
      // Set up document-level handlers
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd);
      document.addEventListener('touchcancel', handleTouchEnd);
      
      e.preventDefault();
    }, { passive: false });
    
    function handleTouchMove(e) {
      if (!isDragging || e.touches.length !== 1) return;
      
      const deltaY = lastY - e.touches[0].clientY;
      lastY = e.touches[0].clientY;
      
      updateKnob(deltaY);
      e.preventDefault();
    }
    
    function handleTouchEnd() {
      if (isDragging) {
        isDragging = false;
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
        document.removeEventListener('touchcancel', handleTouchEnd);
      }
    }
    
    // Common function to update knob rotation and value
    function updateKnob(delta) {
      // Apply movement with sensitivity
      const newRotation = Math.min(150, Math.max(-150, rotation + delta));
      
      // Only update if there's actual change
      if (newRotation !== rotation) {
        rotation = newRotation;
        newKnob.style.transform = `rotate(${rotation}deg)`;
        
        if (callback) {
          const normalizedValue = (rotation + 150) / 300;
          callback(normalizedValue);
        }
      }
    }
    
    // Reset function for double-click/tap
    function resetToDefault() {
      rotation = -150 + (defaultValue * 300);
      newKnob.style.transform = `rotate(${rotation}deg)`;
      if (callback) {
        callback(defaultValue);
      }
      console.log(`Reset ${knobId} to default value:`, defaultValue);
    }
  });
  // Fix switch controls
  document.querySelectorAll('.vertical-switch').forEach(switchEl => {
    // Create fresh switch
    const newSwitch = switchEl.cloneNode(true);
    switchEl.parentNode.replaceChild(newSwitch, switchEl);
    
    // Simple click handler - works for both mouse and touch
    newSwitch.addEventListener('click', function(e) {
      this.classList.toggle('active');
      
      // Trigger switch updates based on ID
      const switchId = this.id;
      if (switchId === 'voice-mode-switch') {
        isMonoMode = this.classList.contains('active');
        cleanupAllNotes();
      } else if (switchId === 'trigger-mode-switch') {
        isLegatoMode = this.classList.contains('active');
      } else if (switchId === 'portamento-switch') {
        isPortamentoOn = this.classList.contains('active');
      }
      
      e.stopPropagation();
    });
    
    // Prevent default on touchstart to avoid scrolling
    newSwitch.addEventListener('touchstart', function(e) {
      e.preventDefault();
    }, { passive: false });
  });
}
// Fix Lo-Fi and Rec buttons (special buttons)
function initializeSpecialButtons() {
  // Fix for LoFi button
  const emuModeSwitch = document.getElementById('emu-mode-switch');
  if (emuModeSwitch) {
    // Remove any existing listeners first
    const newEmuSwitch = emuModeSwitch.cloneNode(true);
    emuModeSwitch.parentNode.replaceChild(newEmuSwitch, emuModeSwitch);
    // Add a single click handler with touch lock
    let touchLock = false;
    let touchTimeout;
    newEmuSwitch.addEventListener('click', function(e) {
      // Prevent rapid toggling
      if (touchLock) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      touchLock = true;
      // Toggle state
      const isActive = newEmuSwitch.classList.contains('active');
      isEmuModeOn = !isActive;
      // Update LED indicator
      const led = document.getElementById('emu-led');
      if (led) {
        led.classList.toggle('on', !isActive);
      }
      // Toggle active class
      newEmuSwitch.classList.toggle('active', !isActive);
      // Process with E-mu mode
      updateSampleProcessing();
      // Update any playing notes
      Object.values(activeNotes).forEach(note => {
        if (note && note.source && !heldNotes.includes(note.noteNumber)) {
          updateSamplePlaybackParameters(note);
        }
      });
      console.log('Lo-Fi Mode:', !isActive ? 'ON' : 'OFF');
      // Release lock after a delay
      clearTimeout(touchTimeout);
      touchTimeout = setTimeout(() => {
        touchLock = false;
      }, 300);
    });
    // Add touch handling that prevents propagation
    newEmuSwitch.addEventListener('touchstart', function(e) {
      e.stopPropagation();
    }, { passive: true });
    newEmuSwitch.addEventListener('touchend', function(e) {
      if (!touchLock) {
        this.click();
      }
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
  }
}
// Direct fix for vertical switches in touch mode
function fixSwitchesTouchMode() {
  // Target specific switches by ID
  const switchIds = ['voice-mode-switch', 'trigger-mode-switch', 'portamento-switch'];
  switchIds.forEach(id => {
    const switchEl = document.getElementById(id);
    if (!switchEl) return;
    // Remove ALL existing event listeners by cloning
    const newSwitch = switchEl.cloneNode(true);
    switchEl.parentNode.replaceChild(newSwitch, switchEl);
    
    // Add a single, simple touchstart event with proper passive setting
    newSwitch.addEventListener('touchstart', function(e) {
      // This is critical - must be at the top
      e.preventDefault();
      e.stopPropagation();
      // Simply toggle the active class
      this.classList.toggle('active');
      // Update state based on ID
      const isActive = this.classList.contains('active');
      console.log(`Switch ${id} touched, state now: ${isActive}`);
      
      switch(id) {
        case 'voice-mode-switch':
          isMonoMode = isActive;
          cleanupAllNotes();
          console.log('Voice Mode:', isActive ? 'MONO' : 'POLY');
          break;
        case 'trigger-mode-switch':
          isLegatoMode = isActive;
          console.log('Trigger Mode:', isActive ? 'LEGATO' : 'MULTI');
          break;
        case 'portamento-switch':
          isPortamentoOn = isActive;
          console.log('Portamento:', isPortamentoOn ? 'ON' : 'OFF');
          break;
      }
    }, { passive: false });  // passive: false is critical here!
    // Also handle normal clicks for mouse users
    newSwitch.addEventListener('click', function(e) {
      // Skip if this was a touch event that bubbled to click
      if (e.pointerType === 'touch') return;
      
      this.classList.toggle('active');
      const isActive = this.classList.contains('active');
      
      switch(id) {
        case 'voice-mode-switch':
          isMonoMode = isActive;
          cleanupAllNotes();
          break;
        case 'trigger-mode-switch':
          isLegatoMode = isActive;
          break;
        case 'portamento-switch':
          isPortamentoOn = isActive;
          break;
      }
    });
  });
}
document.addEventListener('DOMContentLoaded', () => {
  // -------------------------------
  //  Button Switches (dummy toggle)
  // -------------------------------
  document.querySelectorAll('.frame-for-button-switches > div').forEach((btn) => {
    btn.addEventListener('click', () => {
      // Toggle a simple "active" style when clicked
      if (btn.classList.contains('active')) {
        btn.classList.remove('active');
        btn.style.boxShadow = '';
      } else {
        btn.classList.add('active');
        // Simple visual: darker shadow to show it's in
        btn.style.boxShadow = 'inset 0 0 5px rgba(0,0,0,0.5)';
      }
    });
  });

  // ---------------------------------------------------------
  //  Five-Step Selector Slider (snap to 5 notches)
  // ---------------------------------------------------------
  const fiveStepThumb = document.querySelector('.five-Step-Selector-Slider-Thumb');
  if (fiveStepThumb) {
    let isDragging5Step = false;
    let startX = 0;
    let originalLeft = 0;

    // For example, clamp from 0 to 80px total movement
    // and snap to 5 notches => 0, 20, 40, 60, 80
    const minLeft = 0;
    const maxLeft = 80;
    const steps = 4; // 5 total positions => 4 intervals
    const stepSize = (maxLeft - minLeft) / steps;

    fiveStepThumb.addEventListener('mousedown', (e) => {
      isDragging5Step = true;
      startX = e.clientX;
      originalLeft = parseInt(window.getComputedStyle(fiveStepThumb).left, 10) || 0;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging5Step) return;
      const delta = e.clientX - startX;
      let newLeft = originalLeft + delta;

      // Clamp the thumbs position
      if (newLeft < minLeft) newLeft = minLeft;
      if (newLeft > maxLeft) newLeft = maxLeft;

      // Snap to nearest step
      const stepIndex = Math.round(newLeft / stepSize);
      const snappedLeft = stepIndex * stepSize;

      fiveStepThumb.style.left = snappedLeft + 'px';

      // Example: store or log a value from 0..4
      const currentValue = stepIndex; 
      // console.log('Five-step slider value:', currentValue);
    });

    document.addEventListener('mouseup', () => {
      isDragging5Step = false;
    });
  }

  // ---------------------------------------
  //  Rate Slider (dummy vertical drag)
  // ---------------------------------------
  const rateThumb = document.querySelector('.Rate-Slider-Thumb');
  const rateTrack = document.querySelector('.Rate-Slider-Track');
  if (rateThumb && rateTrack) {
    let isDraggingRate = false;
    let startY = 0;
    let originalTop = 0;

    // Suppose the track allows 0..80 px
    const minTop = 0;
    const maxTop = 80;

    rateThumb.addEventListener('mousedown', (e) => {
      isDraggingRate = true;
      startY = e.clientY;
      originalTop = parseInt(window.getComputedStyle(rateThumb).top, 10) || 0;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDraggingRate) return;
      const delta = e.clientY - startY;
      let newTop = originalTop + delta;

      // Clamp the thumbs position
      if (newTop < minTop) newTop = minTop;
      if (newTop > maxTop) newTop = maxTop;

      rateThumb.style.top = newTop + 'px';

      // Example: convert thumb position to 0..1
      const normalizedRateValue = (newTop - minTop) / (maxTop - minTop);
      // console.log('LFO Rate value:', normalizedRateValue.toFixed(2));
    });

    document.addEventListener('mouseup', () => {
      isDraggingRate = false;
    });
  }

  // ----------------------------------------
  //  Delay Slider (dummy vertical drag)
  // ----------------------------------------
  const delayThumb = document.querySelector('.Delay-Slider-Thumb');
  const delayTrack = document.querySelector('.Delay-Slider-Track');
  if (delayThumb && delayTrack) {
    let isDraggingDelay = false;
    let startY = 0;
    let originalTop = 0;

    // Suppose the track allows 0..80 px
    const minTop = 0;
    const maxTop = 80;

    delayThumb.addEventListener('mousedown', (e) => {
      isDraggingDelay = true;
      startY = e.clientY;
      originalTop = parseInt(window.getComputedStyle(delayThumb).top, 10) || 0;
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDraggingDelay) return;
      const delta = e.clientY - startY;
      let newTop = originalTop + delta;

      // Clamp the thumbs position
      if (newTop < minTop) newTop = minTop;
      if (newTop > maxTop) newTop = maxTop;

      delayThumb.style.top = newTop + 'px';

      // Example: convert thumb position to 0..1
      const normalizedDelayValue = (newTop - minTop) / (maxTop - minTop);
      // console.log('LFO Delay value:', normalizedDelayValue.toFixed(2));
    });

    document.addEventListener('mouseup', () => {
      isDraggingDelay = false;
    });
  }

  // Optional: add touch events for mobile (touchstart/touchmove/touchend)
});
document.addEventListener('DOMContentLoaded', () => {
  const fiveStep = document.querySelector('.five-step-selector-range');
  if (fiveStep) {
    fiveStep.addEventListener('input', () => {
      console.log('Five-step value:', fiveStep.value);
    });
  }

  const rateSlider = document.querySelector('.rate-slider-range');
  if (rateSlider) {
    rateSlider.addEventListener('input', () => {
      console.log('LFO Rate:', rateSlider.value);
    });
  }

  const delaySlider = document.querySelector('.delay-slider-range');
  if (delaySlider) {
    delaySlider.addEventListener('input', () => {
      console.log('LFO Delay:', delaySlider.value);
    });
  }
});
// CLEAN UP - Delete redundant and outdated event listeners
// Keep only this consolidated event listener for initialization
document.addEventListener('DOMContentLoaded', function() {
  // Core functionality
  generateKeyboard();
  updateSliderValues();
  updateVoiceDisplay();
  updateADSRVisualization();
  
  // Initialize controls
  fixAllControls();
  initializeSpecialButtons();
  fixSwitchesTouchMode();
  fixMicRecording();
  preventScrollOnControls();
  // Set up special handling for touch devices
  if (isTouchDevice()) {
    setupAutoHideTooltips();
  }
  // iOS-specific handling
  if (isIOS()) {
    addIOSTouchHandlers();
    document.body.style.touchAction = 'none';
    document.body.style.overscrollBehavior = 'none';
  }
  // MIDI functionality
  setupMIDIAccess();
  // Re-register any important listeners
  if (D('audio-file')) {
    D('audio-file').addEventListener('change', handleFileSelect);
  }
  // Add audio context resume handlers
  const resumeAudioContext = function() {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        console.log('AudioContext resumed');
      });
    }
  };
  document.body.addEventListener('touchstart', resumeAudioContext, { passive: true });
  document.body.addEventListener('mousedown', resumeAudioContext, { passive: true });
});
document.addEventListener('DOMContentLoaded', function() {
  const selectButton = document.getElementById('lfo-select-button');
  if (selectButton) {
    selectButton.addEventListener('click', function() {
      this.classList.toggle('active');
    });
  }
  
  // Initialize the depth knob
  const depthKnob = document.getElementById('lfo-depth-knob');
  if (depthKnob) {
    initializeKnob(depthKnob, (value) => {
      const tooltip = createTooltipForKnob('lfo-depth-knob', value);
      tooltip.textContent = `Depth: ${Math.round(value * 100)}%`;
      tooltip.style.opacity = '1';
      console.log('LFO Depth:', value.toFixed(2));
    });
  }
});
// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
  const reverseButton = document.getElementById('reverse-button');
  if (reverseButton) {
    reverseButton.addEventListener('click', function() {
      this.classList.toggle('active');
      isSampleReversed = this.classList.contains('active');
      
      // If we have a sample loaded, process it
      if (audioBuffer) {
        // Store original buffer on first use if it doesn't exist
        if (!originalBuffer) {
          originalBuffer = audioBuffer.slice();
        }
        
        // Apply reverse if needed
        reverseBufferIfNeeded();
        updateSampleProcessing();
        
        // Update any active notes
        Object.values(activeNotes).forEach(note => {
          if (note && note.source) {
            // Force re-processing
            note.usesProcessedBuffer = false;
            note.crossfadeActive = false;
            
            if (isSampleLoopOn) {
              note.looping = true;
              setupLoopCrossfade(note);
            }
            updateSamplePlaybackParameters(note);
          }
        });
      }
      
      console.log('Sample Reverse:', isSampleReversed ? 'ON' : 'OFF');
    });
  }
  
  // Initialize the Key-Track button (default: active)
  const keyTrackButton = document.getElementById('keytrack-button');
  
  if (keyTrackButton) {
    // Set initial state
    keyTrackButton.classList.add('active'); // Key tracking is on by default
    
    // Add click handler
    keyTrackButton.addEventListener('click', function() {
      this.classList.toggle('active');
      isSampleKeyTrackingOn = this.classList.contains('active');
      console.log('Sample Key Tracking:', isSampleKeyTrackingOn ? 'ON' : 'OFF');
    });
  }
});

  // Complete replacement for the global drag handler
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('mod-canvas');
  if (!canvas) return;
  
  // Global handlers for tracking mouse outside canvas
  let isDraggingOutside = false;
  let dragType = null; // 'point' or 'curve' 
  let dragPointIndex = -1;
  
  // Only attach document-level handlers once
  document.addEventListener('mousemove', handleGlobalMouseMove);
  document.addEventListener('mouseup', handleGlobalMouseUp);
  
  function handleGlobalMouseMove(e) {
  if (!isDraggingOutside) return;
  
  // Convert global coordinates to canvas coordinates
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // CRITICAL FIX: Special handling for curve points - most important part for left boundary fix
  if (dragType === 'curve' && dragPointIndex >= 0) {
    const state = canvas.__currentScript || {};
    const points = state.points || [];
    
    if (points && points.length > dragPointIndex + 1) {
      const startPoint = points[dragPointIndex];
      const endPoint = points[dragPointIndex + 1];
      
      if (startPoint && endPoint) {
        // Calculate segment bounds
        const minX = Math.min(startPoint.x, endPoint.x);
        const maxX = Math.max(startPoint.x, endPoint.x);
        
        // NEW APPROACH: For leftmost segment, allow control point to go further left
        let constrainedX;
        
        // Allow negative movement for first segment
        if (x < 0 && startPoint.x === 0) {
          // Allow control point to move up to half segment width to the left of minX
          const segmentWidth = maxX - minX;
          const extraLeftAllowance = segmentWidth * 0.5; // Adjust this factor as needed
          constrainedX = Math.max(minX - extraLeftAllowance, x);
        } 
        // For other segments or positive x, use normal constraints
        else if (x < 0) {
          constrainedX = minX;
        } 
        else {
          // Normal constraint within segment bounds
          constrainedX = Math.max(minX, Math.min(maxX, x));
        }
        
        // Apply the constrained position - Y remains unconstrained for deep curves
        if (typeof canvas.__handleCurveDrag === 'function') {
          canvas.__handleCurveDrag(constrainedX, y);
        }
      } else {
        // Fallback handling
        if (typeof canvas.__handleCurveDrag === 'function') {
          canvas.__handleCurveDrag(x, y);
        }
      }
    } else {
      // Fallback handling
      if (typeof canvas.__handleCurveDrag === 'function') {
        canvas.__handleCurveDrag(x, y);
      }
    }
  }
  // Normal handling for point dragging
  else if (dragType === 'point' && typeof canvas.__handlePointDrag === 'function') {
    canvas.__handlePointDrag(x, y);
  }
  
  // Redraw
  if (typeof canvas.__drawWaveform === 'function') {
    canvas.__drawWaveform();
  }
}
  
  function handleGlobalMouseUp() {
    if (!isDraggingOutside) return;
    
    // Reset drag state
    isDraggingOutside = false;
    dragType = null;
    dragPointIndex = -1;
    
    // Reset canvas internal state too
    if (typeof canvas.__resetDragState === 'function') {
      canvas.__resetDragState();
    }
  }
  
  // Watch canvas mouseleave events to activate global tracking
  canvas.addEventListener('mouseleave', function(e) {
    // Check if we were dragging something
    const state = canvas.__currentScript || {};
    
    if (state.isDraggingPoint && state.selectedPointIndex >= 0) {
      isDraggingOutside = true;
      dragType = 'point';
      dragPointIndex = state.selectedPointIndex;
    }
    else if (state.isDraggingCurve && state.activeCurveIndex >= 0) {
      isDraggingOutside = true;
      dragType = 'curve';
      dragPointIndex = state.activeCurveIndex;
    }
  });
  
  // Make sure we update the script reference when needed
  const originalMouseDown = canvas.addEventListener('mousedown', function() {
    setTimeout(updateScriptRef, 0);
  });
  
  const originalMouseMove = canvas.addEventListener('mousemove', function() {
    setTimeout(updateScriptRef, 0);
  });
  
  const originalMouseUp = canvas.addEventListener('mouseup', function() {
    isDraggingOutside = false;
    dragType = null;
    dragPointIndex = -1;
    setTimeout(updateScriptRef, 0);
  });
  
  function updateScriptRef() {
    if (typeof canvas.__updateScriptReference === 'function') {
      canvas.__updateScriptReference();
    }
  }
});

// Modify your main modulation canvas code
document.addEventListener('DOMContentLoaded', function() {
  const canvas = document.getElementById('mod-canvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  // Shared state variables
  const points = [];
  let selectedPointIndex = -1;
  let isDraggingPoint = false;
  let isDraggingCurve = false;
  let activeCurveIndex = -1;
  let lastTapTime = 0;
  
  // Store references to points and handlers on the canvas element for global access
  canvas.__points = points;
  canvas.__currentScript = {
    points,
    isDraggingPoint,
    isDraggingCurve,
    selectedPointIndex,
    activeCurveIndex
  };
  
  canvas.__handlePointDrag = handlePointDrag;
  canvas.__handleCurveDrag = handleCurveDrag;
  canvas.__drawWaveform = drawWaveform;
  canvas.__resetDragState = function() {
    isDraggingPoint = false;
    isDraggingCurve = false;
  };
  
  // Update the current script reference when states change
  function updateScriptReference() {
    canvas.__currentScript = {
      points,
      isDraggingPoint,
      isDraggingCurve,
      selectedPointIndex,
      activeCurveIndex
    };
  }
  canvas.__updateScriptReference = updateScriptReference;
  // Set initial waveform (sine wave)
  initializeDefaultWave();
  
  // Main drawing function
  function drawWaveform() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (points.length < 2) return;
    
    // Draw grid background
    drawGrid();
    
    // Draw the line segments
    ctx.strokeStyle = '#f2eed3';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    // Connect all points with curves or lines
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      const endPoint = points[i + 1];
      
      if (startPoint.noCurve) {
        // Draw straight line if curve is disabled
        ctx.lineTo(endPoint.x, endPoint.y);
      } else {
        // Calculate default control point if none exists
        if (!startPoint.curveX || !startPoint.curveY) {
          const midX = (startPoint.x + endPoint.x) / 2;
          const midY = (startPoint.y + endPoint.y) / 2;
          startPoint.curveX = midX;
          startPoint.curveY = midY;
        }
        
        // Ensure the curve stays inside the canvas bounds
        const clampedSegment = ensureCurveInsideBounds(
          startPoint.x, startPoint.y,
          startPoint.curveX, startPoint.curveY,
          endPoint.x, endPoint.y
        );
        
        ctx.quadraticCurveTo(
          clampedSegment.cpX, clampedSegment.cpY, 
          endPoint.x, endPoint.y
        );
      }
    }
    
    ctx.stroke();
    
    // Draw the main points
    points.forEach((point, index) => {
      ctx.fillStyle = index === selectedPointIndex ? '#ffcc00' : '#f2eed3';
      ctx.beginPath();
      ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw the curve control points
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      if (startPoint.noCurve) continue;
      
      const endPoint = points[i + 1];
      
      // Draw curve control point
      const isActive = i === activeCurveIndex;
      ctx.fillStyle = isActive ? '#ffcc00' : '#f2eed3';
      ctx.beginPath();
      ctx.arc(startPoint.curveX, startPoint.curveY, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw guide lines for active curve control point
      if (isActive) {
        ctx.strokeStyle = 'rgba(242, 238, 211, 0.4)';
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(startPoint.curveX, startPoint.curveY);
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
    
    // Draw help text
    drawInfoText();
  }
  
  // Grid background
  function drawGrid() {
    const gridSize = 10;
    ctx.strokeStyle = 'rgba(242, 238, 211, 0.1)';
    ctx.lineWidth = 0.5;
    
    for (let x = 0; x <= canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    
    for (let y = 0; y <= canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
  }
  
  // Keep curves within bounds
  function ensureCurveInsideBounds(x1, y1, cpX, cpY, x2, y2) {
    const padding = 1;
    const minY = padding;
    const maxY = canvas.height - padding;
    
    // Check multiple points along the curve
    const steps = 10;
    let maxOutOfBounds = 0;
    let direction = 0;
    
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const y = Math.pow(1-t, 2) * y1 + 2 * (1-t) * t * cpY + Math.pow(t, 2) * y2;
      
      if (y < minY && (minY - y) > maxOutOfBounds) {
        maxOutOfBounds = minY - y;
        direction = 1; // Move control point down
      } 
      else if (y > maxY && (y - maxY) > maxOutOfBounds) {
        maxOutOfBounds = y - maxY;
        direction = -1; // Move control point up
      }
    }
    
    // If curve goes out of bounds, adjust control point
    if (maxOutOfBounds > 0) {
      const correctionFactor = 2;
      cpY += direction * maxOutOfBounds * correctionFactor;
      
      // Verify the correction
      let maxViolation = 0;
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const y = Math.pow(1-t, 2) * y1 + 2 * (1-t) * t * cpY + Math.pow(t, 2) * y2;
        
        if (y < minY) maxViolation = Math.max(maxViolation, minY - y);
        else if (y > maxY) maxViolation = Math.max(maxViolation, y - maxY);
      }
      
      // If still violating, try stronger correction
      if (maxViolation > 0.5) {
        cpY += direction * maxViolation * correctionFactor;
      }
    }
    
    return { cpX, cpY };
  }
  
  // Constrain control points to segment's horizontal bounds
// Update the constrainControlPoint function - keeping it simple
function constrainControlPoint(startPoint, endPoint, curveX, curveY) {
  // First calculate normal segment bounds
  const minX = Math.min(startPoint.x, endPoint.x);
  const maxX = Math.max(startPoint.x, endPoint.x);
  
  // Get the critical X value that ensures monotonicity (always moving forward in time)
  // For a quadratic Bezier curve to move monotonically forward, the control point's X value
  // must be greater than this critical value
  const criticalX = startPoint.x - (endPoint.x - startPoint.x) / 2;
  
  // Use the larger of minX and criticalX to ensure no backward movement
  const effectiveMinX = Math.max(minX, criticalX);
  
  // If this is the leftmost segment, use a small positive value to prevent glitches
  if (startPoint.x === 0) {
    // Never let the control point go below the effective minimum X
    const constrainedX = Math.max(effectiveMinX, Math.min(maxX, curveX));
    
    // Special case: If we're at boundary, use 0.001 to prevent dragging issues
    if (constrainedX <= 0) {
      return { x: 0.001, y: curveY };
    }
    
    return { x: constrainedX, y: curveY };
  }
  
  // For all other segments, use the monotonicity constraint
  const constrainedX = Math.max(effectiveMinX, Math.min(maxX, curveX));
  return { x: constrainedX, y: curveY };
}
  
  // Constrain point Y position within canvas bounds
  function constrainPointY(y) {
    const padding = 1;
    return Math.max(padding, Math.min(canvas.height - padding, y));
  }
  
// Dynamically update control points when segment endpoints move
function updateControlPointsForSegment(segmentIndex) {
  if (segmentIndex < 0 || segmentIndex >= points.length - 1) return;
  
  const startPoint = points[segmentIndex];
  const endPoint = points[segmentIndex + 1];
  
  if (startPoint.noCurve) return;
  
  // If control point doesn't exist, create one at midpoint
  if (startPoint.curveX === undefined || startPoint.curveY === undefined) {
    startPoint.curveX = (startPoint.x + endPoint.x) / 2;
    startPoint.curveY = (startPoint.y + endPoint.y) / 2;
    return;
  }
  
  // Store original Y position
  const originalY = startPoint.curveY;
  
  // Calculate horizontal constraints - CRITICAL FIX
  const minX = Math.min(startPoint.x, endPoint.x);
  const maxX = Math.max(startPoint.x, endPoint.x);
  
  // CRITICAL FIX: Check if the current control point is out of horizontal bounds
  if (startPoint.curveX < minX || startPoint.curveX > maxX) {
    // If out of bounds, maintain relative horizontal position
    const segmentWidth = endPoint.x - startPoint.x;
    if (segmentWidth !== 0) {
      // Try to maintain the same relative position
      const xRatio = segmentWidth > 0 ? 
        (startPoint.curveX - startPoint.x) / segmentWidth : 
        0.5; // Default to middle if segment collapsed
        
      // Keep ratio within 0-1 range
      const clampedRatio = Math.max(0, Math.min(1, xRatio));
      startPoint.curveX = startPoint.x + (segmentWidth * clampedRatio);
    } else {
      // If segment has zero width, place control point at start point
      startPoint.curveX = startPoint.x;
    }
  }
  
  // Always ensure the control point stays within the segment bounds
  startPoint.curveX = Math.max(minX, Math.min(maxX, startPoint.curveX));
  
  // Preserve original Y position
  startPoint.curveY = originalY;
  
  // Ensure the curve stays within the canvas bounds
  const clampedCurve = ensureCurveInsideBounds(
    startPoint.x, startPoint.y,
    startPoint.curveX, startPoint.curveY,
    endPoint.x, endPoint.y
  );
  
  // Apply any needed vertical adjustment to keep curve in bounds
  startPoint.curveY = clampedCurve.cpY;
}
  
  // Default sine wave initialization
  function initializeDefaultWave() {
    points.length = 0;
    
    const width = canvas.width;
    const height = canvas.height;
    const center = height / 2;
    const amplitude = height / 3;
    
    // Create 5 points along a sine wave
    for (let i = 0; i < 5; i++) {
      const x = (i / 4) * width;
      const y = center - Math.sin((i / 4) * Math.PI * 2) * amplitude;
      
      if (i > 0) {
        const prevX = ((i-1) / 4) * width;
        const midX = (prevX + x) / 2;
        const curveY = center - Math.sin((((i - 0.5) / 4)) * Math.PI * 2) * amplitude;
        
        points[i-1].curveX = midX;
        points[i-1].curveY = curveY;
        points[i-1].noCurve = false;
      }
      
      points.push({ x, y, noCurve: false });
    }
    
    drawWaveform();
  }
  
  // Helper functions for finding closest elements
  function findClosestPoint(x, y) {
    let closestIndex = -1;
    let minDistance = 10; // Minimum distance to select
    
    points.forEach((point, index) => {
      const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
      if (distance < minDistance) {
        minDistance = distance;
        closestIndex = index;
      }
    });
    
    return closestIndex;
  }
  
  function findClosestCurvePoint(x, y) {
    let closestIndex = -1;
    let minDistance = 10;
    
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      if (startPoint.noCurve) continue;
      
      if (startPoint.curveX !== undefined && startPoint.curveY !== undefined) {
        const distance = Math.sqrt(Math.pow(startPoint.curveX - x, 2) + Math.pow(startPoint.curveY - y, 2));
        if (distance < minDistance) {
          minDistance = distance;
          closestIndex = i;
        }
      }
    }
    
    return closestIndex;
  }
  
  function findClosestLineSegment(x, y) {
    let closestIndex = -1;
    let minDistance = 10;
    
    for (let i = 0; i < points.length - 1; i++) {
      const startPoint = points[i];
      const endPoint = points[i + 1];
      
      // Calculate distance to line segment
      const A = x - startPoint.x;
      const B = y - startPoint.y;
      const C = endPoint.x - startPoint.x;
      const D = endPoint.y - startPoint.y;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) param = dot / lenSq;
      
      let xx, yy;
      
      if (param < 0) {
        xx = startPoint.x;
        yy = startPoint.y;
      } else if (param > 1) {
        xx = endPoint.x;
        yy = endPoint.y;
      } else {
        xx = startPoint.x + param * C;
        yy = startPoint.y + param * D;
      }
      
      const distance = Math.sqrt(Math.pow(x - xx, 2) + Math.pow(y - yy, 2));
      if (distance < minDistance) {
        minDistance = distance;
        closestIndex = i;
      }
    }
    
    return closestIndex;
  }
  
  // Add/remove points functions
  function findInsertPosition(x) {
    for (let i = 0; i < points.length; i++) {
      if (x < points[i].x) return i;
    }
    return points.length;
  }
  
  function addPoint(x, y) {
    const insertIndex = findInsertPosition(x);
    
    const minDistance = 0.1; 
    if ((insertIndex > 0 && x - points[insertIndex-1].x < minDistance) ||
        (insertIndex < points.length && points[insertIndex].x - x < minDistance)) {
      return -1;
    }
    
    y = constrainPointY(y);
    
    points.splice(insertIndex, 0, { x, y, noCurve: false });
    
    // Update curve control points
    if (insertIndex > 0) {
      const prevPoint = points[insertIndex - 1];
      const midX = (prevPoint.x + x) / 2;
      const midY = (prevPoint.y + y) / 2;
      prevPoint.curveX = midX;
      prevPoint.curveY = midY;
    }
    
    if (insertIndex < points.length - 1) {
      const nextPoint = points[insertIndex + 1];
      const midX = (x + nextPoint.x) / 2;
      const midY = (y + nextPoint.y) / 2;
      points[insertIndex].curveX = midX;
      points[insertIndex].curveY = midY;
    }
    
    return insertIndex;
  }
  
  function toggleCurveOnSegment(segmentIndex) {
    if (segmentIndex < 0 || segmentIndex >= points.length - 1) return;
    
    const startPoint = points[segmentIndex];
    
    if (startPoint.noCurve) {
      // Enable curve
      startPoint.noCurve = false;
      
      const endPoint = points[segmentIndex + 1];
      const midX = (startPoint.x + endPoint.x) / 2;
      const midY = (startPoint.y + endPoint.y) / 2;
      startPoint.curveX = midX;
      startPoint.curveY = midY;
    } else {
      // Disable curve
      startPoint.noCurve = true;
    }
  }
  
  function deletePoint(index) {
    if (index <= 0 || index >= points.length - 1 || points.length <= 2) {
      return false;
    }
    
    points.splice(index, 1);
    selectedPointIndex = -1;
    return true;
  }
  
  // Handle interaction for points and curves
  function handlePointDrag(x, y) {
    if (selectedPointIndex < 0) return;
    
    const oldX = points[selectedPointIndex].x;
    const oldY = points[selectedPointIndex].y;
    
    points[selectedPointIndex].y = constrainPointY(y);
    
    // Restrict horizontal movement for interior points
    if (selectedPointIndex > 0 && selectedPointIndex < points.length - 1) {
      const minX = points[selectedPointIndex - 1].x + 0.1;
      const maxX = points[selectedPointIndex + 1].x - 0.1;
      points[selectedPointIndex].x = Math.max(minX, Math.min(maxX, x));
    }
    // Keep first and last points at edges
    else if (selectedPointIndex === 0) {
      points[selectedPointIndex].x = 0; 
    }
    else if (selectedPointIndex === points.length - 1) {
      points[selectedPointIndex].x = canvas.width;
    }
    
    // If point has moved, update adjacent control points
    if (oldX !== points[selectedPointIndex].x || oldY !== points[selectedPointIndex].y) {
      if (selectedPointIndex > 0) {
        updateControlPointsForSegment(selectedPointIndex - 1);
      }
      
      if (selectedPointIndex < points.length - 1) {
        updateControlPointsForSegment(selectedPointIndex);
      }
    }
  }
  
  function handleCurveDrag(x, y) {
    if (activeCurveIndex < 0) return;
    
    const startPoint = points[activeCurveIndex];
    const endPoint = points[activeCurveIndex + 1];
    
    const constrained = constrainControlPoint(startPoint, endPoint, x, y);
    startPoint.curveX = constrained.x;
    startPoint.curveY = constrained.y;
    
    const clampedCurve = ensureCurveInsideBounds(
      startPoint.x, startPoint.y,
      startPoint.curveX, startPoint.curveY,
      endPoint.x, endPoint.y
    );
    
    startPoint.curveY = clampedCurve.cpY;
  }
  
  // Show help text 
  function drawInfoText() {
    ctx.fillStyle = "rgba(242, 238, 211, 0.6)";
    ctx.font = "8px Arial";
    ctx.textAlign = "center";
    ctx.fillText("", canvas.width/2, canvas.height - 5);
  }

  // Handle double click detection
  function handleDoubleInteraction(x, y) {
    // Check for point deletion
    const pointIndex = findClosestPoint(x, y);
    if (pointIndex >= 0 && pointIndex > 0 && pointIndex < points.length - 1) {
      deletePoint(pointIndex);
      drawWaveform();
      return true;
    }
    
    // Check for curve toggling
    const curveIndex = findClosestCurvePoint(x, y);
    if (curveIndex >= 0) {
      points[curveIndex].noCurve = true;
      drawWaveform();
      return true;
    }
    
    // Check for line segment curve toggling
    const lineIndex = findClosestLineSegment(x, y);
    if (lineIndex >= 0) {
      toggleCurveOnSegment(lineIndex);
      drawWaveform();
      return true;
    }
    
    // Add new point
    const newIndex = addPoint(x, y);
    if (newIndex >= 0) {
      selectedPointIndex = newIndex;
      isDraggingPoint = true;
      drawWaveform();
      return true;
    }
    
    return false;
  }
  
  // MOUSE EVENT HANDLERS
  canvas.addEventListener('mousedown', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Handle double-click
    if (e.detail === 2) {
      handleDoubleInteraction(x, y);
      return;
    }
    
    // Handle single click - check for curve control point first
    const curveIndex = findClosestCurvePoint(x, y);
    if (curveIndex >= 0) {
      isDraggingCurve = true;
      activeCurveIndex = curveIndex;
      drawWaveform();
      return;
    }
    
    // Then check for main points
    const pointIndex = findClosestPoint(x, y);
    if (pointIndex >= 0) {
      selectedPointIndex = pointIndex;
      isDraggingPoint = true;
      drawWaveform();
      return;
    }
    // After updating state, sync with the reference
    updateScriptReference();
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if (!isDraggingPoint && !isDraggingCurve) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (isDraggingPoint) {
      handlePointDrag(x, y);
    } else if (isDraggingCurve) {
      handleCurveDrag(x, y);
    }
    
    drawWaveform();
  });
  
  canvas.addEventListener('mouseup', function() {
    isDraggingPoint = false;
    isDraggingCurve = false;
    updateScriptReference();
  });
  
  canvas.addEventListener('mouseleave', function() {
    // Don't reset dragging flags here - allow document handler to work
    // Just update the reference
    updateScriptReference();
  });

  // TOUCH EVENT HANDLERS
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault(); // Prevent default to avoid scrolling
    if (e.touches.length !== 1) return;
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    // Check if this is a double-tap
    const now = Date.now();
    const timeSinceLastTap = now - lastTapTime;
    const isDoubleTap = (timeSinceLastTap < 300);
    lastTapTime = now;
    
    if (isDoubleTap) {
      handleDoubleInteraction(x, y);
      return;
    }
    
    // Single tap/touch - check for curve control point first
    const curveIndex = findClosestCurvePoint(x, y);
    if (curveIndex >= 0) {
      isDraggingCurve = true;
      activeCurveIndex = curveIndex;
      drawWaveform();
      return;
    }
    
    // Then check for main points
    const pointIndex = findClosestPoint(x, y);
    if (pointIndex >= 0) {
      selectedPointIndex = pointIndex;
      isDraggingPoint = true;
      drawWaveform();
      return;
    }
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(e) {
    if ((!isDraggingPoint && !isDraggingCurve) || e.touches.length !== 1) return;
    
    e.preventDefault(); // Prevent scrolling
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    if (isDraggingPoint) {
      handlePointDrag(x, y);
    } else if (isDraggingCurve) {
      handleCurveDrag(x, y);
    }
    
    drawWaveform();
  }, { passive: false });
  
  canvas.addEventListener('touchend', function() {
    isDraggingPoint = false;
    isDraggingCurve = false;
  });
  
  canvas.addEventListener('touchcancel', function() {
    isDraggingPoint = false;
    isDraggingCurve = false;
  });
  
  // Key event for deleting points
  document.addEventListener('keydown', function(e) {
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedPointIndex > 0 && selectedPointIndex < points.length - 1) {
      deletePoint(selectedPointIndex);
      drawWaveform();
    }
  });
  
  // Handle mode options
  document.querySelectorAll('.mode-option').forEach(option => {
    option.addEventListener('click', function() {
      document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
      this.classList.add('active');
    });
  });
  
  // Initialize on load
  drawWaveform();
});
// Add this to your JavaScript section
document.addEventListener('DOMContentLoaded', function() {
  // Get the modulation select button
  const modSelectButton = document.getElementById('mod-select-button');
  
  if (modSelectButton) {
    // Add click event listener 
    modSelectButton.addEventListener('click', function() {
      // Toggle active class for visual feedback
      this.classList.toggle('active');
      
      // Get current state (active or not)
      const isActive = this.classList.contains('active');
      
      // Log the state change
      console.log('Modulation Select button:', isActive ? 'ACTIVE' : 'INACTIVE');
      
      // Placeholder for actual functionality
      // This is where you would handle selecting destinations 
      // or whatever functionality this button should perform
      if (isActive) {
        // Enable selection mode - the modulation destination becomes
        // selectable when this button is active
        document.querySelector('.mod-destination-container').classList.add('selection-mode');
      } else {
        // Disable selection mode
        document.querySelector('.mod-destination-container').classList.remove('selection-mode');
      }
    });
    
    // Add touch event for mobile devices
    modSelectButton.addEventListener('touchstart', function(e) {
      e.preventDefault(); // Prevent double-triggering
      this.click(); // Trigger the click event
    }, { passive: false });
  }
});
// Make both oscillator FM source switches interactive
document.addEventListener('DOMContentLoaded', function() {
  // Find all oscillator FM source switches
  const oscSwitches = document.querySelectorAll('.osc-vertical-switch');
  
  // Process each switch individually
  oscSwitches.forEach((switchEl, index) => {
    // Ensure unique IDs to avoid conflicts
    if (!switchEl.id) {
      switchEl.id = `fm-source-switch-${index + 1}`;
    }
    
    // Remove any existing event listeners by cloning
    const newSwitch = switchEl.cloneNode(true);
    switchEl.parentNode.replaceChild(newSwitch, switchEl);
    switchEl = newSwitch;
    
    // Track state for each switch
    let isActive = false;
    
    // Simple click handler
    switchEl.addEventListener('click', function() {
      // Toggle state
      isActive = !isActive;
      this.classList.toggle('active', isActive);
      
      // Log which switch was toggled and its new state
      const switchNum = this.id.includes('2') ? 2 : 1;
      console.log(`Oscillator ${switchNum} FM Source changed to:`, 
                  isActive ? 'Osc 2' : 'Noise');
    });
    
    // Ensure touch support works properly
    switchEl.addEventListener('touchstart', function(e) {
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
    
    switchEl.addEventListener('touchend', function(e) {
      this.click();
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
    
    // Make the cursor style indicate it's clickable
    switchEl.style.cursor = 'pointer';
  });
});

document.addEventListener('DOMContentLoaded', function() {
  const shapeKnob = document.getElementById('mod-shape-knob');
  
  if (shapeKnob) {
    let currentPosition = 0; // 0-4 for the 5 positions
    let isDragging = false;
    let lastY;
    let accumulatedDelta = 0; // Track accumulated movement
    
    // Position angles for the 5 discrete positions (in degrees)
    const positions = [0, 72, 144, 216, 288];
    
    // Initial position
    updateKnobPosition();
    
    function updateKnobPosition() {
      shapeKnob.style.transform = `rotate(${positions[currentPosition]}deg)`;
    }
    
    function handleMouseDown(e) {
      isDragging = true;
      lastY = e.clientY;
      accumulatedDelta = 0; // Reset accumulated delta on new drag
      shapeKnob.style.cursor = 'grabbing';
      e.preventDefault();
    }
    
    function handleMouseMove(e) {
      if (!isDragging) return;
      
      // Calculate vertical movement (up = increase, down = decrease)
      const deltaY = lastY - e.clientY;
      lastY = e.clientY;
      
      // Initial threshold to start registering movement
      if (Math.abs(deltaY) >= 1) {
        // Add to accumulated delta
        accumulatedDelta += deltaY;
        
        // Require a larger accumulated threshold to actually change position
        // This creates resistance between steps
        const positionChangeThreshold = 15; // Pixels needed to move to next position
        
        if (Math.abs(accumulatedDelta) >= positionChangeThreshold) {
          // Determine direction of movement
          const direction = accumulatedDelta > 0 ? 1 : -1;
          
          // Calculate new position with wrapping
          let newPosition = currentPosition + direction;
          
          // Wrap around 0-4 range
          if (newPosition < 0) newPosition = 4;
          if (newPosition > 4) newPosition = 0;
          
          // Only update if position actually changed
          if (newPosition !== currentPosition) {
            currentPosition = newPosition;
            updateKnobPosition();
            console.log(`Shape position changed to: ${currentPosition}`);
          }
          
          // Reset accumulated delta after position change
          accumulatedDelta = 0;
        }
      }
      
      e.preventDefault();
    }
    
    function handleMouseUp() {
      isDragging = false;
      accumulatedDelta = 0;
      shapeKnob.style.cursor = 'pointer';
    }
    
    // Mouse events
    shapeKnob.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Touch events
    shapeKnob.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        isDragging = true;
        lastY = e.touches[0].clientY;
        accumulatedDelta = 0;
      }
      e.preventDefault();
    }, { passive: false });
    
    document.addEventListener('touchmove', function(e) {
      if (!isDragging || e.touches.length !== 1) return;
      
      const deltaY = lastY - e.touches[0].clientY;
      lastY = e.touches[0].clientY;
      
      if (Math.abs(deltaY) >= 1) {
        accumulatedDelta += deltaY;
        
        const positionChangeThreshold = 15;
        
        if (Math.abs(accumulatedDelta) >= positionChangeThreshold) {
          const direction = accumulatedDelta > 0 ? 1 : -1;
          let newPosition = currentPosition + direction;
          
          if (newPosition < 0) newPosition = 4;
          if (newPosition > 4) newPosition = 0;
          
          if (newPosition !== currentPosition) {
            currentPosition = newPosition;
            updateKnobPosition();
            console.log(`Shape position changed to: ${currentPosition}`);
          }
          
          accumulatedDelta = 0;
        }
      }
      e.preventDefault();
    }, { passive: false });
    
    document.addEventListener('touchend', handleMouseUp);
    document.addEventListener('touchcancel', handleMouseUp);
  }
});
document.addEventListener('DOMContentLoaded', function() {
  // Get all matrix buttons
  const matrixButtons = document.querySelectorAll('.matrix-buttons-container .matrix-button');
  
  // Set up event listeners for each button
  matrixButtons.forEach((button, index) => {
    button.addEventListener('click', function() {
      // If this button is already active, do nothing
      if (button.classList.contains('active')) {
        return;
      }
      
      // Remove active class from all buttons
      matrixButtons.forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Add active class to clicked button
      button.classList.add('active');
      
      // You can add additional functionality based on which button was clicked
      console.log(`Matrix button ${index + 1} activated`);
    });
  });
  
  // Optionally make the first button active by default
  matrixButtons[0].classList.add('active');
});
document.addEventListener('DOMContentLoaded', function() {
  // Toggle buttons (Record, Play/Stop, Additive)
  const toggleButtons = document.querySelectorAll('.record-button');
  toggleButtons.forEach(button => {
    button.addEventListener('click', function() {
      this.classList.toggle('active');
    });
  });
  
  // Initialize the Layers knob
  const layersKnob = document.getElementById('looper-layers-knob');
  if (layersKnob) {
    let currentPosition = 0; // 0-7 for the 8 positions
    let isDragging = false;
    let startY;
    let totalMovement = 0;
    
    // Position angles for the 8 discrete positions in the -150 to +150 range (in degrees)
    const positions = [-150, -107.14, -64.29, -21.43, 21.43, 64.29, 107.14, 150];
    
    // Initial position
    updateKnobPosition();
    
    function updateKnobPosition() {
      // Snap directly to the exact angle for the current position
      layersKnob.style.transform = `rotate(${positions[currentPosition]}deg)`;
    }
    
    layersKnob.addEventListener('mousedown', function(e) {
      isDragging = true;
      startY = e.clientY;
      totalMovement = 0;
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', function(e) {
      if (!isDragging) return;
      
      // Calculate the vertical movement
      const deltaY = startY - e.clientY;
      totalMovement += deltaY;
      startY = e.clientY;
      
      // Determine if we should change position based on amount moved
      const moveThreshold = 20; // Pixels needed to move to next step
      
      if (totalMovement >= moveThreshold) {
        // Move up one position (if not already at max)
        if (currentPosition < 7) {
          currentPosition++;
          updateKnobPosition();
          console.log(`Layers position: ${currentPosition + 1}/8`);
        }
        totalMovement = 0;
      }
      else if (totalMovement <= -moveThreshold) {
        // Move down one position (if not already at min)
        if (currentPosition > 0) {
          currentPosition--;
          updateKnobPosition();
          console.log(`Layers position: ${currentPosition + 1}/8`);
        }
        totalMovement = 0;
      }
    });
    
    document.addEventListener('mouseup', function() {
      isDragging = false;
      totalMovement = 0;
    });
    
    // Touch support with similar snapping behavior
    layersKnob.addEventListener('touchstart', function(e) {
      if (e.touches.length !== 1) return;
      
      isDragging = true;
      startY = e.touches[0].clientY;
      totalMovement = 0;
      e.preventDefault();
    }, { passive: false });
    
    document.addEventListener('touchmove', function(e) {
      if (!isDragging || e.touches.length !== 1) return;
      
      const deltaY = startY - e.touches[0].clientY;
      totalMovement += deltaY;
      startY = e.touches[0].clientY;
      
      const moveThreshold = 20;
      
      if (totalMovement >= moveThreshold) {
        if (currentPosition < 7) {
          currentPosition++;
          updateKnobPosition();
          console.log(`Layers position: ${currentPosition + 1}/8`);
        }
        totalMovement = 0;
      }
      else if (totalMovement <= -moveThreshold) {
        if (currentPosition > 0) {
          currentPosition--;
          updateKnobPosition(); 
          console.log(`Layers position: ${currentPosition + 1}/8`);
        }
        totalMovement = 0;
      }
      
      e.preventDefault();
    }, { passive: false });
    
    document.addEventListener('touchend', function() {
      isDragging = false;
      totalMovement = 0;
    });
    
    // Double-click/tap to reset to first position
    layersKnob.addEventListener('dblclick', function() {
      currentPosition = 0;
      updateKnobPosition();
      console.log("Layers reset to position 1/8");
    });
    
    let lastTap = 0;
    layersKnob.addEventListener('touchend', function(e) {
      const now = Date.now();
      if (now - lastTap < 300) {
        // Double-tap detected
        currentPosition = 0;
        updateKnobPosition();
        console.log("Layers reset to position 1/8");
      }
      lastTap = now;
    });
  }
});
document.addEventListener('DOMContentLoaded', function() {
  const chorusButton = document.getElementById('chorus-button');
  let chorusState = 0; // 0: off, 1: first I lit, 2: both I's lit
  
  if (chorusButton) {
    chorusButton.addEventListener('click', function() {
      // Advance to next state
      chorusState = (chorusState + 1) % 3;
      
      // Remove all state classes first
      chorusButton.classList.remove('state-1', 'state-2');
      
      // Apply the appropriate class based on state
      if (chorusState === 1) {
        chorusButton.classList.add('state-1');
        console.log('Chorus: Light mode activated');
      } else if (chorusState === 2) {
        chorusButton.classList.add('state-2');
        console.log('Chorus: Heavy mode activated');
      } else {
        console.log('Chorus: Off');
      }
    });
  }
});
document.addEventListener('DOMContentLoaded', function() {
  // Initialize switches
  const delayModuleSwitches = document.querySelectorAll('.delay-module .vertical-switch');
  
  delayModuleSwitches.forEach(switchEl => {
    switchEl.addEventListener('click', function() {
      this.classList.toggle('active');
      console.log(`${this.id} switched: ${this.classList.contains('active') ? 'ON' : 'OFF'}`);
    });
  });
});
// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
  // Initialize horizontal switches
  const horizontalSwitches = document.querySelectorAll('.horizontal-switch');
  
  horizontalSwitches.forEach(switchEl => {
    switchEl.addEventListener('click', function() {
      this.classList.toggle('active');
      console.log(`${this.id} toggled: ${this.classList.contains('active') ? 'ON' : 'OFF'}`);
    });
  });
});
    </script>
</body>
</html>