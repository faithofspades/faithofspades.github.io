<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ARDIST - Thule</title>
    <style>
        
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5dc;
            color: #3f2101;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
    max-width: 1500px; /* Increased from 1200px - 25% wider */
    width: 100%;
}
        
        h2 {
            color: #8b4513;
            margin-bottom: 5px;
        }
        
        p {
            margin-top: 5px;
            margin-bottom: 15px;
        }
        
        /* Synth panel styling */
        /* Update the synth-panel class */
.synth-panel {
    display: flex;  /* Change from grid to flex */
    flex-direction: row;
    gap: 2px;
    background-color: #f0e6d2;
    border: 2px solid #3f2101;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    overflow-x: auto;  /* Allow horizontal scrolling if needed */
}
        
        .module {
    background-color: #f5f5dc;
    border: 1px solid #3f2101;
    border-radius: 5px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    width: 80px; /* Fixed width, reduced by ~30% from original */
    min-width: 80px; /* Same as width to prevent resizing */
    max-width: 80px; /* Same as width to prevent resizing */
}
        
        .module-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3f2101;
        }
        .wave-select-container {
    position: relative;
    width: 100%;
    margin: 10px 0;
}
/* Styling for the sampler module with two columns */
.sampler-module {
  width: 160px; /* Double the width of regular modules */
  min-width: 160px; /* Keep the minimum width consistent */
  max-width: 160px; /* Maximum width */
}

.sampler-columns {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: 100%;
}

.sampler-column {
  width: 48%; /* Slightly less than 50% to allow for spacing */
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Make the file section take full width of its column */
.sampler-column .file-section {
  width: 100%;
}

/* Adjust knobs to fit within narrower columns */
.sampler-column .knob {
  margin: 8px auto; /* Slightly reduced margin */
}

/* Update sampler column labels to match other modules */
.sampler-column label {
  font-size: 16px; /* Changed from 11px to match oscillator modules */
  margin-bottom: 5px;
  font-family: 'Courier New', Courier, monospace; /* Explicitly set font family */
  color: #3f2101; /* Match text color */
  text-align: center; /* Ensure consistent alignment */
}
/* Updated sample selector styling to match rest of the interface */
.sample-selector-container {
  width: 100%;
  position: relative;
  margin: 5px 0 10px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Match button styling perfectly to Load Sample button */
#sample-selector-btn {
  width: 80%;
  height: 32px;
  min-height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #e6e6e6;
  color: #3f2101;
  border: 1px solid #3f2101;
  border-radius: 3px;
  padding: 8px;
  font-family: 'Courier New', Courier, monospace; /* Match font family */
  font-size: 12px; /* Match font size */
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
}

#sample-selector-btn:hover {
  background: #d4c6a8;
}

/* Update dropdown menu styling to match theme */
.sample-dropdown {
  display: none;
  position: absolute;
  top: 40px; /* Position below button */
  background-color: #e6e6e6; /* Match button background */
  width: 80%; /* Match button width */
  box-shadow: 0px 8px 16px 0px rgba(63, 33, 1, 0.2);
  z-index: 100;
  border-radius: 3px;
  border: 1px solid #3f2101;
  max-height: 150px;
  overflow-y: auto;
}

.sample-dropdown.show {
  display: block;
}

.dropdown-item {
  padding: 6px 8px;
  text-decoration: none;
  display: block;
  color: #3f2101;
  font-family: 'Courier New', Courier, monospace; /* Match font family */
  font-size: 12px; /* Match font size */
  cursor: pointer;
}

.dropdown-item:hover {
  background-color: #d4c6a8;
}
/* Fix alignment of right column knobs */
#sample-start-knob {
  margin-top: 11px !important; /* Push down the first knob in right column */
}

/* Make space for dropdown to prevent elements pushing down */
.sample-selector-container {
  margin-bottom: 5px;
  height: 42px; /* Fixed height to match file input area */
}
/* Add to your style section */
.lofi-button-container {
  margin: 10px 0 10px 0; /* Adjusted from 10px 0 */
  display: flex;
  justify-content: center;
  align-items: center; /* Added to help with vertical alignment */
}

.lofi-button {
  position: relative;
  width: 45px;     /* Changed from 60px to make square */
  height: 45px;    /* Changed from 30px to match width */
  background-color: #e6e6e6;
  border: 1px solid #3f2101;
  border-radius: 8px;  /* Slightly increased for better appearance */
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  color: #3f2101;
  transition: background-color 0.2s;
}



.lofi-button:hover {
  background-color: #d4c6a8;
}

.lofi-button.active {
  background-color: #c0b090;
}

/* Update LED position for the square button */
.lofi-button .led-indicator {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 6px;
  height: 6px;
  border-radius: 50%;
}

.lofi-button .led-indicator.on {
  background-color: #ff5500;
  box-shadow: 0 0 3px #ff5500;
}
.rec-button-container {
  margin: 10px 0 10px 0; /* Make sure both containers use identical margins */
  display: flex;
  justify-content: center;
  align-items: center; /* Added to help with vertical alignment */
}

.rec-button {
  position: relative;
  width: 45px;
  height: 45px;
  background-color: #e6e6e6;
  border: 1px solid #3f2101;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  color: #3f2101;
  transition: background-color 0.2s;
}

.rec-button:hover {
  background-color: #d4c6a8;
}

.rec-button.recording {
  background-color: #ff5500;
  color: #fff;
}

.rec-button .led-indicator {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 6px;
  height: 6px;
  border-radius: 50%;
}

.rec-button .led-indicator.on {
  background-color: #ff0000;
  box-shadow: 0 0 5px #ff0000;
  animation: pulsate 1s infinite;
}

@keyframes pulsate {
  0% { opacity: 1; }
  50% { opacity: 0.6; }
  100% { opacity: 1; }
}
.sampler-column .lofi-button-container {
  margin-top: 15px; /* Increase top margin slightly */
  margin-bottom: 10px;
  height: 47px; /* Set explicit height */
  position: relative;
  top: -3px; /* Small upward adjustment */
}

.sampler-column .rec-button-container {
  margin-top: 10px;
  margin-bottom: 10px;
  height: 47px; /* Set explicit height */
}
/* Position the switch container */
.sampler-column .switch-container {
  margin-top: 8px;
  margin-bottom: 8px;
  width: 100%;
}
.wave-select {
    width: 100%;
    padding: 8px;
    border: 1px solid #3f2101;
    border-radius: 4px;
    background-color: #e6e6e6;
    color: #3f2101;
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
}

/* Custom dropdown arrow */
.wave-select-container::after {
    content: '';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid #3f2101;
    pointer-events: none;
}

/* Hover and focus states */
.wave-select:hover {
    background-color: #d4c6a8;
}

.wave-select:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
    background-color: #f5f5dc;
}

.tooltip {
    position: absolute;
    background: rgba(63, 33, 1, 0.9);
    color: #f5f5dc;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s;
}
/* Style for options */
.wave-select option {
    background-color: #f5f5dc;
    color: #3f2101;
    padding: 8px;
}
        /* Sliders and knobs */
        .knob {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e6e6e6;
    border: 1px solid #3f2101;
    position: relative;
    margin: 10px auto;
    cursor: grab;
    transform-origin: center center;
    transition: transform 0.05s ease-out;
}

.knob:active {
    cursor: grabbing;
}

.knob::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 3px;    /* Changed from 3px to 2px for consistency */
    height: 14px;   /* Changed from 14px to 10px for consistency */
    background-color: #3f2101;
    transform-origin: bottom center;
    transform: translateX(-50%);
}
        
.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    height: 120px;
    margin: 0 10px;
}

.slider-container label {
    font-size: 12px;
    color: #3f2101;
    margin-top: 10px;
}

.slider-container input[type="range"] {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-35px, 35px);
}

.slider-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.slider-container input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

.slider-container span {
    font-size: 12px;
    color: #3f2101;
    margin-top: 5px;
}
        
        /* Radio button group styling */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 10px 0;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        /* Keyboard responsive resizing */
.keyboard {
    display: flex;
    width: 100%;
    position: relative;
    background-color: #f0e6d2;
    border: 2px solid #3f2101;
    border-radius: 5px;
    /* Create an aspect ratio container */
    aspect-ratio: 4 / 1; /* Width:Height ratio for the keyboard */
    max-height: 190px; /* Maximum height */
    margin-top: 20px;
    overflow: hidden;
}

.key {
    flex: 1;
    height: 100%;
    background-color: #f5f5dc;
    border: 1px solid #3f2101;
    cursor: pointer;
    position: relative;
    user-select: none;
    margin: 0;
    padding: 0;
}

.key.black {
    background-color: #3f2101;
    position: absolute;
    width: 7%; /* Relative width instead of fixed pixels */
    height: 60%; /* Height relative to keyboard height */
    z-index: 1;
    border: none;
    transform: translateX(-50%);
    max-width: 5.5%; /* Maximum width for larger screens */
}

/* Update black key positioning calculations */
.key.black:nth-of-type(15) { left: calc(100% * 1/14); }   /* C# */
.key.black:nth-of-type(16) { left: calc(100% * 2/14); }   /* D# */
.key.black:nth-of-type(17) { left: calc(100% * 4/14); }   /* F# */
.key.black:nth-of-type(18) { left: calc(100% * 5/14); }   /* G# */
.key.black:nth-of-type(19) { left: calc(100% * 6/14); }   /* A# */
.key.black:nth-of-type(20) { left: calc(100% * 8/14); }   /* C# (second octave) */
.key.black:nth-of-type(21) { left: calc(100% * 9/14); }   /* D# (second octave) */
.key.black:nth-of-type(22) { left: calc(100% * 11/14); }  /* F# (second octave) */
.key.black:nth-of-type(23) { left: calc(100% * 12/14); }  /* G# (second octave) */
.key.black:nth-of-type(24) { left: calc(100% * 13/14); }  /* A# (second octave) */
/* Add a responsive adjustment for small screens */
@media (max-width: 768px) {
    .keyboard {
        max-height: 150px; /* Smaller maximum height on small screens */
    }
    
    .key.black {
        width: 8%; /* Slightly wider on small screens for better touch targets */
    }
}

/* For very small screens */
@media (max-width: 480px) {
    .keyboard {
        max-height: 120px; /* Even smaller on very small screens */
    }
}
/* Make sure the black keys overflow is visible */

.key.pressed {
    background-color: #d4c6a8;
}

.key.black.pressed {
    background-color: #6b4e29;
}
        
        /* Voice monitoring */
        .voice-monitor {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #3f2101;
            border-radius: 4px;
            background-color: #f0e6d2;
        }
        
        .voice-item {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            background-color: #e0e0e0;
            border-radius: 3px;
            border: 1px solid #3f2101;
        }
        
        .active-voice {
            background-color: #8b4513;
            color: white;
        }
        
        /* File section styling */
        .file-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        input[type="file"] {
            background-color: #f0e6d2;
            border: 1px solid #3f2101;
            border-radius: 3px;
            padding: 5px;
        }
        
        /* ADSR graph visualization */
        .adsr-graph {
            height: 100px;
            width: 100%;
            border: 1px solid #3f2101;
            background-color: #f5f5dc;
            margin: 10px 0;
            position: relative;
        }
        
        .adsr-line {
            position: absolute;
            background-color: #8b4513;
            width: 2px;
            height: 100%;
            top: 0;
            left: 0;
        }
        
body {
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
/* Base knob style */
.knob.notched {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e6e6e6;
    border: 1px solid #3f2101;
    position: absolute;
    top: 0;
    left: 0;
    cursor: grab;
    z-index: 2;
}

/* Notch marks around the knob */
.knob.notched::before {
    content: '';
    position: absolute;
    top: -4px;  /* Position outside the knob */
    left: -4px;
    width: 48px;  /* Larger than the knob */
    height: 48px;
    border-radius: 50%;
    background: conic-gradient(
        from 60deg,
        transparent 0deg 2deg,
        #3f2101 2deg 4deg,      /* -2 octave notch */
        transparent 4deg 58deg,
        #3f2101 58deg 60deg,    /* -1 octave notch */
        transparent 60deg 118deg,
        #3f2101 118deg 120deg,  /* 0 octave notch */
        transparent 120deg 178deg,
        #3f2101 178deg 180deg,  /* +1 octave notch */
        transparent 180deg 238deg,
        #3f2101 238deg 240deg,  /* +2 octave notch */
        transparent 240deg 360deg
    );
    opacity: 0.6;
    pointer-events: none;
    z-index: 1;
}

/* Indicator line */
.knob.notched::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 10px;
    background-color: #3f2101;
    transform-origin: bottom center;
    transform: translateX(-50%);
    z-index: 3;
}

.knob-container {
    position: relative;
    width: 40px;
    height: 40px;
    margin: 10px auto;
}
/* Fixed notch ring */
.knob-container::before {
    content: '';
    position: absolute;
    top: -4px;
    left: -4px;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: conic-gradient(
        from 240deg,
        #3f2101 0deg 2deg,      /* -2 octave notch */
        transparent 2deg 58deg,
        #3f2101 58deg 60deg,    /* -1 octave notch */
        transparent 60deg 118deg,
        #3f2101 118deg 120deg,  /* 0 octave notch */
        transparent 120deg 178deg,
        #3f2101 178deg 180deg,  /* +1 octave notch */
        transparent 180deg 238deg,
        #3f2101 238deg 240deg,  /* +2 octave notch */
        transparent 240deg 360deg
    );
    opacity: 0.6;
    pointer-events: none;
    z-index: 1;
}
.knob-value {
    font-size: 12px;
    margin-top: 4px;
    color: #3f2101;
}

.octave-control {
    display: flex;
    flex-direction: row;
    align-items: center;
    margin: 10px 0;
    position: relative;
    height: 120px;
}

.octave-slider {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(0%, 22%);
    margin: 35px 0;

}

.octave-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.octave-slider::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

.octave-ticks {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 100px;
    font-size: 12px;
    color: #3f2101;
    margin-left: -80px; /* Adjust space between slider and ticks */
}
/* Adjust the label position */
.octave-control label {
    position: absolute;
    bottom: -10px; /* Moved down by 10px */
    left: 50%;
    transform: translateX(-50%);
    font-size: 15px;
    color: #3f2101;
}
.octave-ticks span {
    line-height: 20px;
}
/* Update the ADSR module layout */
.module[style="grid-column: span 2;"] .module-title {
    margin-top: -5px; /* Adjust to move text up by 5px */
    margin-bottom: 14px;
    padding-top: 0;
    padding-bottom: 5px; /* Add padding-bottom to put the underline in the right spot */
    display: block;
}

.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 60px;
    height: 140px;
    position: relative;
    margin-bottom: 30px; /* Add space for the lower labels */
}

.slider-container label {
    position: absolute;
    bottom: -30px; /* Move labels much lower */
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-container span {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-group {
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
    height: 170px;
    margin: 10px 0;
    padding-bottom: 30px; /* Increased padding for lower labels */
}
.module[style="grid-column: span 0;"] {
    display: flex;
    flex-direction: column;
    min-height: 250px;
    min-width: 400px; /* Add minimum width */
    padding: 15px;
}

.adsr-graph {
    width: 100%;
    height: 100px;
    min-height: 100px;
    border: 1px solid #3f2101;
    background-color: #f5f5dc;
    margin: 10px 0;
    position: relative;
    overflow: hidden; /* Prevent overflow */
}

.slider-group {
    display: flex;
    flex-direction: row;
    justify-content: space-evenly; /* Changed from space-around */
    align-items: center;
    width: 100%;
    height: 150px;
    margin: 10px 0;
}

.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 60px; /* Fixed width for container */
    height: 140px;
    position: relative;
}

.slider-container input[type="range"] {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-35px, 35px);
    margin: 35px 0;
}

.slider-container span {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-container label {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}
/* ADSR module styles */
.module[style="grid-column: span 0;"] {
    display: flex;
    flex-direction: column;
    width: 160px; /* Match graph width */
    min-width: 160px;
    padding: 15px;
    align-items: center;
}

.adsr-graph {
    width: 105%; /* Reduced from 100% to 80% */
    height: 80px;
    border: 1px solid #3f2101;
    background-color: #f5f5dc;
    margin-bottom: 20px;
    position: relative;
}

/* Values row */
.slider-values {
    display: flex;
    justify-content: space-between;
    width: 220px; /* Match slider group width */
    margin-bottom: 5px;
}

.slider-values span {
    font-size: 12px;
    color: #3f2101;
    width: 40px;
    text-align: center;
}

.slider-group {
    width: 160px; /* Match graph width */
    display: flex;
    justify-content: center;
    margin: 10px 0;
    gap: 7%;
}

.slider-group input[type="range"] {
    width: 120px; /* Reduced width */
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(0px, -50px); /* Adjusted translation */
}

.slider-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.slider-group input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

/* Labels row */
.slider-labels {
    display: flex;
    justify-content: space-between;
    width: 220px;
    margin-top: -10px;
}

.slider-labels label {
    font-size: 12px;
    color: #3f2101;
    width: 40px;
    text-align: center;
}
/* ADSR container styles */
.module[style="grid-column: span 2;"] {
    display: flex;
    flex-direction: column;
    min-width: 170px;
    max-width: 170px;
    padding: 15px;
    align-items: center;
    
}
input[type="range"] {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

input[type="range"]:focus {
    outline: none;
}

input[type="range"]::-moz-focus-outer {
    border: 0;
}

.slider-group {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

.slider-container {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

* {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
}
/* Individual slider containers */
.slider-attack, .slider-decay, .slider-sustain, .slider-release {
    position: relative;
    width: 35px; /* Unchanged base width */
    height: 120px;
    margin: 0 7%;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none; /* Prevent text selection */
    pointer-events: none; /* Prevent container from capturing clicks */

}

/* Common slider styles */
.slider-group input[type="range"] {
    position: absolute;
    width: 160px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-40%, 40%);
    /* Center the slider over its label */
    left: -89.5px;
    pointer-events: auto; /* Re-enable clicks for slider */
}

/* Values above sliders */
#attack-value, #decay-value, #sustain-value, #release-value {
    position: absolute;
    top: -20px;
    width: 35px;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

/* Labels below sliders */
.slider-labels {
    display: flex;
    justify-content: space-between;
    width: 180px;
    margin-top: 5px;
}

.slider-labels label {
    width: 35px;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

/* Slider group containing all sliders */
.slider-group {
    display: flex;
    justify-content: center;
    width: 180px;
    margin: 10px 0;
    gap: 7%; /* Added gap property to match margin */
    
}
/* Add to your existing CSS */
.file-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin: 5px 0;
}

.custom-file-input {
    position: relative;
    width: 80%;
    height: 45px;
    overflow: hidden;
}

.custom-file-input input[type="file"] {
    position: absolute;
    font-size: 100px;
    opacity: 0;
    right: 0;
    top: 0;
    cursor: pointer;
}

.custom-file-input label {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 3px;
    padding: 8px;
    font-size: 12px;
    color: #3f2101;
    text-align: center;
    cursor: pointer;
    height: 32px;  /* Fixed height */
    min-height: 32px;
    width: 100%;
    box-sizing: border-box;
}

#file-status {
    font-size: 10px;
    color: #3f2101;
    margin-top: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 90%;
    text-align: center;
}
/* Add vertical switch styling */
.switch-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px 0;
}

.switch-label {
    font-size: 10px;
    margin-bottom: 5px;
    color: #3f2101;
    text-align: center;
}

/* Update vertical switch styling */
.vertical-switch {
    width: 20px;
    height: 40px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 10px;
    position: relative;
    cursor: grab;
}

.vertical-switch::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 18px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    border-radius: 8px;
    left: 1px;
    top: 1px;
    transition: top 0.1s;
}

.vertical-switch.active::after {
    top: 19px;
}

/* Mono controls container */
.mono-controls {
    width: 100%;
    transition: opacity 0.3s;
}

.legato-controls {
    width: 100%;
    transition: opacity 0.3s;
}

    </style>
</head>
<body>
    </style>
</head>
<body>
    <div class="container">
        
        <div class="synth-panel">
            
        <!-- Modified SAMPLER Module with Two Columns and Sample Selector -->
<div class="module sampler-module">
    <div class="module-title">SAMPLER</div>
    
    <!-- Two-column layout container -->
    <div class="sampler-columns">
      <!-- Left Column -->
      <div class="sampler-column">
        <div class="file-section">
          <div class="custom-file-input">
            <input type="file" id="audio-file" accept="audio/*">
            <label for="audio-file">Load Sample</label>
          </div>
        </div>
        <div class="switch-container lofi-button-container">
            <div class="lofi-button" id="emu-mode-switch">
              <span>Lo-Fi</span>
              <div class="led-indicator" id="emu-led"></div>
            </div>
          </div>
        <div class="knob" id="sample-volume-knob"></div>
        <label for="sample-volume-knob" style="text-align: center;">Volume</label>
        <div class="knob" id="sample-pitch-knob"></div>
        <label for="sample-pitch-knob" style="text-align: center;">Pitch</label>
      <!-- Add this knob to the right column of your sampler module -->
<div class="knob" id="sample-fade-knob"></div>
<label for="sample-fade-knob" style="text-align: center;">Fade</label>
    </div>
      
      <!-- Right Column -->
      <div class="sampler-column">
        <!-- Sample selector dropdown -->
        <div class="sample-selector-container">
          <button id="sample-selector-btn">Presets ▼</button>
          <div id="sample-dropdown" class="sample-dropdown">
            <div class="dropdown-item" data-sample="Dirty Bass.wav">Dirty Bass</div>
            <div class="dropdown-item" data-sample="Keys - Piano.wav">Piano</div>
            <div class="dropdown-item" data-sample="Noise.wav">Noise</div>
            <div class="dropdown-item" data-sample="Saw.wav">Saw</div>
          </div>
        </div>
        <div class="switch-container rec-button-container">
            <div class="rec-button" id="mic-record-button">
              <span>Rec</span>
              <div class="led-indicator" id="rec-led"></div>
            </div>
          </div>
        <div class="knob" id="sample-start-knob"></div>
        <label for="sample-start-knob" style="text-align: center;">Start</label>
        <div class="knob" id="sample-end-knob"></div>
        <label for="sample-end-knob" style="text-align: center;">End</label>
        <div class="knob" id="sample-crossfade-knob"></div>
        <label for="sample-crossfade-knob" style="text-align: center;">Crossfade</label>
      </div>
    </div>
  </div>
            <!-- OSC 1 Module -->
            <div class="module">
                <div class="module-title">OSC 1</div>
                <div class="wave-select-container">
                    <select class="wave-select" name="osc1-wave">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="saw">Saw</option>
                        <option value="square">Square</option>
                        <option value="pulse">Pulse</option>
                    </select>
                </div>
                <div class="knob" id="osc1-pwm-knob"></div>
                <label for="osc1-pwm-knob" style="text-align: center;">PWM</label>
                <div class="knob" id="osc1-gain-knob"></div>
                <label for="osc1-gain-knob" style="text-align: center;">Gain</label>
                <div class="octave-control">
                    <input type="range" class="octave-slider" min="-2" max="2" step="1" value="0">
                    <div class="octave-ticks">
                        <span>+2</span>
                        <span>+1</span>
                        <span>0</span>
                        <span>-1</span>
                        <span>-2</span>
                    </div>
                    <label>Octave</label>
                </div>
            </div>

            <!-- OSC 2 Module -->
            <div class="module">
                <div class="module-title">OSC 2</div>
                <div class="wave-select-container">
                    <select class="wave-select" name="osc2-wave">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="saw">Saw</option>
                        <option value="square">Square</option>
                        <option value="pulse">Pulse</option>
                    </select>
                </div>
                <div class="knob" id="osc2-pwm-knob"></div>
                <label for="osc2-pwm-knob" style="text-align: center;">PWM</label>
                <div class="knob" id="osc2-gain-knob"></div>
                <label for="osc2-gain-knob" style="text-align: center;">Gain</label>
                <div class="octave-control">
                    <input type="range" class="octave-slider" min="-2" max="2" step="1" value="0">
                    <div class="octave-ticks">
                        <span>+2</span>
                        <span>+1</span>
                        <span>0</span>
                        <span>-1</span>
                        <span>-2</span>
                    </div>
                    <label>Octave</label>
                </div>
            </div>

            

            <!-- ADSR Module -->
            <div class="module" style="grid-column: span 2;">
                <div class="module-title">ADSR Envelope</div>
                
                <div class="adsr-graph" id="adsr-visualization">
                    <div class="adsr-line"></div>
                </div>
            
                <div class="slider-group">
                    <div class="slider-attack">
                        <span id="attack-value">0</span>
                        <input type="range" id="attack" min="0" max="5" step="0.001" value="0">
                    </div>
                    <div class="slider-decay">
                        <span id="decay-value">0.1</span>
                        <input type="range" id="decay" min="0" max="5" step="0.01" value="0.1">
                    </div>
                    <div class="slider-sustain">
                        <span id="sustain-value">0.7</span>
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
                    </div>
                    <div class="slider-release">
                        <span id="release-value">0.01</span>
                        <input type="range" id="release" min="0" max="5" step="0.001" value="0.001">
                    </div>
                </div>
                <div class="slider-labels">
                    <label>A</label>
                    <label>D</label>
                    <label>S</label>
                    <label>R</label>
                </div>
            </div>
            

<div class="module">
    <div class="module-title">MASTER</div>
    
    <!-- Voice Mode Switch -->
    <div class="switch-container">
        <label class="switch-label">POLY/MONO</label>
        <div class="vertical-switch" id="voice-mode-switch"></div>
    </div>
    
    <!-- Mono controls -->
    <div class="mono-controls">
        <!-- Trigger Mode Switch -->
        <div class="switch-container">
            <label class="switch-label">MULTI/LEGATO</label>
            <div class="vertical-switch" id="trigger-mode-switch"></div>
        </div>
        
        <!-- Portamento controls -->
        <div class="legato-controls">
            <div class="switch-container">
                <label class="switch-label">PORTA ON/OFF</label>
                <div class="vertical-switch" id="portamento-switch"></div>
            </div>
            
            <!-- Glide Time Knob -->
            <div class="knob" id="glide-time-knob"></div>
            <label for="glide-time-knob">GLIDE</label>
        </div>
    </div>
    
    <!-- Master Volume -->
    <div class="knob" id="master-volume-knob"></div>
    <label for="master-volume-knob">Volume</label>
</div>
    
   
      

        </div> <!-- End of synth-panel -->
        
        <!-- Keyboard -->
        <div class="keyboard" id="keyboard">
            <!-- Keys will be generated by JavaScript -->
        </div>
        
        <div class="voice-monitor">
            <h3>Active Voices: <span id="voice-count">0</span>/6</h3>
            <div id="voice-display"></div>
        </div>
    </div>

    <script>
        const D = x => document.getElementById(x);
        const TR2 = 2 ** (1.0 / 12.0);
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        masterGain.connect(audioCtx.destination);


// Main keys (first + second octave)
const keys = [
  'Z','S','X','D','C','V','G','B','H','N','J','M',  // First octave
  'Q','2','W','3','E','R','5','T','6','Y','7','U'   // Second octave
];

// Extra punctuation → note index mapping (second octave)
const specialKeyMap = {
  ',': 12, // C
  '.': 14, // D
  '/': 16, // E
  'L': 13, // C#
  'l': 13, // Handle lowercase L
  ';': 15,  // D#
    // Third octave (C through G):
    'I': 24, // C
    "i": 24, // Handle lowercase I
  '9': 25, // C#
  'O': 26, // D
  "o": 26, // Handle lowercase O
  '0': 27, // D#
  'P': 28, // E
  "p": 28, // Handle lowercase P
  '[': 29, // F
  '=': 30, // F#
  ']': 31  // G
};

// Add this after the masterGain initialization
let currentVolume = 0.5; // Initial volume
masterGain.gain.setValueAtTime(currentVolume, audioCtx.currentTime, 0.01);
// Add these global variables at the top with other audio-related variables
// Add to your global variables
let currentSampleDetune = 0; // Range will be -1200 to +1200 cents
let isEmuModeOn = false;
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;
let recordingStartTime = null;
let fadedBufferOriginalDuration = null;
let emuFilterNode = null;
let lastPlayedNote = null;
let sampleSource = null;
let isPlaying = false;
let sampleStartPosition = 0; // 0-1 range representing portion of audio file
let sampleEndPosition = 1;   // 0-1 range (default to full sample)
let sampleCrossfadeAmount = 0; // 0-1 range for crossfade percentage
let isSampleLoopOn = false; // Will now be controlled by crossfade knob
let cachedCrossfadedBuffer = null;
let crossfadeUpdateTimer = null;
let sampleFadeInAmount = 0;
let sampleFadeOutAmount = 0;
let fadeProcessTimer = null;
let fadedBuffer = null;
let startUpdateTimer = null;
let endUpdateTimer = null;
let lastCachedStartPos = null;
let lastCachedEndPos = null;
let lastCachedCrossfade = null;
// Add at top with other global variables
sampleGainNode = audioCtx.createGain();
sampleGainNode.gain.value = 0.5;
// Update the createNote function to use a reference to the current gain value
let currentSampleGain = 0.5; // Add this with other global variables
let currentSamplePosition = 0; // Add this with other global variables
const knobDefaults = {
  'sample-start-knob': 0.0,     // Start at beginning of sample
  'sample-end-knob': 1.0,       // End at end of sample
  'sample-crossfade-knob': 0.0, // No crossfade initially
  'glide-time-knob': 0.05,      // 100ms (5% of 2000ms)
  // All other knobs default to 0.5
};
// Replace all knob-related code with this single implementation
// Add touch support for knobs and keyboard
// Create a startup overlay for iOS devices
function createiOSStartupOverlay() {
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.backgroundColor = 'rgba(245, 245, 220, 0.95)';
  overlay.style.zIndex = '9999';
  overlay.style.display = 'flex';
  overlay.style.flexDirection = 'column';
  overlay.style.justifyContent = 'center';
  overlay.style.alignItems = 'center';
  overlay.style.textAlign = 'center';
  
  const heading = document.createElement('h2');
  heading.textContent = 'THULE Sampler';
  heading.style.color = '#8b4513';
  heading.style.marginBottom = '20px';
  
  const message = document.createElement('p');
  message.textContent = 'Tap anywhere to enable audio';
  message.style.marginBottom = '30px';
  message.style.color = '#3f2101';
  
  const button = document.createElement('button');
  button.textContent = 'Start Synth';
  button.style.padding = '15px 30px';
  button.style.fontSize = '18px';
  button.style.backgroundColor = '#e6e6e6';
  button.style.border = '1px solid #3f2101';
  button.style.borderRadius = '8px';
  button.style.color = '#3f2101';
  button.style.cursor = 'pointer';
  
  overlay.appendChild(heading);
  overlay.appendChild(message);
  overlay.appendChild(button);
  
  // Make sure overlay is in the DOM before adding audio context
  document.body.appendChild(overlay);
  
// Prepare the audio context but don't resume yet
if (window.AudioContext || window.webkitAudioContext) {
    // Use your own silent audio file
    const silentAudio = document.createElement('audio');
    silentAudio.src = 'silence.mp3'; // Path to your silent audio file
    silentAudio.setAttribute('loop', 'loop');
    silentAudio.setAttribute('preload', 'auto');
    silentAudio.style.display = 'none';
    document.body.appendChild(silentAudio);
    
    function unlockAudio(event) {
      // This is the key change: multiple unlock methods in a synchronous user event handler
      
      // 1. Play the silent audio element first (this works for iOS Chrome)
      const playPromise = silentAudio.play();
      
      // 2. Resume the AudioContext
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      
      // 3. Create and play an immediate oscillator (works in Safari)
      try {
        const oscillator = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.001; // Nearly silent
        oscillator.connect(gain);
        gain.connect(audioCtx.destination);
        oscillator.start(0);
        oscillator.stop(0.5);
      } catch(e) {
        console.log("Error creating oscillator:", e);
      }
      
      // 4. Create and play a buffer source (alternative method)
      try {
        const buffer = audioCtx.createBuffer(1, 1, 22050);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0);
      } catch(e) {
        console.log("Error playing buffer:", e);
      }
      
      console.log("Audio unlock attempts complete, removing overlay");
      
      // Remove the overlay with slight delay
      setTimeout(() => {
        document.body.removeChild(overlay);
        // Keep the silent audio element playing in the background
      }, 50);
      
      // Clean up event listeners
      overlay.removeEventListener('touchstart', unlockAudio);
      button.removeEventListener('touchstart', unlockAudio);
      overlay.removeEventListener('click', unlockAudio);
      
      // Prevent default
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    
    // Add event listeners for both touch and click
    overlay.addEventListener('touchstart', unlockAudio, { passive: false });
    button.addEventListener('touchstart', unlockAudio, { passive: false });
    overlay.addEventListener('click', unlockAudio);
  }
}

// Initialize for all mobile devices to be safe
if (/iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  // Use DOMContentLoaded for more reliable initialization
  document.addEventListener('DOMContentLoaded', () => {
    createiOSStartupOverlay();
  });
}
// Add this function at the beginning of your script
function createIOSChromeAudioUnlocker() {
  // Create a special overlay for Chrome on iOS
  const overlay = document.createElement('div');
  overlay.innerHTML = `
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
         background: rgba(245, 245, 220, 0.95); z-index: 99999; display: flex; 
         flex-direction: column; justify-content: center; align-items: center; text-align: center;">
      <h2 style="color: #8b4513;">THULE Sampler</h2>
      <p style="margin: 20px 0;">Tap the button below to enable audio</p>
      <button id="ios-chrome-audio-unlock" style="padding: 16px 32px; font-size: 18px; 
              background: #e6e6e6; border: 1px solid #3f2101; border-radius: 8px; 
              color: #3f2101; cursor: pointer;">START SYNTHESIZER</button>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Create a hidden HTML5 audio element (crucial for Chrome on iOS)
  const audioElement = document.createElement('audio');
  audioElement.setAttribute('src', 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABIgD///////////////////////////////////////////8AAAA8TEFNRTMuMTAwAQAAAAAAAAAAABUgJAMGQQABmgAAIicg4EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=');
  audioElement.setAttribute('playsinline', '');
  audioElement.setAttribute('preload', 'auto');
  audioElement.setAttribute('loop', 'loop');
  audioElement.style.display = 'none';
  document.body.appendChild(audioElement);
  
  // Function to unlock audio with special handling for Chrome on iOS
  function unlockAudioForChromeIOS() {
    console.log("Attempting to unlock audio for Chrome on iOS");
    
    // 1. First, try to play the HTML5 audio element
    const playPromise = audioElement.play();
    
    if (playPromise !== undefined) {
      playPromise.then(() => {
        console.log("Audio element playback successful");
        
        // 2. After successful audio element play, resume AudioContext
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().then(() => {
            console.log("AudioContext resumed");
          }).catch(err => {
            console.error("Failed to resume AudioContext:", err);
          });
        }
        
        // 3. Create a silent oscillator (important for iOS Chrome)
        try {
          const oscillator = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          gain.gain.value = 0.001;
          oscillator.connect(gain);
          gain.connect(audioCtx.destination);
          oscillator.start(0);
          oscillator.stop(audioCtx.currentTime + 0.5);
          console.log("Created silent oscillator");
        } catch(e) {
          console.error("Failed to create oscillator:", e);
        }
        
        // Remove the overlay
        setTimeout(() => {
          document.body.removeChild(overlay);
        }, 100);
        
      }).catch(err => {
        console.error("Audio playback failed:", err);
        // Show a more direct error message to the user
        alert("Audio couldn't be enabled. Please reload and try again, making sure to tap directly on the button.");
      });
    }
  }
  
  // Add event listener directly to the button
  document.getElementById('ios-chrome-audio-unlock').addEventListener('click', unlockAudioForChromeIOS);
  document.getElementById('ios-chrome-audio-unlock').addEventListener('touchend', unlockAudioForChromeIOS);
}
// Function to detect Chrome on iOS specifically
function isChromeOnIOS() {
  const userAgent = navigator.userAgent;
  return /iPad|iPhone|iPod/.test(userAgent) && /CriOS/.test(userAgent);
}

// Show the special Chrome iOS unlocker only when needed
document.addEventListener('DOMContentLoaded', function() {
  if (isChromeOnIOS()) {
    console.log("Detected Chrome on iOS - showing special audio unlock UI");
    createIOSChromeAudioUnlocker();
  } else if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
    // Use your original iOS unlocker for Safari
    createiOSStartupOverlay();
  }
});
// Detect if the device is a touch device
function isTouchDevice() {
  return ('ontouchstart' in window) || 
         (navigator.maxTouchPoints > 0) || 
         (navigator.msMaxTouchPoints > 0);
}

function initializeKnob(knob, onChange) {
  // Remove any existing event listeners first
  const newKnob = knob.cloneNode(true);
  knob.parentNode.replaceChild(newKnob, knob);
  knob = newKnob;
  
  // Use default value from knobDefaults if available, otherwise 0.5
  const defaultValue = knobDefaults[knob.id] !== undefined ? knobDefaults[knob.id] : 0.5;
  
  // Set initial rotation based on default value WITHOUT triggering tooltip
  let rotation = -150 + (defaultValue * 300);
  let isDragging = false;
  let lastY;
  let initialMovement = true;  // Flag to track first movement

  // Set the initial visual rotation
  knob.style.transform = `rotate(${rotation}deg)`;

  function resetToDefault() {
    rotation = -150 + (defaultValue * 300);
    knob.style.transform = `rotate(${rotation}deg)`;
    if (onChange) {
      onChange(defaultValue);
    }
  }

  function handleMove(y) {
    const sensitivity = 1.0;
    const deltaY = (lastY - y) * sensitivity;
    
    if (initialMovement) {
      // On first movement, just record the position but don't apply the delta
      initialMovement = false;
      lastY = y;
      return;
    }

    lastY = y;
    
    const newRotation = Math.min(150, Math.max(-150, rotation + deltaY));
    
    if (newRotation !== rotation) {
      rotation = newRotation;
      knob.style.transform = `rotate(${rotation}deg)`;
      
      if (onChange) {
        const normalizedValue = (rotation + 150) / 300;
        onChange(normalizedValue);
      }
    }
  }

  function handleMouseMove(e) {
    if (!isDragging) return;
    handleMove(e.clientY);
    e.preventDefault();
    e.stopPropagation();
  }

  function handleTouchMove(e) {
    if (!isDragging || !e.touches[0]) return;
    handleMove(e.touches[0].clientY);
    
    // Critical: prevent default to stop page scrolling while turning knobs
    e.preventDefault();
    e.stopPropagation();
  }

  function handleEnd() {
    isDragging = false;
    initialMovement = true; // Reset for next drag
    knob.style.cursor = 'grab';
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleEnd);
    document.removeEventListener('touchcancel', handleEnd);
  }

  knob.addEventListener('click', (e) => {
    if (e.altKey) {
      resetToDefault();
    }
  });

  knob.addEventListener('dblclick', () => {
    resetToDefault();
  });

  knob.addEventListener('mousedown', (e) => {
    if (!e.altKey) {
      isDragging = true;
      initialMovement = true; // Reset flag on new drag
      lastY = e.clientY;
      knob.style.cursor = 'grabbing';
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleEnd);
    }
    e.preventDefault();
  });

  // Add touch support with proper scroll prevention
  knob.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      initialMovement = true;
      lastY = e.touches[0].clientY;
      
      // Critical: add touchmove listener with passive: false to allow preventDefault
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleEnd);
      document.addEventListener('touchcancel', handleEnd);
    }
    e.preventDefault();
  }, { passive: false });

  // Also update the parameters directly when the default is applied
  if (knob.id === 'sample-start-knob') {
    sampleStartPosition = defaultValue;
  } else if (knob.id === 'sample-end-knob') {
    sampleEndPosition = defaultValue;
  } else if (knob.id === 'sample-crossfade-knob') {
    sampleCrossfadeAmount = defaultValue;
    isSampleLoopOn = defaultValue > 0.01;
  } else if (knob.id === 'glide-time-knob') {
    glideTime = defaultValue * 2; // 0-2 seconds range
  }

  return {
    getValue: () => (rotation + 150) / 300,
    setValue: (value, triggerOnChange = false) => {
      const newRotation = (value * 300) - 150;
      rotation = Math.min(150, Math.max(-150, newRotation));
      knob.style.transform = `rotate(${rotation}deg)`;
      
      // Only trigger onChange if explicitly requested
      if (onChange && triggerOnChange) {
        onChange(value);
      }
    }
  };
}
// Also fix the notched knob function with the same change
function initializeNotchedKnob(knob, onChange) {
  let rotation = 0;
  let isDragging = false;
  let lastY;
  const degreesPerStep = 60;

  function snapToNotch(rotation) {
    const steps = Math.round(rotation / degreesPerStep);
    const limitedSteps = Math.max(-2, Math.min(2, steps));
    return limitedSteps * degreesPerStep;
  }

  function handleMove(y) {
    const sensitivity = 1.5; 
    const deltaY = (lastY - y) * sensitivity;
    lastY = y;
    
    let newRotation = rotation + deltaY;
    newRotation = snapToNotch(newRotation);
    
    if (newRotation !== rotation) {
      rotation = newRotation;
      knob.style.transform = `rotate(${rotation}deg)`;
      
      if (onChange) {
        const octaveValue = Math.round(-rotation / degreesPerStep);
        onChange(octaveValue);
      }
    }
  }

  function handleMouseMove(e) {
    if (!isDragging) return;
    handleMove(e.clientY);
    e.preventDefault();
    e.stopPropagation();
  }
  
  function handleTouchMove(e) {
    if (!isDragging || !e.touches[0]) return;
    handleMove(e.touches[0].clientY);
    
    // Critical: prevent default to stop page scrolling
    e.preventDefault();
    e.stopPropagation();
  }

  function handleEnd() {
    isDragging = false;
    knob.style.cursor = 'grab';
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleEnd);
    document.removeEventListener('touchcancel', handleEnd);
  }

  knob.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastY = e.clientY;
    knob.style.cursor = 'grabbing';
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleEnd);
    e.preventDefault();
  });

  // Add touch support with proper scroll prevention
  knob.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      lastY = e.touches[0].clientY;
      
      // Critical: add touchmove listener with passive: false
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleEnd);
      document.addEventListener('touchcancel', handleEnd);
    }
    e.preventDefault();
  }, { passive: false });

  return {
    getValue: () => -Math.round(rotation / degreesPerStep),
    setValue: (octave) => {
      rotation = -octave * degreesPerStep;
      knob.style.transform = `rotate(${rotation}deg)`;
    }
  };
}
// Function to process the buffer with fade in/out before crossfades
// Function to process the buffer with fade in/out after applying start/end points
// Clean up the processing order and fade handling functions

// Fix the mic recording functionality once and for all
// FIXED VERSION
function fixMicRecording() {
  // Get button reference FIRST
  const recButton = document.getElementById('mic-record-button');
  if (!recButton) return;
  
  // Then clone it
  const newRecButton = recButton.cloneNode(true);
  recButton.parentNode.replaceChild(newRecButton, recButton);
  
  // NOW you can safely access elements inside it
  const recLed = newRecButton.querySelector('.led-indicator');
  
  // Global state
  let localIsRecording = false;
  let processingLock = false;
  let audioInputStream = null;
  let audioInputNode = null;
  let recordingChunks = [];
  let recorderWorklet = null;
  
  // First, create and register the AudioWorklet processor
  const workletCode = `
  class RecorderWorkletProcessor extends AudioWorkletProcessor {
    constructor() {
      super();
      this.isRecording = false;
      
      // ADD THIS HANDLER - it was completely missing!
      this.port.onmessage = (event) => {
        if (event.data.command === 'setRecording') {
          console.log("RecorderWorklet: Set recording to", event.data.value);
          this.isRecording = event.data.value;
        }
      };
    }
    
    process(inputs, outputs, parameters) {
      if (!this.isRecording || !inputs[0] || !inputs[0][0]) return true;
      
      // Clone the input data to send to main thread
      const inputData = inputs[0][0];
      const buffer = new Float32Array(inputData.length);
      buffer.set(inputData);
      
      // Send buffer to main thread
      this.port.postMessage({ type: 'chunk', data: buffer });
      
      return true;
    }
  }
  
  registerProcessor('recorder-processor', RecorderWorkletProcessor);
`;
  // Create a Blob URL for the worklet code
  const blob = new Blob([workletCode], { type: 'application/javascript' });
  const workletUrl = URL.createObjectURL(blob);
  
  // Register the worklet with the audio context
  let workletReady = false;
  
  audioCtx.audioWorklet.addModule(workletUrl).then(() => {
    workletReady = true;
    console.log("Audio worklet ready for recording");
  }).catch(err => {
    console.error("Error loading audio worklet:", err);
  });
  
  newRecButton.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (processingLock) return;
    processingLock = true;
    setTimeout(() => { processingLock = false; }, 300);
    
    if (localIsRecording) {
      stopRecording();
    } else {
      startRecording();
    }
  });
  
  async function startRecording() {
    try {
      if (!workletReady) {
        console.error("Audio worklet not ready yet");
        return;
      }
      
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Update UI
      newRecButton.classList.add('recording');
      if (recLed) recLed.classList.add('on');
      localIsRecording = true;
      
      // Reset recording chunks
      recordingChunks = [];
      
      // Create audio input source
      audioInputStream = stream;
      audioInputNode = audioCtx.createMediaStreamSource(stream);
      
      // Create and connect the AudioWorkletNode for recording
      recorderWorklet = new AudioWorkletNode(audioCtx, 'recorder-processor');
      
      // Set up message handling to collect audio chunks
      recorderWorklet.port.onmessage = (event) => {
        if (event.data.type === 'chunk') {
          recordingChunks.push(event.data.data);
        }
      };
      
      // Tell the worklet to start recording
      recorderWorklet.port.postMessage({ command: 'setRecording', value: true });
      
      // Connect the nodes
      audioInputNode.connect(recorderWorklet);
      recorderWorklet.connect(audioCtx.destination);
      
      console.log("Recording started with AudioWorkletNode");
    } catch (err) {
      console.error("Error starting recording:", err);
    }
  }
  
  function stopRecording() {
    
    // Clean up BEFORE updating UI
    if (audioInputStream) {
      try {
        audioInputStream.getTracks().forEach(track => track.stop());
      } catch(e) {
        console.error("Error stopping tracks:", e);
      }
    }
    
    // Handle each node individually
    if (audioInputNode) {
      try {
        audioInputNode.disconnect();
      } catch(e) {
        console.error("Error disconnecting input node:", e);
      }
    }
    
    if (recorderWorklet) {
      try {
        // Tell the worklet to stop recording
        recorderWorklet.port.postMessage({ command: 'setRecording', value: false });
        recorderWorklet.disconnect();
      } catch(e) {
        console.error("Error disconnecting recorder worklet:", e);
      }
    }
    
    // NOW update UI
    newRecButton.classList.remove('recording');
    if (recLed) recLed.classList.remove('on');
    localIsRecording = false;
    
    // Process the recording chunks if we have any
    if (recordingChunks && recordingChunks.length > 0) {
      processRecording(recordingChunks);
    }
  }

  function processRecording(chunks) {
  console.log("Processing recorded audio...");

  // 1) Build one buffer from the recorded chunks
  let totalLength = 0;
  for (let i = 0; i < chunks.length; i++) {
    totalLength += chunks[i].length;
  }
  const newBuffer = audioCtx.createBuffer(1, totalLength, audioCtx.sampleRate);
  const channelData = newBuffer.getChannelData(0);
  let offset = 0;
  for (let i = 0; i < chunks.length; i++) {
    channelData.set(chunks[i], offset);
    offset += chunks[i].length;
  }

  // 2) Use the same global audioBuffer
  audioBuffer = newBuffer; 
  console.log("Recording loaded as sample with duration:", audioBuffer.duration);

  // 3) Process fades and crossfades using the same function
  updateSampleProcessing();

  // 4) Reset crossfade data to match loadPresetSample approach
  cachedCrossfadedBuffer = null;
  lastCachedStartPos = null;
  lastCachedEndPos = null;
  lastCachedCrossfade = null;

  // 5) Create and connect a new source node, just like in loadPresetSample
  if (sampleSource) {
    sampleSource.stop();
  }
  sampleSource = audioCtx.createBufferSource();
  sampleSource.buffer = audioBuffer;
  sampleSource.connect(sampleGainNode);
  sampleSource.start();

  // 6) Set UI label (equivalent to showing loaded sample name)
  const fileLabel = document.querySelector('label[for="audio-file"]');
  if (fileLabel) {
    fileLabel.textContent = 'Recording (mic)';
  }

  // 7) Create crossfaded buffer if needed
  if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
    console.log("Creating crossfaded buffer for recorded sample");
    const result = createCrossfadedBuffer(
      audioBuffer,
      sampleStartPosition,
      sampleEndPosition,
      sampleCrossfadeAmount
    );
    if (result && result.buffer) {
      console.log("Successfully created crossfaded buffer for recorded sample");
      cachedCrossfadedBuffer = result.buffer;
      lastCachedStartPos = sampleStartPosition;
      lastCachedEndPos = sampleEndPosition;
      lastCachedCrossfade = sampleCrossfadeAmount;
    }
  }

  // 8) Update any active notes to use the new buffer, same as loadPresetSample
  Object.values(activeNotes).forEach(note => {
    if (note && note.source) {
      // Skip held notes
      if (heldNotes.includes(note.noteNumber)) {
        console.log(`Note ${note.id} is held; will update on release.`);
        return;
      }
      console.log(`Updating note ${note.id} to use recorded sample`);
      note.usesProcessedBuffer = false;
      note.crossfadeActive = false;
      if (isSampleLoopOn) {
        note.looping = true;
        setupLoopCrossfade(note);
      }
      updateSamplePlaybackParameters(note);
    }
  });
}
}
function preventScrollOnControls() {
  // More targeted approach - add touch event handlers to each UI control type individually
  
  
  
  // 2. Fix sliders
  document.querySelectorAll('input[type="range"]').forEach(slider => {
    slider.addEventListener('touchstart', function(e) {
      // Don't prevent default on sliders to allow native handling
    }, { passive: false });
  });
  

  
  // 4. Fix oscillator selectors (wave-select)
  document.querySelectorAll('.wave-select').forEach(select => {
    select.addEventListener('touchstart', function(e) {
      // Allow default behavior for selects
    }, { passive: true });
  });
  
  // 5. Fix special buttons (emu mode and rec button)
  document.querySelectorAll('.lofi-button, .rec-button').forEach(button => {
    button.addEventListener('touchstart', function(e) {
      e.preventDefault();
      // Simulate a click
      button.click();
    }, { passive: false });
  });
  
  
}
/**
 * Creates a properly loopable buffer with crossfades baked in.
 */

 function createCrossfadedBuffer(originalBuffer, startFraction, endFraction, crossfadeAmount) {
  try {
    // Basic parameter checks
    if (!originalBuffer || originalBuffer.length === 0) {
      console.log("No buffer provided or empty buffer");
      return null;
    }
    
    if (crossfadeAmount <= 0.00001) {
      console.log("Crossfade amount too small");
      return null;
    }
    
    // IMPORTANT: Use the original buffer for consistency 
    // This ensures the lead-in audio matches the main loop content
    const sourceBuffer = originalBuffer; 
    const sampleRate = sourceBuffer.sampleRate;
    const channels = sourceBuffer.numberOfChannels;
    const totalSamples = sourceBuffer.length;
    const channel0Data = sourceBuffer.getChannelData(0);
    
    // Calculate sample indices and loop length
    let startSamplePos = Math.floor(startFraction * totalSamples);
    const endSamplePos = Math.floor(endFraction * totalSamples);
    let loopLength = endSamplePos - startSamplePos;
    
    // Check for minimum viable loop length
    const minimumSamples = Math.max(100, Math.floor(totalSamples * 0.001));
    if (loopLength < minimumSamples) {
      console.log(`Loop length (${loopLength} samples) is too short for crossfading. Minimum: ${minimumSamples}`);
      return { buffer: fadedBuffer || originalBuffer, adjustedStartFraction: startFraction };
    }
    
    // For very small crossfades (<20%), we just use zero-crossing alignment without crossfade
    if (crossfadeAmount < 0.20) {
      console.log("Using pure zero-crossing alignment for small crossfade");
      
      // Zero crossing detection code (unchanged)
      const searchWindowSamples = Math.ceil(sampleRate * 0.01);
      const startCrossings = [];
      const startMin = Math.max(0, startSamplePos - searchWindowSamples);
      const startMax = Math.min(totalSamples - 2, startSamplePos + searchWindowSamples);
      
      for (let i = startMin; i < startMax; i++) {
        if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
          startCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'rising'
          });
        }
        else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
          startCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'falling'
          });
        }
      }
      
      const endCrossings = [];
      const endMin = Math.max(0, endSamplePos - searchWindowSamples);
      const endMax = Math.min(totalSamples - 2, endSamplePos + searchWindowSamples);
      
      for (let i = endMin; i < endMax; i++) {
        if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
          endCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'rising'
          });
        }
        else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
          endCrossings.push({
            index: i,
            slope: channel0Data[i + 1] - channel0Data[i],
            type: 'falling'
          });
        }
      }
      
      console.log(`Found ${startCrossings.length} start and ${endCrossings.length} end zero crossings`);
      
      if (startCrossings.length > 0 && endCrossings.length > 0) {
        let bestMatch = { score: -Infinity, start: startSamplePos, end: endSamplePos };
        
        for (const start of startCrossings) {
          for (const end of endCrossings) {
            const typeScore = (start.type === end.type) ? 5 : -2;
            const slopeScore = 5 - Math.min(5, Math.abs(start.slope - end.slope) * 20);
            const distanceScore = 3 - Math.min(3, 
              (Math.abs(start.index - startSamplePos) + 
               Math.abs(end.index - endSamplePos)) / (searchWindowSamples * 2) * 3);
            
            const score = typeScore + slopeScore + distanceScore;
            
            if (score > bestMatch.score) {
              bestMatch = {
                score,
                start: start.index,
                end: end.index
              };
            }
          }
        }
        
        if (bestMatch.score > 0) {
          console.log(`Using zero crossings: start=${bestMatch.start}, end=${bestMatch.end}, score=${bestMatch.score.toFixed(2)}`);
          startSamplePos = bestMatch.start;
          endSamplePos = bestMatch.end;
          loopLength = endSamplePos - startSamplePos;
        }
      }
      
      const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
      
      for (let channel = 0; channel < channels; channel++) {
        const origData = sourceBuffer.getChannelData(channel);
        const newData = newBuffer.getChannelData(channel);
        
        for (let i = 0; i < loopLength; i++) {
          newData[i] = origData[startSamplePos + i];
        }
      }
      
      return { buffer: newBuffer, adjustedStartFraction: startSamplePos / totalSamples };
    }
    
    // For larger crossfades (≥20%), implement a robust crossfade with phase alignment
    console.log("Using enhanced phase-aligned crossfade for larger fade amount");

    // IMPROVED CROSSFADE LENGTH CALCULATION
    // This is a critical part for consistent results
    const minFadeSamples = Math.max(Math.round(sampleRate * 0.015), 100); // minimum 15ms fade
    const maxFadeSamples = Math.floor(loopLength * 0.4); // maximum 40% of loop length

    // Calculate fade length based on crossfade amount with better scaling
    let fadeLengthSamples;
    if (crossfadeAmount >= 0.95) {
      // Near 100% - use most of the available loop length
      fadeLengthSamples = maxFadeSamples;
    } else if (crossfadeAmount < 0.3) {
      // Small crossfades (20-30%) - use fixed duration
      fadeLengthSamples = Math.max(minFadeSamples, Math.round(sampleRate * 0.035)); // 35ms minimum
    } else {
      // Mid-range crossfades - use balanced approach with cubic easing
      // This easing function provides smoother scaling across percentage ranges
      const t = crossfadeAmount;
      const easedT = t * t * (3 - 2 * t); // Smooth step function
      fadeLengthSamples = Math.floor(minFadeSamples + (maxFadeSamples - minFadeSamples) * easedT);
    }

    console.log(`Fade length: ${fadeLengthSamples} samples (${fadeLengthSamples/sampleRate}s), ${(fadeLengthSamples/loopLength*100).toFixed(1)}% of loop`);
    
    // Ensure we have enough samples before start for lead-in
    if (startSamplePos < fadeLengthSamples) {
      startSamplePos = fadeLengthSamples;
      loopLength = endSamplePos - startSamplePos;
    }
    
    // ENHANCED CROSSFADE REGION ANALYSIS
    // Find the best matching lead-in segment with multiple criteria
    
    // First analyze the crossfade region characteristics
    const crossfadeStartPos = endSamplePos - fadeLengthSamples;
    
    // Multiple analysis points for better matching - analyze the ENTIRE crossfade region
    const analysisPoints = 5; // Sample 5 points across the crossfade region
    const crossfadeCharacteristics = [];
    
    for (let i = 0; i < analysisPoints; i++) {
      const position = crossfadeStartPos + Math.floor(i * fadeLengthSamples / (analysisPoints - 1));
      
      // Detect zero-crossing near this position
      let crossType = null;
      let isRising = false;
      
      // Check 3 samples before and after
      for (let j = -3; j <= 2; j++) {
        const idx = Math.max(0, Math.min(position + j, totalSamples - 2));
        if (channel0Data[idx] <= 0 && channel0Data[idx + 1] > 0) {
          crossType = 'rising';
          isRising = true;
          break;
        } else if (channel0Data[idx] >= 0 && channel0Data[idx + 1] < 0) {
          crossType = 'falling';
          isRising = false;
          break;
        }
      }
      
      // If no zero crossing, analyze slope and polarity
      if (!crossType) {
        const p0 = channel0Data[Math.max(0, position - 3)];
        const p1 = channel0Data[position];
        const p2 = channel0Data[Math.min(totalSamples - 1, position + 3)];
        
        isRising = (p2 > p0);
        crossType = p1 >= 0 ? 'positive' : 'negative';
      }
      
      // Calculate local amplitude
      const amplitude = Math.abs(channel0Data[position]);
      
      // Calculate local frequency using zero-crossing rate
      let localFreq = 0;
      const freqWindow = 20;
      let crossings = 0;
      
      for (let j = Math.max(0, position - freqWindow); j < Math.min(totalSamples - 1, position + freqWindow); j++) {
        if ((channel0Data[j] <= 0 && channel0Data[j + 1] > 0) || 
            (channel0Data[j] >= 0 && channel0Data[j + 1] < 0)) {
          crossings++;
        }
      }
      
      localFreq = crossings / (freqWindow * 2);
      
      // Store the characteristics at this point
      crossfadeCharacteristics.push({
        position,
        crossType,
        isRising,
        amplitude,
        localFreq
      });
    }
    
    // Now find the best matching lead-in section
    const searchWindow = Math.min(Math.floor(sampleRate * 0.1), Math.floor(loopLength * 0.3)); // 100ms or 30% of loop
    const searchStartPoint = startSamplePos - fadeLengthSamples;
    let bestLeadInPos = searchStartPoint;
    let bestScore = -1000;
    
    // Try different potential lead-in positions and score them
    for (let offset = -searchWindow; offset <= searchWindow; offset += 5) { // Step by 5 samples for efficiency
      const testPos = searchStartPoint + offset;
      if (testPos < 0 || testPos + fadeLengthSamples >= crossfadeStartPos) {
        continue;
      }
      
      let totalScore = 0;
      
      // Score based on matching the characteristics at each analysis point
      for (let i = 0; i < analysisPoints; i++) {
        const targetChar = crossfadeCharacteristics[i];
        const relativePos = Math.floor(i * fadeLengthSamples / (analysisPoints - 1));
        const testSamplePos = testPos + relativePos;
        
        let pointScore = 0;
        
        // Check for matching zero crossing type
        let testCrossType = null;
        let testIsRising = false;
        
        // Look for zero crossing near this test position
        for (let j = -3; j <= 2; j++) {
          const idx = Math.max(0, Math.min(testSamplePos + j, totalSamples - 2));
          if (channel0Data[idx] <= 0 && channel0Data[idx + 1] > 0) {
            testCrossType = 'rising';
            testIsRising = true;
            break;
          } else if (channel0Data[idx] >= 0 && channel0Data[idx + 1] < 0) {
            testCrossType = 'falling';
            testIsRising = false;
            break;
          }
        }
        
        if (!testCrossType) {
          const p0 = channel0Data[Math.max(0, testSamplePos - 3)];
          const p1 = channel0Data[testSamplePos];
          const p2 = channel0Data[Math.min(totalSamples - 1, testSamplePos + 3)];
          
          testIsRising = (p2 > p0);
          testCrossType = p1 >= 0 ? 'positive' : 'negative';
        }
        
        // Score matching characteristics
        if (testCrossType === targetChar.crossType) {
          pointScore += 30;
        }
        
        if (testIsRising === targetChar.isRising) {
          pointScore += 20;
        }
        
        // Calculate amplitude similarity
        const testAmplitude = Math.abs(channel0Data[testSamplePos]);
        const ampDiff = Math.abs(targetChar.amplitude - testAmplitude);
        pointScore += 20 - Math.min(20, ampDiff * 40);
        
        // Calculate local frequency
        let testCrossings = 0;
        const freqWindow = 20;
        
        for (let j = Math.max(0, testSamplePos - freqWindow); j < Math.min(totalSamples - 1, testSamplePos + freqWindow); j++) {
          if ((channel0Data[j] <= 0 && channel0Data[j + 1] > 0) || 
              (channel0Data[j] >= 0 && channel0Data[j + 1] < 0)) {
            testCrossings++;
          }
        }
        
        const testLocalFreq = testCrossings / (freqWindow * 2);
        const freqDiff = Math.abs(targetChar.localFreq - testLocalFreq);
        pointScore += 20 - Math.min(20, freqDiff * 100);
        
        // Add to total score (weight later points slightly more)
        totalScore += pointScore * (0.8 + 0.2 * i / analysisPoints);
      }
      
      // Additional score for proximity to original position
      totalScore += 50 - Math.min(50, Math.abs(offset) / searchWindow * 50);
      
      // Check for best score
      if (totalScore > bestScore) {
        bestScore = totalScore;
        bestLeadInPos = testPos;
      }
    }
    
    console.log(`Selected lead-in position: ${bestLeadInPos}, score: ${bestScore.toFixed(1)}`);
    
    // FINE-TUNE THE LEAD-IN POSITION FOR PRECISE PHASE ALIGNMENT
    // Once we have the approximate best position, do a fine-grained search for perfect phase alignment
    let fineTunedLeadIn = bestLeadInPos;
    let fineTuneScore = -1000;
    
    for (let fineOffset = -10; fineOffset <= 10; fineOffset++) {
      const testPos = bestLeadInPos + fineOffset;
      if (testPos < 0) continue;
      
      // Focus on precise alignment at the start of crossfade region
      const endPhase = channel0Data[crossfadeStartPos];
      const endSlope = channel0Data[crossfadeStartPos + 1] - channel0Data[crossfadeStartPos];
      
      const testPhase = channel0Data[testPos];
      const testSlope = channel0Data[testPos + 1] - channel0Data[testPos];
      
      // Score based on phase alignment and slope matching
      const phaseScore = 50 - Math.min(50, Math.abs(endPhase - testPhase) * 100);
      const slopeScore = 50 - Math.min(50, Math.abs(endSlope - testSlope) * 200);
      
      const score = phaseScore + slopeScore;
      
      if (score > fineTuneScore) {
        fineTuneScore = score;
        fineTunedLeadIn = testPos;
      }
    }
    
    console.log(`Fine-tuned lead-in position: ${fineTunedLeadIn}, improvement: ${(fineTuneScore/100).toFixed(1)}`);
    
    // Create the final buffer with the best phase alignment
    const adjustedStart = startSamplePos;
    const fadeInStart = fineTunedLeadIn;
    
    const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
    
    // Apply improved crossfade technique
    for (let channel = 0; channel < channels; channel++) {
      const origData = sourceBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      // First copy the main loop content
      for (let i = 0; i < loopLength; i++) {
        newData[i] = origData[adjustedStart + i];
      }
      
      // APPLY ENHANCED EQUAL-POWER CROSSFADE CURVE
      // This is critical for eliminating clicks and glitches
      for (let i = 0; i < fadeLengthSamples; i++) {
        const idx = loopLength - fadeLengthSamples + i;
        if (idx >= 0) {
          // Use optimized crossfade ratio with slight modification to ensure 
          // the fade out goes completely to zero at the midpoint
          const ratio = i / fadeLengthSamples;
          
          // Equal power crossfade curve (quarter-circle) provides the smoothest transition
          // Apply a very slight bias (0.02) to ensure the fadeOut curve reaches complete zero
          const fadeOutFactor = Math.cos(ratio * Math.PI/2) - Math.max(0, 0.02 - ratio * 0.04);
          const fadeInFactor = Math.sin(ratio * Math.PI/2);
          
          const loopEndSample = newData[idx];
          const leadInSample = origData[fadeInStart + i];
          
          // Apply the crossfade with perfect phase alignment
          newData[idx] = (loopEndSample * fadeOutFactor) + (leadInSample * fadeInFactor);
        }
      }
      
      // Apply a tiny smoothing at the loop transition point to eliminate any remaining discontinuities
      const smoothSamples = Math.min(24, Math.ceil(sampleRate * 0.0005)); // 0.5ms or 24 samples, whichever is smaller
      
      // Smooth the transition at the very end of the buffer (loop point)
      for (let i = 1; i <= smoothSamples; i++) {
        const idx = loopLength - i;
        if (idx >= 0 && idx < loopLength - 1) {
          const weight = i / smoothSamples;
          newData[idx] = newData[idx] * (1 - weight * 0.1) + newData[idx + 1] * (weight * 0.1);
        }
      }
    }
    
    console.log(`Created enhanced crossfaded buffer: ${(loopLength / sampleRate).toFixed(3)}s loop`);
    return { buffer: newBuffer, adjustedStartFraction: adjustedStart / totalSamples };
    
  } catch (e) {
    console.error("Error creating crossfaded buffer:", e);
    return { buffer: fadedBuffer || originalBuffer, adjustedStartFraction: startFraction };
  }
}
// Knob initializations (only one set)
const knobInitializations = {
      
    'osc1-pwm-knob': (value) => {
        const tooltip = createTooltipForKnob('osc1-pwm-knob', value);
        tooltip.textContent = `PWM: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        console.log('OSC1 PWM:', value.toFixed(2));
    },
    'osc1-gain-knob': (value) => {
        const tooltip = createTooltipForKnob('osc1-gain-knob', value);
        tooltip.textContent = `Gain: ${value.toFixed(2)}`;
        tooltip.style.opacity = '1';
        console.log('OSC1 Gain:', value.toFixed(2));
    },
    'osc2-pwm-knob': (value) => {
        const tooltip = createTooltipForKnob('osc2-pwm-knob', value);
        tooltip.textContent = `PWM: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        console.log('OSC2 PWM:', value.toFixed(2));
    },
    'osc2-gain-knob': (value) => {
        const tooltip = createTooltipForKnob('osc2-gain-knob', value);
        tooltip.textContent = `Gain: ${value.toFixed(2)}`;
        tooltip.style.opacity = '1';
        console.log('OSC2 Gain:', value.toFixed(2));
    },
    'master-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('master-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        masterGain.gain.setTargetAtTime(value, audioCtx.currentTime, 0.01);
        console.log('Master Volume:', value.toFixed(2));
    },
    'sample-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('sample-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        currentSampleGain = value;
        // Update all active notes' sample gain
        Object.values(activeNotes).forEach(note => {
            if (note && note.sampleNode) {
                note.sampleNode.gain.value = currentSampleGain;
            }
        });
        console.log('Sample Gain:', value.toFixed(2));
    },
    // ... existing knobs ...
    'sample-pitch-knob': (value) => {
        // Convert 0-1 range to -1200 to +1200 cents
        currentSampleDetune = (value * 2400) - 1200;
    
    // Show and update tooltip
    const tooltip = document.getElementById('pitch-tooltip') || createTooltip();
    tooltip.textContent = `${currentSampleDetune.toFixed(0)} cents`;
    tooltip.style.opacity = '1';
    
    // Update all active notes' sample pitch
    Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
            note.source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
        }
    });
    
    console.log('Sample Pitch:', currentSampleDetune.toFixed(0) + ' cents');
},

// Add these new knob initializations in the knobInitializations object
'sample-start-knob': (value) => {
    // Ensure start position is always less than end position
    const maxStart = Math.min(value, sampleEndPosition - 0.01);
    sampleStartPosition = maxStart;
    
    // Update processing with new start position
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-start-knob', value);
    tooltip.textContent = `Start: ${(sampleStartPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample Start:', (sampleStartPosition * 100).toFixed(0) + '%');
    
    // Instead of direct creation, ensure we wait for updateSampleProcessing to finish
    if (startUpdateTimer) { clearTimeout(startUpdateTimer); }
    startUpdateTimer = setTimeout(() => {
        if (audioBuffer && sampleCrossfadeAmount > 0.01 && isSampleLoopOn) {
            console.log("Creating new crossfaded buffer after start position settled");
            // Use the processed buffer that includes fades
            const result = createCrossfadedBuffer(
                fadedBuffer || audioBuffer, 
                0,   // Use entire processed buffer 
                1,   // Use entire processed buffer
                sampleCrossfadeAmount
            );
            
            if (result && result.buffer) {
                cachedCrossfadedBuffer = result.buffer;
                lastCachedStartPos = sampleStartPosition;
                lastCachedEndPos = sampleEndPosition;
                lastCachedCrossfade = sampleCrossfadeAmount;
            }
        }
        
        // Update any active notes
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping start update.`);
                    return;
                }
                
                // Force re-processing
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                if (isSampleLoopOn) {
                    note.looping = true;
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        startUpdateTimer = null;
    }, 150);  // Longer delay to ensure processing completes
},

'sample-end-knob': (value) => {
    // Ensure end position is always greater than start position
    const minEnd = Math.max(value, sampleStartPosition + 0.01);
    sampleEndPosition = minEnd;
    
    // Add this line to process fades when end position changes
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-end-knob', value);
    tooltip.textContent = `End: ${(sampleEndPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample End:', (sampleEndPosition * 100).toFixed(0) + '%');
    
    // Instead of direct creation, ensure we wait for updateSampleProcessing to finish
    if (endUpdateTimer) { clearTimeout(endUpdateTimer); }
    endUpdateTimer = setTimeout(() => {
        if (audioBuffer && sampleCrossfadeAmount > 0.01 && isSampleLoopOn) {
            console.log("Creating new crossfaded buffer after end position settled");
            // Use the processed buffer that includes fades
            const result = createCrossfadedBuffer(
                fadedBuffer || audioBuffer, 
                0,   // Use entire processed buffer 
                1,   // Use entire processed buffer
                sampleCrossfadeAmount
            );
            
            if (result && result.buffer) {
                cachedCrossfadedBuffer = result.buffer;
                lastCachedStartPos = sampleStartPosition;
                lastCachedEndPos = sampleEndPosition;
                lastCachedCrossfade = sampleCrossfadeAmount;
            }
        }
        
        // Update any active notes
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping end update.`);
                    return;
                }
                
                // Force re-processing
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                if (isSampleLoopOn) {
                    note.looping = true;
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        endUpdateTimer = null;
    }, 150);  // Longer delay to ensure processing completes
},
'sample-crossfade-knob': (value) => {
    const tooltip = createTooltipForKnob('sample-crossfade-knob', value);
    tooltip.textContent = `Crossfade: ${(value * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    // Store previous values
    const prevCrossfade = sampleCrossfadeAmount;
    const prevLoopState = isSampleLoopOn;
    
    // Update values
    sampleCrossfadeAmount = value;
    isSampleLoopOn = value > 0.01;
    
    // If enabling crossfade, clear any existing fades
    if (value > 0.01) {
        // Reset fade values when enabling crossfade
        sampleFadeInAmount = 0;
        sampleFadeOutAmount = 0;
        
        // Update the fade knob position to center (no fade)
        const fadeKnob = D('sample-fade-knob');
        if (fadeKnob) {
            const control = initializeKnob(fadeKnob, knobInitializations['sample-fade-knob']);
            control.setValue(0.5);
        }
    }
    
    // CRITICAL FIX: When crossfade amount changes significantly, recalculate zero-crossing alignment
    if (Math.abs(prevCrossfade - value) > 0.02 || prevLoopState !== isSampleLoopOn) {
        console.log("Crossfade changed significantly - recalculating zero crossings");
        
        if (audioBuffer) {
            // Similar to what happens in updateSampleProcessing but just for zero crossing
            const totalSamples = audioBuffer.length;
            const rawStartSample = Math.floor(sampleStartPosition * totalSamples);
            const rawEndSample = Math.floor(sampleEndPosition * totalSamples);
            
            // Find zero-crossings near the start and end points
            const alignedPoints = findBestZeroCrossings(
                audioBuffer, 
                rawStartSample, 
                rawEndSample
            );
            
            // Update the start and end positions with aligned zero crossings
            sampleStartPosition = alignedPoints.start / totalSamples;
            sampleEndPosition = alignedPoints.end / totalSamples;
            
            console.log(`Zero-crossings recalculated: start=${sampleStartPosition.toFixed(4)}, end=${sampleEndPosition.toFixed(4)}`);
            
            // // Update knob positions to reflect new values
            // const startKnob = D('sample-start-knob');
            // const endKnob = D('sample-end-knob');
            
            // if (startKnob) {
            //     const control = initializeKnob(startKnob, knobInitializations['sample-start-knob']);
            //     control.setValue(sampleStartPosition);
            // }
            
            // if (endKnob) {
            //     const control = initializeKnob(endKnob, knobInitializations['sample-end-knob']);
            //     control.setValue(sampleEndPosition);
            // }
        }
    }
    
    // Process with any updated settings
    updateSampleProcessing();

    // Regular debounced update
    if (crossfadeUpdateTimer) { clearTimeout(crossfadeUpdateTimer); }
    crossfadeUpdateTimer = setTimeout(() => {
        console.log("CROSSFADE UPDATE TIMER FIRED with", Object.keys(activeNotes).length, "active notes");
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                console.log(`Processing note ${note.id}, held: ${heldNotes.includes(note.noteNumber)}`);
                // Skip held notes
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping crossfade update.`);
                    return;
                }
                
                console.log(`Forcing re-processing for note ${note.id}`);
                // Force re-processing - important!
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                // This is crucial: first create the crossfaded buffer, then update the note
                if (isSampleLoopOn) {
                    note.looping = true; // Force looping flag to true!
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        crossfadeUpdateTimer = null;
    }, 100);
},
'sample-fade-knob': (value) => {
    // Convert 0-1 range to -0.5 to 0.5 range
    const fadeValue = value * 2 - 1;
    
    // Create tooltip
    const tooltip = createTooltipForKnob('sample-fade-knob', value);
    
    // If crossfade/loop is on, disable fade functionality completely
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        tooltip.textContent = `Fade (disabled)`;
        tooltip.style.opacity = '1';
        console.log("Fade knob ignored - crossfade is active");
        return; // Exit early - don't process fades when crossfade is active
    }
    
    // Different text based on direction
    if (fadeValue < 0) {
        // Fade out (left side)
        const fadeOutPercent = Math.abs(fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade Out: ${fadeOutPercent}%`;
        console.log(`Setting fade OUT to ${fadeOutPercent}%`);
    } else if (fadeValue > 0) {
        // Fade in (right side)
        const fadeInPercent = (fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade In: ${fadeInPercent}%`;
        console.log(`Setting fade IN to ${fadeInPercent}%`);
    } else {
        // Center position
        tooltip.textContent = `No Fade`;
        console.log("Resetting fades to 0");
    }
    tooltip.style.opacity = '1';
    
    // Store values for processing
    sampleFadeInAmount = Math.max(0, fadeValue);
    sampleFadeOutAmount = Math.abs(Math.min(0, fadeValue));
    
    console.log(`Fade control values: fadeIn=${sampleFadeInAmount.toFixed(2)}, fadeOut=${sampleFadeOutAmount.toFixed(2)}`);
    
    // Process the fade changes
    updateSampleProcessing();
},
'glide-time-knob': (value) => {
    const tooltip = createTooltipForKnob('glide-time-knob', value);
    tooltip.textContent = `${(value * 2000).toFixed(0)}ms`;
    tooltip.style.opacity = '1';
    glideTime = value * 2; // 0-2 seconds range
    console.log('Glide Time:', (value * 2000).toFixed(0) + 'ms');
},
};
/**
 * Updates existing note playback parameters.
 * For crossfaded loops, if not already using the processed buffer,
 * this will create a new note and fade out the old one.
 */
 function updateSamplePlaybackParameters(note) {
  if (!note || !audioBuffer) return note;
  if (note.isBeingUpdated) return note;
  if (note.state === "releasing") {
    console.log("updateSamplePlaybackParameters: Note", note.id, "is releasing; skipping update.");
    return note;
  }
  note.isBeingUpdated = true;
  
  // Reset flags to force new settings to take hold
  note.crossfadeActive = false;
  note.usesProcessedBuffer = false;
  
  try {
    if (sampleCrossfadeAmount > 0.01) {
      console.log("updateSamplePlaybackParameters: Creating replacement note with crossfade for note", note.id);
      const replacementNote = createNote(
        note.noteNumber,
        audioBuffer,
        audioCtx,
        masterGain
      );
      if (replacementNote) {
        replacementNote.gainNode.gain.value = note.gainNode.gain.value;
        quickFadeOut(note, 0.03);
        note = replacementNote;
        console.log("updateSamplePlaybackParameters: Replaced note", note.id, "with crossfaded version");
      }
    } else {
      if (note.source && note.looping) {
        note.source.loop = isSampleLoopOn;
        note.source.loopStart = sampleStartPosition * audioBuffer.duration;
        note.source.loopEnd = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: Updated loop points for note", note.id);
      }
      if (
        !note.looping ||
        Math.abs(note.sampleStartPosition - sampleStartPosition * audioBuffer.duration) > 0.01
      ) {
        console.log("updateSamplePlaybackParameters: Creating new source for note", note.id);
        const newSource = audioCtx.createBufferSource();
        newSource.buffer = audioBuffer;
        newSource.loop = isSampleLoopOn;
        newSource.playbackRate.value = note.source.playbackRate.value;
        newSource.detune.value = currentSampleDetune;
        if (isSampleLoopOn) {
          newSource.loopStart = sampleStartPosition * audioBuffer.duration;
          newSource.loopEnd = sampleEndPosition * audioBuffer.duration;
        }
        note.source.disconnect();
        newSource.connect(note.sampleNode);
        newSource.start(0, sampleStartPosition * audioBuffer.duration);
        setTimeout(() => { 
          try { note.source.stop(); } catch (e) {} 
        }, 30);
        note.source = newSource;
        note.sampleStartPosition = sampleStartPosition * audioBuffer.duration;
        note.sampleEndPosition = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: New source set for note", note.id);
      }
    }
  } finally {
    note.isBeingUpdated = false;
  }
  return note;
}
// Replace the entire createNote function with this fixed version
function createNote(noteNumber, buffer, audioCtx, destination) {
    const noteId = `${noteNumber}_${Date.now()}`;
    
    // Create gain nodes
    const gainNode = audioCtx.createGain();
    const sampleNode = audioCtx.createGain();
    gainNode.gain.value = 0.5;
    sampleNode.gain.value = currentSampleGain;
    
    const source = audioCtx.createBufferSource();
    
    // IMPORTANT: Select the correct buffer to use
    let useOriginalBuffer = true;
    let sourceBuffer = buffer; // Default to original buffer
    
    // If we have a crossfaded buffer and looping is on, use that
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01 && cachedCrossfadedBuffer) {
        sourceBuffer = cachedCrossfadedBuffer;
        useOriginalBuffer = false;
        console.log("Creating note using crossfaded buffer");
    } 
    // If we have a faded buffer and crossfade is not active, use the faded buffer
    else if (fadedBuffer && (!isSampleLoopOn || sampleCrossfadeAmount <= 0.01)) {
        sourceBuffer = fadedBuffer;
        useOriginalBuffer = false;
        console.log("Creating note using faded buffer");
    }
    
    // Set the buffer
    source.buffer = sourceBuffer;
    
    // Set playback speed for note pitch
    source.playbackRate.value = TR2 ** (noteNumber - 12);
    source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
    
    // Connect nodes
    source.connect(sampleNode);
    sampleNode.connect(gainNode);
    gainNode.connect(destination);
    
    // Set exact loop points if using original buffer
    if (useOriginalBuffer) {
        if (isSampleLoopOn) {
            source.loop = true;
            source.loopStart = sampleStartPosition * buffer.duration;
            source.loopEnd = sampleEndPosition * buffer.duration;
            console.log(`Setting loop points: ${source.loopStart.toFixed(3)}s to ${source.loopEnd.toFixed(3)}s`);
        }
    } else {
        // For processed buffer, loop the entire thing if looping is on
        source.loop = isSampleLoopOn;
    }
    
    // Create note object
    const note = {
        id: noteId,
        noteNumber,
        source,
        gainNode,
        sampleNode,
        startTime: audioCtx.currentTime,
        state: "starting",
        scheduledEvents: [],
        sampleStartPosition: useOriginalBuffer ? sampleStartPosition * buffer.duration : 0,
        sampleEndPosition: useOriginalBuffer ? sampleEndPosition * buffer.duration : sourceBuffer.duration,
        looping: isSampleLoopOn,
        usesProcessedBuffer: !useOriginalBuffer,
        crossfadeActive: !useOriginalBuffer && isSampleLoopOn && sampleCrossfadeAmount > 0.01
    };
    
    // Start playback
    source.start(0);
    
    if (!isSampleLoopOn) {
        let originalDuration;
        
        // The key fix: When using a processed buffer (faded), we need to use
        // the original duration calculation (from start/end positions on the original buffer),
        // not the already trimmed buffer duration
        if (fadedBuffer && sourceBuffer === fadedBuffer && fadedBufferOriginalDuration) {
            // Use the stored original duration value for faded buffers
            originalDuration = fadedBufferOriginalDuration;
            console.log(`Using stored fadedBufferOriginalDuration: ${originalDuration.toFixed(3)}s`);
        }
        else if (!useOriginalBuffer && sourceBuffer === cachedCrossfadedBuffer) {
            // For crossfaded buffers, use their full duration
            originalDuration = sourceBuffer.duration;
            console.log(`Using crossfaded buffer duration: ${originalDuration.toFixed(3)}s`);
        }
        else {
            // Default calculation based on start/end positions
            originalDuration = (sampleEndPosition - sampleStartPosition) * buffer.duration;
            console.log(`Calculating original duration: ${originalDuration.toFixed(3)}s`);
        }
        
        const now = audioCtx.currentTime;
        sampleNode.gain.setValueAtTime(currentSampleGain, now);
        
        // Apply safety margin
        const safetyMargin = 0.05;
        source.stop(now + originalDuration + safetyMargin);
        
        console.log(`Note scheduled to play for duration: ${originalDuration.toFixed(3)}s + ${safetyMargin}s margin`);
    }
    
    // Store the note
    activeNotes[noteId] = note;
    
    return note;
}
/**
 * Sets up loop crossfade without recursion.
 * (Do not call updateSamplePlaybackParameters or createNote here.)
 */


// Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', () => {
  // Initialize all regular knobs
  Object.entries(knobInitializations).forEach(([id, callback]) => {
    const knob = D(id);
    if (knob) {
      const defaultValue = knobDefaults[id] !== undefined ? knobDefaults[id] : 0.5;
      const control = initializeKnob(knob, callback);
    }
  });

  // Initialize octave knobs
  ['osc1-octave-knob', 'osc2-octave-knob'].forEach(id => {
    const knob = D(id);
    const valueId = id.replace('-knob', '-value');
    if (knob) {
      const control = initializeNotchedKnob(knob, (value) => {
        D(valueId).textContent = value > 0 ? `+${value}` : value;
        console.log(`${id} octave:`, value);
      });
      control.setValue(0);
    }
  });
  
  // Initialize any remaining parameters
  updateSampleProcessing();
});

// Remove any other knob initialization code
        const keyStates = {};
        keys.forEach(key => keyStates[key] = false);
// Add to global variables

const MAX_MONO = 1;
        let audioBuffer = null;
        const MAX_POLYPHONY = 6;
        const activeVoices = []; // FIFO queue of active notes with their key info
        const activeNotes = {}; // Stores active notes
        const playingNotes = [];
        let playingNoteCount = 0;

        // Generate piano keyboard
        function generateKeyboard() {
            
    const keyboard = D('keyboard');
    keyboard.innerHTML = '';
    
    // Create white keys first
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                      'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
    
    for (let i = 0; i < whiteKeys.length; i++) {
        const key = document.createElement('div');
        key.className = 'key';
        // Map to the correct index in the keys array
        const keyIndex = getWhiteKeyIndex(i);
        key.dataset.noteIndex = keyIndex;
        keyboard.appendChild(key);
        
        // Add mouse events
        key.addEventListener('mousedown', () => {
            noteOn(parseInt(key.dataset.noteIndex));
            key.classList.add('pressed');
        });
        
        key.addEventListener('mouseup', () => {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        });
        
        key.addEventListener('mouseleave', () => {
            if (key.classList.contains('pressed')) {
                noteOff(parseInt(key.dataset.noteIndex));
                key.classList.remove('pressed');
            }
        });
    }
  // Add this after your existing initializeKnob function
  function initializeNotchedKnob(knob, onChange) {
    let rotation = 0;
    let isDragging = false;
    let lastY;
    const degreesPerStep = 60;

    function snapToNotch(rotation) {
        const steps = Math.round(rotation / degreesPerStep);
        const limitedSteps = Math.max(-2, Math.min(2, steps));
        return limitedSteps * degreesPerStep;
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        const sensitivity = 1.0; // Increased sensitivity
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        let newRotation = rotation + deltaY;
        newRotation = snapToNotch(newRotation);
        
        if (newRotation !== rotation) {
            rotation = newRotation;
            knob.style.transform = `rotate(${rotation}deg)`;
            
            if (onChange) {
                // Convert rotation to octave value (-2 to +2)
                const octaveValue = Math.round(-rotation / degreesPerStep);
                onChange(octaveValue);
            }
        }
        
        e.preventDefault();
        e.stopPropagation();
    }

    function handleMouseUp() {
        isDragging = false;
        knob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }

    knob.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        knob.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });

    return {
        getValue: () => Math.round(-rotation / degreesPerStep),
        setValue: (octave) => {
            rotation = -octave * degreesPerStep;
            knob.style.transform = `rotate(${rotation}deg)`;
        }
    };
}

// Replace the octave initialization code with this
document.addEventListener('DOMContentLoaded', () => {
    // Initialize octave sliders
    ['osc1', 'osc2'].forEach(id => {
        const slider = document.querySelector(`#${id}-octave-slider`);
        if (slider) {
            slider.addEventListener('input', (e) => {
                console.log(`${id.toUpperCase()} Octave:`, e.target.value);
            });
        }
    });
});
// Update the black keys creation in generateKeyboard
const blackKeys = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // Positions for all black keys

blackKeys.forEach((position) => {
    const key = document.createElement('div');
    key.className = 'key black';
    const keyIndex = getBlackKeyIndex(position);
    key.dataset.noteIndex = keyIndex;
    keyboard.appendChild(key);
    
    // Add mouse events
    key.addEventListener('mousedown', () => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
    });
    
    key.addEventListener('mouseup', () => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
    });
    
    key.addEventListener('mouseleave', () => {
        if (key.classList.contains('pressed')) {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        }
    });
})};

// Helper functions to map key positions to note indices
function getWhiteKeyIndex(position) {
    // Maps white key position to the corresponding index in the keys array
    const whiteKeyMap = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B positions
    const octave = Math.floor(position / 7);
    const noteInOctave = position % 7;
    return whiteKeyMap[noteInOctave] + (octave * 12);
}

function getBlackKeyIndex(position) {
    // Black key mapping for the entire keyboard
    const blackKeyIndices = [
        1,  // C#
        3,  // D#
        6,  // F#
        8,  // G#
        10, // A#
        13, // C# (second octave)
        15, // D# (second octave)
        18, // F# (second octave)
        20, // G# (second octave)
        22  // A# (second octave)
    ];
    
    return blackKeyIndices[position];
}

        // Add interface updating functions
        function updateSliderValues() {
            D('attack-value').textContent = D('attack').value;
            D('decay-value').textContent = D('decay').value;
            D('sustain-value').textContent = D('sustain').value;
            D('release-value').textContent = D('release').value;
            updateADSRVisualization();
        }

        // ADSR visualization
        function updateADSRVisualization() {
            const attack = parseFloat(D('attack').value);
            const decay = parseFloat(D('decay').value);
            const sustain = parseFloat(D('sustain').value);
            const release = parseFloat(D('release').value);
            
            const graph = D('adsr-visualization');
            const totalTime = attack + decay + 2 + release; // 2 seconds for sustain
            const width = graph.offsetWidth;
            const height = graph.offsetHeight;
            
            // Calculate points for ADSR envelope
            const attackX = (attack / totalTime) * width;
            const decayX = attackX + ((decay / totalTime) * width);
            const releaseStartX = decayX + ((2 / totalTime) * width); // 2 seconds sustain
            const releaseEndX = width;
            
            // Create SVG path for visualization
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            
            // Draw ADSR path
            ctx.beginPath();
            ctx.moveTo(0, height); // Start at bottom left
            ctx.lineTo(attackX, 0); // Attack to peak
            ctx.lineTo(decayX, height - (sustain * height)); // Decay to sustain level
            ctx.lineTo(releaseStartX, height - (sustain * height)); // Sustain
            ctx.lineTo(releaseEndX, height); // Release
            ctx.stroke();
            
            // Update visualization
            graph.innerHTML = '';
            graph.appendChild(canvas);
        }
    
        // Update the voice monitoring display
        // Update the voice display function to handle releasing state
// Update the updateVoiceDisplay function
// Update the updateVoiceDisplay function to also update keyboard
function updateVoiceDisplay() {
    const displayEl = D('voice-display');
    displayEl.innerHTML = '';
    
    // Only count and display notes that are in "playing" state
    const playingNotes = Object.values(activeNotes).filter(
        note => note && note.state === "playing"
    );
    
    // Update count first
    const activeNoteCount = Math.min(playingNotes.length, MAX_POLYPHONY);
    D('voice-count').textContent = activeNoteCount;
    
    // Create display items for keyboard keys
    keys.forEach((key, index) => {
        const voiceItem = document.createElement('div');
        voiceItem.className = 'voice-item';
        voiceItem.textContent = key;
        
        // Only show as active if the note is actually playing
        const isPlaying = playingNotes.some(
            note => note.noteNumber === index
        );
        
        if (isPlaying) {
            voiceItem.classList.add('active-voice');
        }
        
        displayEl.appendChild(voiceItem);
    });

    // Update keyboard visual state
    updateKeyboardDisplay();
}

// you're the best <3 and you should put french fries in my car so that my car smells like fries forever :) - from Asher to Faith
        // Add event listeners for sliders
        D('attack').addEventListener('input', updateSliderValues);
        D('decay').addEventListener('input', updateSliderValues);
        D('sustain').addEventListener('input', updateSliderValues);
        D('release').addEventListener('input', updateSliderValues);

        // Update createNote to use unique IDs instead of note numbers as keys
       

       // Update releaseNote to properly handle keyboard display

    function startNote(noteNumber, audioCtx, destination, buffer) {
    // Create new note
    const note = createNote(noteNumber, buffer, audioCtx, destination);
    
    // Apply ADSR envelope
    const attack = parseFloat(D('attack').value);
    const decay = parseFloat(D('decay').value);
    const sustain = parseFloat(D('sustain').value);
    const now = audioCtx.currentTime;
    
    note.gainNode.gain.setValueAtTime(0, now);
    note.gainNode.gain.linearRampToValueAtTime(1, now + attack);
    note.gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    
    note.state = "playing";
    updateVoiceDisplay();
    return note;
}
// Update releaseNote function to use noteId instead of noteNumber
function releaseNote(noteId, audioCtx) {
  const note = activeNotes[noteId];
  if (!note || note.state !== "playing") {
    console.log("releaseNote: Note", noteId, "is not playing. Skipping release.");
    return;
  }
  
  // If the note is using the processed (crossfaded) buffer, disable looping
  if (note.usesProcessedBuffer) {
    note.looping = false;
    console.log("releaseNote: Disabling looping for processed note", noteId);
  }
  
  note.state = "releasing";
  const release = parseFloat(D('release').value);
  const now = audioCtx.currentTime;
  
  note.gainNode.gain.cancelScheduledValues(now);
  const currentGain = note.gainNode.gain.value;
  note.gainNode.gain.setValueAtTime(currentGain, now);
  note.gainNode.gain.linearRampToValueAtTime(0, now + release);
  
  try {
    note.source.stop(now + release + 0.05);
    console.log("releaseNote: Scheduling stop for note", noteId, "at", now + release + 0.05);
  } catch (e) {
    console.log("releaseNote: Error stopping source for note", noteId, e);
  }
  
  const releaseTimer = setTimeout(() => {
    if (note.state === "releasing") {
      killNote(note.id);
      updateVoiceDisplay();
      console.log("releaseNote: Note", noteId, "has been cleaned up.");
    }
  }, (release * 1000) + 100);
  
  note.releaseTimer = releaseTimer;
  note.scheduledEvents.push({ type: "timeout", id: releaseTimer });
  
  updateVoiceDisplay();
}
// Rename existing noteOn/noteOff to these:
// Update handlePolyNoteOn function
// Update handlePolyNoteOn function
function handlePolyNoteOn(noteNumber) {
    if (!heldNotes.includes(noteNumber)) {
    heldNotes.push(noteNumber);
}

// Gather all notes that are still alive (playing or releasing)
let active = Object.values(activeNotes).filter(
    n => n.state === "playing" || n.state === "releasing"
);

// While we are at or above the poly limit,
// kill the oldest note to free a slot
while (active.length >= MAX_POLYPHONY) {
    // Sort oldest first
    active.sort((a, b) => a.startTime - b.startTime);
    const oldest = active[0];

    // Mark it as "fadingOut" so it won't be counted in active[] next loop
    oldest.state = "fadingOut";
    quickFadeOut(oldest, 0.15); // short forced fade

    // Re-check the active list
    active = Object.values(activeNotes).filter(
        n => n.state === "playing" || n.state === "releasing"
    );
}

// Now that we freed up a slot, start the new note
startNewPolyNote(noteNumber);
updateVoiceDisplay();
}
// Helper to start a note with portamento if needed
function startNewPolyNote(noteNumber) {
    if (isPortamentoOn && lastPlayedNote !== null) {
        const note = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        const startRate = TR2 ** (lastPlayedNote - 12);
        const targetRate = TR2 ** (noteNumber - 12);

        note.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
        note.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    } else {
        startNote(noteNumber, audioCtx, masterGain, audioBuffer);
    }
    lastPlayedNote = noteNumber;
}
// Fix handlePolyNoteOff function
function handlePolyNoteOff(noteNumber) {
    // Remove from held notes
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    // Release all instances of this note
    Object.values(activeNotes).forEach(note => {
        if (note.noteNumber === noteNumber && note.state === "playing") {
            releaseNote(note.id, audioCtx);
        }
    });
    updateVoiceDisplay();
}updateVoiceDisplay();


// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
/**
 * Quickly fades out a note and cleans it up.
 * @param {Object} note - The note object to fade out
 * @param {number} fadeTime - Fade time in seconds (default: 0.05)
 * @returns {Object} - The same note for chaining
 */
 function quickFadeOut(note, fadeTime = 0.05) {
  if (!note || !note.gainNode) return note;
  
  // Update state
  note.state = "fadingOut";
  
  try {
    // Get current time and gain value
    const now = audioCtx.currentTime;
    const currentGain = note.gainNode.gain.value;
    
    // Cancel any scheduled values and set current value
    note.gainNode.gain.cancelScheduledValues(now);
    note.gainNode.gain.setValueAtTime(currentGain, now);
    
    // Ramp down to zero
    note.gainNode.gain.linearRampToValueAtTime(0, now + fadeTime);
    
    // Schedule the note to be killed after the fade
    const killTimer = setTimeout(() => {
      killNote(note.id);
    }, fadeTime * 1000 + 10); // Add 10ms buffer
    
    // Register this timeout in the note's scheduled events
    note.scheduledEvents.push({ type: 'timeout', id: killTimer });
  } 
  catch (e) {
    console.error("Error in quickFadeOut:", e);
    killNote(note.id); // Clean up immediately on error
  }
  
  return note;
}
        // Fix the killNote function
        function killNote(noteId) {
    const note = activeNotes[noteId];
    if (!note) return false;

    // Clean up scheduled events
    note.scheduledEvents.forEach(event => {
        if (event.type === "timeout") {
            clearTimeout(event.id);
        }
    });

    // Stop the source and disconnect nodes
    try {
        note.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
        note.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        if (note.source) {
            note.source.stop(audioCtx.currentTime);
        }
    } catch (e) {
        console.log("Error during cleanup:", e);
    }

    // Remove note from active notes
    delete activeNotes[noteId];
    return true;
}

function updateKeyboardDisplay() {
    // Update all keyboard keys based on active notes
    document.querySelectorAll('.key').forEach(keyElement => {
        const noteIndex = parseInt(keyElement.dataset.noteIndex);
        const isNotePlaying = Object.values(activeNotes).some(
            note => note.noteNumber === noteIndex && note.state === "playing"
        );
        
        keyElement.classList.toggle('pressed', isNotePlaying);
    });
}

// Update noteOn to handle polyphony with unique note instances
// Update noteOn to ensure proper mode handling
function noteOn(noteNumber) {
    if (!audioBuffer) {
        console.error("No audio buffer available!");
        return;
    }

    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
    updateKeyboardDisplay();
}

function noteOff(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOff(noteNumber);
    } else {
        handlePolyNoteOff(noteNumber);
    }
    updateKeyboardDisplay();
}

document.onkeydown = function(e) {
  // Stop repeated keydown events
  if (e.repeat) return;

  const upperKey = e.key.toUpperCase();
  console.log("Key pressed:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && !keyStates[upperKey]) {
    console.log("Mapped to note index:", keys.indexOf(upperKey));
    keyStates[upperKey] = true;
    noteOn(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && !keyStates[e.key]) {
    console.log("Special key pressed:", e.key, "=> Note index:", specialKeyMap[e.key]);
    keyStates[e.key] = true;
    noteOn(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

document.onkeyup = function(e) {
  const upperKey = e.key.toUpperCase();
  console.log("Key released:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && keyStates[upperKey]) {
    console.log("Released from array:", upperKey);
    keyStates[upperKey] = false;
    noteOff(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && keyStates[e.key]) {
    console.log("Released special key:", e.key);
    keyStates[e.key] = false;
    noteOff(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

// Update the keyboard generation to use correct note triggering
// Update generateKeyboard to add touch support
function generateKeyboard() {
  const keyboard = D('keyboard');
  keyboard.innerHTML = '';

  // Create white keys first
  const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                    'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
  
  for (let i = 0; i < whiteKeys.length; i++) {
      const key = document.createElement('div');
      key.className = 'key';
      // Map to the correct index in the keys array
      const keyIndex = getWhiteKeyIndex(i);
      key.dataset.noteIndex = keyIndex;
      keyboard.appendChild(key);
      
      // Add mouse events
      key.addEventListener('mousedown', () => {
          noteOn(parseInt(key.dataset.noteIndex));
          key.classList.add('pressed');
      });
      
      key.addEventListener('mouseup', () => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
      });
      
      key.addEventListener('mouseleave', () => {
          if (key.classList.contains('pressed')) {
              noteOff(parseInt(key.dataset.noteIndex));
              key.classList.remove('pressed');
          }
      });
      
      // Add touch events
      key.addEventListener('touchstart', (e) => {
          noteOn(parseInt(key.dataset.noteIndex));
          key.classList.add('pressed');
          e.preventDefault(); // Prevent double-triggering
      }, { passive: false });
      
      key.addEventListener('touchend', (e) => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
          e.preventDefault();
      }, { passive: false });
      
      key.addEventListener('touchcancel', (e) => {
          noteOff(parseInt(key.dataset.noteIndex));
          key.classList.remove('pressed');
          e.preventDefault();
      }, { passive: false });
  }

  // Create black keys
  for (let i = 0; i < 10; i++) { // 5 black keys per octave, 2 octaves
    const key = document.createElement('div');
    key.className = 'key black';
    const keyIndex = getBlackKeyIndex(i);
    key.dataset.noteIndex = keyIndex;
    
    key.addEventListener('mousedown', () => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
    });
    
    key.addEventListener('mouseup', () => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
    });
    
    key.addEventListener('mouseleave', () => {
        if (key.classList.contains('pressed')) {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        }
    });
    
    // Add touch events
    key.addEventListener('touchstart', (e) => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
        e.preventDefault(); // Prevent double-triggering
    }, { passive: false });
    
    key.addEventListener('touchend', (e) => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
        e.preventDefault();
    }, { passive: false });
    
    key.addEventListener('touchcancel', (e) => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
        e.preventDefault();
    }, { passive: false });
    
    keyboard.appendChild(key);
  }
}


function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            audioCtx.decodeAudioData(e.target.result, function(buffer) {
                audioBuffer = buffer;
                
                // Process fades and crossfades whenever a new sample is loaded
                updateSampleProcessing();
                
                // Reset cached crossfade buffer when loading a new sample
                cachedCrossfadedBuffer = null;
                lastCachedStartPos = null;
                lastCachedEndPos = null;
                lastCachedCrossfade = null;
                
                // Create new source node
                if (sampleSource) {
                    sampleSource.stop();
                }
                sampleSource = audioCtx.createBufferSource();
                sampleSource.buffer = buffer;
                
                // Connect the audio chain
                sampleSource.connect(sampleGainNode);
                sampleSource.start();
                
                // Update the label text to show the file name
                const fileLabel = document.querySelector('label[for="audio-file"]');
                if (fileLabel) {
                    // Truncate filename if too long
                    const maxLength = 12;
                    const displayName = file.name.length > maxLength ? 
                        file.name.substring(0, maxLength-3) + '...' : 
                        file.name;
                    fileLabel.textContent = displayName;
                }
                
                // Create crossfaded buffer if needed
                if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
                    console.log("Creating crossfaded buffer for newly loaded sample");
                    const result = createCrossfadedBuffer(
                        buffer, 
                        sampleStartPosition, 
                        sampleEndPosition, 
                        sampleCrossfadeAmount
                    );
                    
                    if (result && result.buffer) {
                        console.log("Successfully created crossfaded buffer for new sample");
                        cachedCrossfadedBuffer = result.buffer;
                        lastCachedStartPos = sampleStartPosition;
                        lastCachedEndPos = sampleEndPosition;
                        lastCachedCrossfade = sampleCrossfadeAmount;
                    }
                }
                
                // Update any active notes to use the new buffer
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        // Skip held notes to avoid interruption
                        if (heldNotes.includes(note.noteNumber)) {
                            console.log(`Note ${note.id} is held; will update on release.`);
                            return;
                        }
                        
                        console.log(`Updating note ${note.id} to use new sample`);
                        note.usesProcessedBuffer = false;
                        note.crossfadeActive = false;
                        
                        if (isSampleLoopOn) {
                            note.looping = true; 
                            setupLoopCrossfade(note);
                        }
                        updateSamplePlaybackParameters(note);
                    }
                });
            });
        };
        reader.readAsArrayBuffer(file);
    }
}

function checkAudioAvailable() {
    if (!audioBuffer) {
        console.warn("No audio buffer available - load a sample first!");
        return false;
    }
    return true;
}

        D('audio-file').addEventListener('change', handleFileSelect);
        
        // Clean up everything
        function cleanupAllNotes() {
            for (const noteNum in activeNotes) {
                killNote(parseInt(noteNum));
            }
            
            // Reset all key states
            for (const key in keyStates) {
                keyStates[key] = false;
            }
            
            updateVoiceDisplay();
        }

        // Add additional safety with blur/focus event handling
        window.addEventListener('blur', cleanupAllNotes);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cleanupAllNotes();
            }
        });

        // Initialize interface
        generateKeyboard();
        updateSliderValues();
        updateVoiceDisplay();
        updateADSRVisualization();

        document.addEventListener('DOMContentLoaded', () => {
    // Initialize all knobs with placeholder functionality
    const knobInitializations = {
        'osc1-pwm-knob': (value) => console.log('OSC1 PWM:', value.toFixed(2)),
        'osc1-gain-knob': (value) => console.log('OSC1 Gain:', value.toFixed(2)),
        'osc2-pwm-knob': (value) => console.log('OSC2 PWM:', value.toFixed(2)),
        'osc2-gain-knob': (value) => console.log('OSC2 Gain:', value.toFixed(2)),
        'vcf-cutoff-knob': (value) => console.log('VCF Cutoff:', value.toFixed(2)),
        'vcf-resonance-knob': (value) => console.log('VCF Resonance:', value.toFixed(2)),
        'lfo-rate-knob': (value) => console.log('LFO Rate:', value.toFixed(2)),
        'arp-rate-knob': (value) => console.log('ARP Rate:', value.toFixed(2)),
        'sample-volume-knob': (value) => {
            if (sampleGainNode) {
                sampleGainNode.gain.setValueAtTime(value, audioCtx.currentTime);
                console.log('Sample Gain:', value.toFixed(2));
            }
        }
    };
});



// Add tooltip creation function
function createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'pitch-tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    // Position tooltip near the pitch knob
    const knob = D('sample-pitch-knob');
    const knobRect = knob.getBoundingClientRect();
    tooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
    tooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
    
    return tooltip;
}
function createTooltipForKnob(knobId, value) {
    const tooltip = document.getElementById(`${knobId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${knobId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        
        // Position tooltip near its knob
        const knob = D(knobId);
        const knobRect = knob.getBoundingClientRect();
        newTooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
        newTooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
        
        return newTooltip;
    })();
    
    return tooltip;
}
function initializeOctaveSlider(slider, onChange) {
    const handle = slider.querySelector('.octave-slider-handle');
    const sliderHeight = slider.offsetHeight - handle.offsetHeight;
    const positions = 5; // -2 to +2
    const stepSize = sliderHeight / (positions - 1);
    let currentPosition = 2; // Start at middle (0)
    
    // Set initial position
    handle.style.top = (currentPosition * stepSize) + 'px';
    
    function snapToPosition(y) {
        const relativeY = y - slider.getBoundingClientRect().top;
        let position = Math.round(relativeY / stepSize);
        position = Math.max(0, Math.min(positions - 1, position));
        return position;
    }
    
    function updatePosition(position) {
        handle.style.top = (position * stepSize) + 'px';
        const value = 2 - position; // Convert position to octave value
        if (onChange) onChange(value);
    }
    
    let isDragging = false;
    
    handle.addEventListener('mousedown', (e) => {
        isDragging = true;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const position = snapToPosition(e.clientY);
        updatePosition(position);
        currentPosition = position;
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
        }
    });
    
    // Initialize at center position (0 octave)
    updatePosition(2);
    
    return {
        setValue: (octave) => {
            const position = 2 - octave; // Convert octave value to position
            updatePosition(Math.max(0, Math.min(positions - 1, position)));
        }
    };
}
// Update the document mouseup handler to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});

function initializePrecisionSlider(slider) {
    let lastY;
    let isDragging = false;
    const range = parseFloat(slider.max) - parseFloat(slider.min);
    const totalHeight = 120; // Height of slider in pixels
    
    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Calculate sensitivity based on shift key
        const sensitivity = e.shiftKey ? 0.2 : 1.0;
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        // Calculate value change
        const valueChange = (deltaY / totalHeight) * range;
        const currentValue = parseFloat(slider.value);
        let newValue = currentValue + valueChange;
        
        // Clamp to min/max
        newValue = Math.min(Math.max(newValue, slider.min), slider.max);
        
        // Update slider value
        slider.value = newValue;
        
        // Trigger input event for ADSR visualization
        slider.dispatchEvent(new Event('input'));
        
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }
    
    slider.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });
}

// Initialize precision control for ADSR sliders
document.addEventListener('DOMContentLoaded', () => {
    ['attack', 'decay', 'sustain', 'release'].forEach(id => {
        const slider = D(id);
        if (slider) {
            initializePrecisionSlider(slider);
        }
    });
});

// Add to your global variables
let isMonoMode = false;
let isLegatoMode = false;
let isPortamentoOn = false;
let glideTime = 0.1; // seconds
let heldNotes = []; // Keep track of held notes in mono mode
let currentNote = null; // Currently sounding note in mono mode


// Add to initializeSwitch function
function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
    let isDragging = false;
    let isActive = false;
    
    // Create tooltip for this switch
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    function updateTooltip() {
        const switchRect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${switchRect.left + switchRect.width + 5}px`;
        tooltip.style.top = `${switchRect.top + (switchRect.height / 2) - 10}px`;
        tooltip.textContent = isActive ? options.onText : options.offText;
        tooltip.style.opacity = '1';
    }
    
    function handleMouseDown(e) {
        isDragging = true;
        switchEl.style.cursor = 'grabbing';
        updateTooltip();
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        switchEl.style.cursor = 'grab';
        tooltip.style.opacity = '0';
    }
    
    function handleClick() {
        isActive = !isActive;
        switchEl.classList.toggle('active');
        updateTooltip();
        return isActive;
    }
    
    switchEl.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    switchEl.addEventListener('click', handleClick);
    
    return {
        getValue: () => isActive,
        setValue: (value) => {
            isActive = value;
            switchEl.classList.toggle('active', isActive);
            updateTooltip();
        }
    };
}

// Update switch initialization with custom text
function initializeSwitches() {
    // Initialize all switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
    const switches = {
        'voice-mode-switch': {
            // ... existing code ...
        },
        'trigger-mode-switch': {
            // ... existing code ...
        },
        'portamento-switch': {
            // ... existing code ...
        },
        'sample-loop-switch': {
            onText: 'LOOP ON',
            offText: 'LOOP OFF',
            onChange: (active) => {
                isSampleLoopOn = active;
                
                // Update any playing samples
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        updateSamplePlaybackParameters(note);
                    }
                });
                
                console.log('Sample Loop:', active ? 'ON' : 'OFF');
            }
        }
    };
    // Rest of the initialization code remains the same...
}

// Initialize the switches
function initializeSwitches() {
    function initializeSwitch(switchEl) {
        let isDragging = false;
        let isActive = false;
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
            }
        };
    }
    
    // Initialize all switches
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'));
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'));
    const portamentoSwitch = initializeSwitch(D('portamento-switch'));
    
    // Handle voice mode changes
    voiceModeSwitch.onChange = (isActive) => {
        isMonoMode = isActive;
        cleanupAllNotes();
    };
    
    // Handle trigger mode changes
    triggerModeSwitch.onChange = (isActive) => {
        isLegatoMode = isActive;
    };
    
    // Handle portamento changes
    portamentoSwitch.onChange = (isActive) => {
        isPortamentoOn = isActive;
    };
}

// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});

        // Update noteOn function to handle mono mode
function noteOn(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
}
// Fix for voice limiting in mono mode
function handleMonoNoteOn(noteNumber) {
    if (!checkAudioAvailable()) return;
    
    // Add note to held notes
    if (!heldNotes.includes(noteNumber)) {
        heldNotes.push(noteNumber);
    }
    
    // Clean up any stale notes that aren't the current note
    Object.values(activeNotes).forEach(note => {
        if (note !== currentNote && note.state === "releasing") {
            quickFadeOut(note, 0.015);
        }
    });

    const shouldTrigger = !isLegatoMode || !currentNote;
    const shouldGlide = isPortamentoOn && lastPlayedNote !== null;

    if (shouldTrigger) {
        if (currentNote) {
            const prevNote = currentNote;
            quickFadeOut(prevNote, 0.015);
            setTimeout(() => {
                // Make sure we're really in mono mode - kill any remaining notes
                Object.values(activeNotes).forEach(note => {
                    if (note !== prevNote) {
                        killNote(note.id);
                    }
                });
                
                currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
                
                if (shouldGlide) {
                    const startRate = TR2 ** (lastPlayedNote - 12);
                    const targetRate = TR2 ** (noteNumber - 12);
                    currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
                    currentNote.source.playbackRate.linearRampToValueAtTime(
                        targetRate,
                        audioCtx.currentTime + glideTime
                    );
                }
                updateVoiceDisplay();
            }, 20);
            return;
        }
        
        currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        if (shouldGlide) {
            const startRate = TR2 ** (lastPlayedNote - 12);
            const targetRate = TR2 ** (noteNumber - 12);
            currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
            currentNote.source.playbackRate.linearRampToValueAtTime(
                targetRate,
                audioCtx.currentTime + glideTime
            );
        }
    } else if (currentNote) {
        // Handle pitch changes in legato mode
        currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
        const currentRate = currentNote.source.playbackRate.value;
        const targetRate = TR2 ** (noteNumber - 12);
        
        currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
        currentNote.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    }

    lastPlayedNote = noteNumber;
    updateVoiceDisplay();
}

// Update handleMonoNoteOff function
function handleMonoNoteOff(noteNumber) {
    // Remove note from held notes array
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    if (heldNotes.length > 0) {
        // If there are still held notes, move to the last pressed note
        const lastNote = heldNotes[heldNotes.length - 1];

        if (!isLegatoMode) {
            // In multi-trigger mode, only retrigger if we're releasing the currently playing note
            if (currentNote && currentNote.noteNumber === noteNumber) {
                quickFadeOut(currentNote);
                setTimeout(() => {
                    currentNote = startNote(lastNote, audioCtx, masterGain, audioBuffer);
                    updateVoiceDisplay();
                }, 20);
            }
        } else {
            // In legato mode, glide if needed
            if (currentNote) {
                currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
                const currentRate = currentNote.source.playbackRate.value;
                const targetRate = TR2 ** (lastNote - 12);
                
                currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
                currentNote.source.playbackRate.linearRampToValueAtTime(
                    targetRate,
                    audioCtx.currentTime + glideTime
                );
            }
        }
    } else {
        if (currentNote) {
            releaseNote(currentNote.id, audioCtx);
            currentNote = null;
        }
    }

    updateVoiceDisplay();
}
// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
function initializeSampleLoopSwitch() {
  const loopSwitch = document.getElementById('sample-loop-switch');
  if (!loopSwitch) return;

  // Toggle “active” class on click
  loopSwitch.addEventListener('click', () => {
    loopSwitch.classList.toggle('active');
    isSampleLoopOn = loopSwitch.classList.contains('active');
    // Update any playing samples
    Object.values(activeNotes).forEach(note => {
      if (note.source) updateSamplePlaybackParameters(note);
    });
    console.log('Sample Loop:', isSampleLoopOn ? 'ON' : 'OFF');
  });
}
document.addEventListener('DOMContentLoaded', () => {
  // Call this after other setup
  initializeSampleLoopSwitch();
});
// Add this function for switch tooltips
function createTooltipForSwitch(switchId, options = { onText: 'ON', offText: 'OFF' }) {
    const tooltip = document.getElementById(`${switchId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${switchId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        return newTooltip;
    })();
    
    // Position tooltip near its switch
    const switchEl = D(switchId);
    if (switchEl) {
        const rect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width + 5}px`;
        tooltip.style.top = `${rect.top + (rect.height / 2) - 10}px`;
    }
    
    return tooltip;
}

function initializeSwitches() {
    function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
        let isDragging = false;
        let isActive = false;
        
        function updateTooltip() {
            const tooltip = createTooltipForSwitch(switchEl.id, options);
            tooltip.textContent = isActive ? options.onText : options.offText;
            tooltip.style.opacity = '1';
        }
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            updateTooltip();
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            updateTooltip();
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
                updateTooltip();
            }
        };
    }
    
    // Initialize switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
}
// Call this function during initialization instead of setupMicRecording

// Update document mouseup to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});
// Auto-hide tooltips after inactivity
function setupAutoHideTooltips() {
  let tooltipHideTimers = {}; // Track timers per tooltip
  const tooltipHideDelay = 250; // 2 seconds
  
  // Function to hide all tooltips
  function hideAllTooltips() {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
      tooltip.style.opacity = '0';
    });
  }
  
  // Function to schedule hiding a specific tooltip
  function scheduleTooltipHide(tooltipId) {
    // Clear any existing timer for this tooltip
    if (tooltipHideTimers[tooltipId]) {
      clearTimeout(tooltipHideTimers[tooltipId]);
    }
    
    // Set new timer
    tooltipHideTimers[tooltipId] = setTimeout(() => {
      const tooltip = document.getElementById(tooltipId);
      if (tooltip) tooltip.style.opacity = '0';
      delete tooltipHideTimers[tooltipId];
    }, tooltipHideDelay);
  }
  
  // When any touch interaction ends, schedule hiding all tooltips
  document.addEventListener('touchend', () => {
    setTimeout(hideAllTooltips, tooltipHideDelay);
  });
  
  // Force hide tooltips when leaving the page or switching tabs
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      hideAllTooltips();
    }
  });
  
  // Ensure tooltips hide after inactivity
  let globalInactivityTimer = null;
  
  function resetInactivityTimer() {
    if (globalInactivityTimer) clearTimeout(globalInactivityTimer);
    globalInactivityTimer = setTimeout(hideAllTooltips, tooltipHideDelay);
  }
  
  // Reset the timer on any touch event
  ['touchstart', 'touchmove', 'touchend'].forEach(eventName => {
    document.addEventListener(eventName, resetInactivityTimer, { passive: true });
  });
  
  // Initially reset timer
  resetInactivityTimer();
}
function initializeSwitches() {
    const switches = {
        'voice-mode-switch': {
            onText: 'MONO',
            offText: 'POLY',
            onChange: (active) => {
                isMonoMode = active;
                cleanupAllNotes();
                console.log('Voice Mode:', active ? 'MONO' : 'POLY');
            }
        },
        'trigger-mode-switch': {
            offText: 'MULTI',
            onText: 'LEGATO',
            onChange: (active) => {
                isLegatoMode = active;
                console.log('Trigger Mode:', active ? 'LEGATO' : 'MULTI');
            }
        },
        'portamento-switch': {
            onText: 'PORTA ON',
            offText: 'PORTA OFF',
            onChange: (active) => {
                isPortamentoOn = active;
                console.log('Portamento:', active ? 'ON' : 'OFF');
            }
        }
    };

    Object.entries(switches).forEach(([id, config]) => {
        const switchEl = D(id);
        if (!switchEl) return;

        let isActive = false;
        
        function updateSwitch() {
            switchEl.classList.toggle('active', isActive);
            
            // Skip tooltip creation completely for emu-mode-switch
            if (id !== 'emu-mode-switch') {
                const tooltip = createTooltipForSwitch(id);
                tooltip.textContent = isActive ? config.onText : config.offText;
                tooltip.style.opacity = '1';
            }
            
            config.onChange(isActive);
        }

        switchEl.addEventListener('click', () => {
            isActive = !isActive;
            updateSwitch();
        });

        // Don't add tooltip events to emu-mode-switch
        if (id !== 'emu-mode-switch') {
            switchEl.addEventListener('mousedown', (e) => {
                const tooltip = createTooltipForSwitch(id);
                tooltip.textContent = isActive ? config.onText : config.offText;
                tooltip.style.opacity = '1';
                e.preventDefault();
            });
        }
    });
    
    // Add special handling for emu-mode-switch
    const emuModeSwitch = D('emu-mode-switch');
    if (emuModeSwitch) {
        emuModeSwitch.addEventListener('click', () => {
            const isActive = emuModeSwitch.classList.contains('active');
            isEmuModeOn = !isActive; // Toggle the state
            
            // Update LED indicator
            const led = document.getElementById('emu-led');
            if (led) {
                led.classList.toggle('on', !isActive);
            }
            
            // Toggle active class
            emuModeSwitch.classList.toggle('active', !isActive);
            
            // Process with E-mu mode
            updateSampleProcessing();
            
            // Update any playing notes
            Object.values(activeNotes).forEach(note => {
                if (note && note.source && !heldNotes.includes(note.noteNumber)) {
                    updateSamplePlaybackParameters(note);
                }
            });
            
            console.log('Lo-Fi Mode:', !isActive ? 'ON' : 'OFF');
        });
    }
}
// JavaScript for sample selector dropdown
document.addEventListener('DOMContentLoaded', function() {
  const selectorBtn = document.getElementById('sample-selector-btn');
  const dropdown = document.getElementById('sample-dropdown');
  const dropdownItems = document.querySelectorAll('.dropdown-item');
  
  // Toggle dropdown when clicking the button
  selectorBtn.addEventListener('click', function() {
    dropdown.classList.toggle('show');
    event.stopPropagation();
  });
  
  // Close dropdown when clicking outside
  window.addEventListener('click', function() {
    if (dropdown.classList.contains('show')) {
      dropdown.classList.remove('show');
    }
  });
  
  // Handle preset sample selection
  dropdownItems.forEach(item => {
    item.addEventListener('click', function() {
      const sampleName = this.getAttribute('data-sample');
      loadPresetSample(sampleName);
      dropdown.classList.remove('show');
    });
  });
});

// Function to load preset samples
function loadPresetSample(filename) {
  console.log(`Loading preset sample: ${filename}`);
  
  // Build the URL to the sample file
  const sampleUrl = `samples/${filename}`;
  
  // Fetch the sample file
  fetch(sampleUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load sample: ${response.status} ${response.statusText}`);
      }
      return response.arrayBuffer();
    })
    .then(arrayBuffer => {
      // Decode the audio data
      return audioCtx.decodeAudioData(arrayBuffer);
    })
    .then(buffer => {
    // Use the buffer as the sample
    audioBuffer = buffer;
    
    // Process fades and crossfades whenever a new preset is loaded
    updateSampleProcessing();
    
    // Rest of the function...
      
      // Reset cached crossfade buffer when loading a new sample
      cachedCrossfadedBuffer = null;
      lastCachedStartPos = null;
      lastCachedEndPos = null;
      lastCachedCrossfade = null;
      
      // Create new source node
      if (sampleSource) {
        sampleSource.stop();
      }
      sampleSource = audioCtx.createBufferSource();
      sampleSource.buffer = buffer;
      
      // Connect the audio chain
      sampleSource.connect(sampleGainNode);
      sampleSource.start();
      
      // Update the label to show the loaded sample name
      const fileLabel = document.querySelector('label[for="audio-file"]');
      if (fileLabel) {
        fileLabel.textContent = filename.substring(0, 10) + (filename.length > 10 ? '...' : '');
      }
      
      // Create crossfaded buffer if needed
      if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        console.log("Creating crossfaded buffer for preset sample");
        const result = createCrossfadedBuffer(
          buffer, 
          sampleStartPosition, 
          sampleEndPosition, 
          sampleCrossfadeAmount
        );
        
        if (result && result.buffer) {
          console.log("Successfully created crossfaded buffer for preset sample");
          cachedCrossfadedBuffer = result.buffer;
          lastCachedStartPos = sampleStartPosition;
          lastCachedEndPos = sampleEndPosition;
          lastCachedCrossfade = sampleCrossfadeAmount;
        }
      }
      
      // Update any active notes to use the new buffer
      Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
          // Skip held notes to avoid interruption
          if (heldNotes.includes(note.noteNumber)) {
            console.log(`Note ${note.id} is held; will update on release.`);
            return;
          }
          
          console.log(`Updating note ${note.id} to use new preset sample`);
          note.usesProcessedBuffer = false;
          note.crossfadeActive = false;
          
          if (isSampleLoopOn) {
            note.looping = true; 
            setupLoopCrossfade(note);
          }
          updateSamplePlaybackParameters(note);
        }
      });
    })
    .catch(error => {
      console.error('Error loading preset sample:', error);
      alert(`Failed to load sample: ${filename}`);
    });
}
// In your processBufferWithFades function:
function processBufferWithFades(buffer) {
    if (!buffer) return null;

    // Skip processing if no fades needed
    if (sampleFadeInAmount < 0.01 && sampleFadeOutAmount < 0.01) {
        console.log("No fades to apply, returning original buffer");
        return buffer;
    }

    console.log("Applying fade to trimmed buffer...");
    const length = buffer.length;
    if (length < 2) return buffer;

    // Create the faded buffer
    const newFadedBuffer = audioCtx.createBuffer(
        buffer.numberOfChannels, 
        length, 
        buffer.sampleRate
    );
    
    // Calculate fade samples OUTSIDE the channel loop
    const fadeInSamples = Math.floor(length * sampleFadeInAmount);
    const fadeOutSamples = Math.floor(length * sampleFadeOutAmount);
    
    for (let c = 0; c < buffer.numberOfChannels; c++) {
        const inputData = buffer.getChannelData(c);
        const outputData = newFadedBuffer.getChannelData(c);
        
        // First copy all samples
        for (let i = 0; i < length; i++) {
            outputData[i] = inputData[i];
        }
        
        // Apply fade in (first part of buffer)
        for (let i = 0; i < fadeInSamples; i++) {
            outputData[i] *= i / fadeInSamples;
        }
        
        // Apply fade out (last part of buffer)
        for (let i = 0; i < fadeOutSamples; i++) {
            const idx = length - 1 - i;
            outputData[idx] *= i / fadeOutSamples;
        }
    }
    
    // CRITICAL FIX: Store the processed buffer in the global fadedBuffer variable
    fadedBuffer = newFadedBuffer;
    
    // Store the original duration for correct playback
    fadedBufferOriginalDuration = (sampleEndPosition - sampleStartPosition) * audioBuffer.duration;
    console.log(`Created faded buffer with ${fadeInSamples} fade in samples and ${fadeOutSamples} fade out samples`);
    console.log(`Original duration: ${fadedBufferOriginalDuration}s`);
    
    return newFadedBuffer;
}
function applyEmuProcessing(buffer) {
  if (!buffer) return null;
  
  const ctx = audioCtx;
  const sampleRate = buffer.sampleRate;
  const channels = buffer.numberOfChannels;
  const length = buffer.length;
  
  // Create a new buffer for the processed audio
  const processedBuffer = ctx.createBuffer(channels, length, sampleRate);
  
  // Process each channel
  for (let channel = 0; channel < channels; channel++) {
    const inputData = buffer.getChannelData(channel);
    const outputData = processedBuffer.getChannelData(channel);
    
    // First simply copy all data
    for (let i = 0; i < length; i++) {
      outputData[i] = inputData[i];
    }
    
    // Apply 8-bit mu-law companding simulation 
    for (let i = 0; i < length; i++) {
      // 1. Compress (simulate mu-law encoding)
      const compressed = Math.sign(outputData[i]) * 
                      Math.log(1 + 255 * Math.abs(outputData[i])) / Math.log(256);
      
      // 2. Simulate quantization (8-bit)
      const quantized = Math.round(compressed * 255) / 255;
      
      // 3. Decompress (simulate mu-law decoding)
      outputData[i] = Math.sign(quantized) * 
                   (Math.pow(256, Math.abs(quantized)) - 1) / 255;
    }
    
    // Apply extremely subtle noise (0.05% amplitude)
    for (let i = 0; i < length; i++) {
      outputData[i] += (Math.random() * 2 - 1) * 0.0005;
    }
    
    // Apply gentle low-pass filter
    let prevSample = outputData[0];
    const alpha = 0.20; // Filter strength
    
    for (let i = 0; i < length; i++) {
      prevSample = outputData[i] = prevSample + alpha * (outputData[i] - prevSample);
    }
  }
  
  return processedBuffer;
}
// Add this helper function to find zero crossings
function findBestZeroCrossings(buffer, rawStartSample, rawEndSample) {
    const searchWindowSamples = Math.ceil(buffer.sampleRate * 0.01); // 10ms search window
    let startSample = rawStartSample;
    let endSample = rawEndSample;
    
    try {
        // Get first channel data for analysis
        const data = buffer.getChannelData(0);
        const totalSamples = buffer.length;
        
        // Find zero crossings near start position
        const startCrossings = [];
        const startMin = Math.max(0, rawStartSample - searchWindowSamples);
        const startMax = Math.min(totalSamples - 2, rawStartSample + searchWindowSamples);
        
        for (let i = startMin; i < startMax; i++) {
            // Detect rising zero crossing (negative to positive)
            if (data[i] <= 0 && data[i + 1] > 0) {
                startCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'rising'
                });
            }
            // Detect falling zero crossing (positive to negative)
            else if (data[i] >= 0 && data[i + 1] < 0) {
                startCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'falling'
                });
            }
        }
        
        // Find zero crossings near end position
        const endCrossings = [];
        const endMin = Math.max(0, rawEndSample - searchWindowSamples);
        const endMax = Math.min(totalSamples - 2, rawEndSample + searchWindowSamples);
        
        for (let i = endMin; i < endMax; i++) {
            if (data[i] <= 0 && data[i + 1] > 0) {
                endCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'rising'
                });
            }
            else if (data[i] >= 0 && data[i + 1] < 0) {
                endCrossings.push({
                    index: i,
                    slope: data[i + 1] - data[i],
                    type: 'falling'
                });
            }
        }
        
        console.log(`Found ${startCrossings.length} start and ${endCrossings.length} end zero crossings`);
        
        // If we found zero crossings, match them by type and slope
        if (startCrossings.length > 0 && endCrossings.length > 0) {
            let bestMatch = { score: -Infinity, start: rawStartSample, end: rawEndSample };
            
            for (const start of startCrossings) {
                for (const end of endCrossings) {
                    // Score based on matching type and similar slope
                    const typeScore = (start.type === end.type) ? 5 : -2;
                    const slopeScore = 5 - Math.min(5, Math.abs(start.slope - end.slope) * 20);
                    const distanceScore = 3 - Math.min(3, 
                        (Math.abs(start.index - rawStartSample) + 
                         Math.abs(end.index - rawEndSample)) / (searchWindowSamples * 2) * 3);
                    
                    const score = typeScore + slopeScore + distanceScore;
                    
                    if (score > bestMatch.score) {
                        bestMatch = {
                            score,
                            start: start.index,
                            end: end.index
                        };
                    }
                }
            }
            
            if (bestMatch.score > 0) {
                console.log(`Using zero crossings: start=${bestMatch.start}, end=${bestMatch.end}, score=${bestMatch.score.toFixed(2)}`);
                startSample = bestMatch.start;
                endSample = bestMatch.end;
            }
        }
    } catch (e) {
        console.error("Error finding zero crossings:", e);
    }
    
    return { start: startSample, end: endSample };
}
function updateSampleProcessing() {
    console.log("Updating sample processing...");
    
    // Reset cached buffers
    fadedBuffer = null;
    cachedCrossfadedBuffer = null;
    lastCachedStartPos = null;
    lastCachedEndPos = null;
    lastCachedCrossfade = null;
    
    setTimeout(() => {
        if (audioBuffer) {
            // STEP 1: First trim to the desired region WITH ZERO-CROSSING ALIGNMENT
            const totalSamples = audioBuffer.length;
            const rawStartSample = Math.floor(sampleStartPosition * totalSamples);
            const rawEndSample = Math.floor(sampleEndPosition * totalSamples);
            
            // Find zero-crossings near the start and end points
            const alignedPoints = findBestZeroCrossings(
                audioBuffer, 
                rawStartSample, 
                rawEndSample
            );
            
            const startSample = alignedPoints.start;
            const endSample = alignedPoints.end;
            const trimmedLength = Math.max(2, endSample - startSample);
            
            // Store original duration for accurate playback timing
            fadedBufferOriginalDuration = (endSample - startSample) / audioBuffer.sampleRate;
            
            const trimmedBuffer = audioCtx.createBuffer(
                audioBuffer.numberOfChannels,
                trimmedLength,
                audioBuffer.sampleRate
            );
            
            // Copy the trimmed section
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                const origData = audioBuffer.getChannelData(channel);
                const newData = trimmedBuffer.getChannelData(channel);
                for (let i = 0; i < trimmedLength; i++) {
                    newData[i] = origData[startSample + i];
                }
            }
            
            // STEP 2: Apply fades to the trimmed buffer
            let processedBuffer = trimmedBuffer;
            
            // Only apply fades if needed 
            if (sampleFadeInAmount > 0.01 || sampleFadeOutAmount > 0.01) {
                processedBuffer = audioCtx.createBuffer(
                    trimmedBuffer.numberOfChannels,
                    trimmedBuffer.length,
                    trimmedBuffer.sampleRate
                );
                
                // Calculate fade lengths once
                const fadeInSamples = Math.floor(trimmedLength * sampleFadeInAmount);
                const fadeOutSamples = Math.floor(trimmedLength * sampleFadeOutAmount);
                
                for (let c = 0; c < trimmedBuffer.numberOfChannels; c++) {
                    const inputData = trimmedBuffer.getChannelData(c);
                    const outputData = processedBuffer.getChannelData(c);
                    
                    // Copy all samples first
                    for (let i = 0; i < trimmedLength; i++) {
                        outputData[i] = inputData[i];
                    }
                    
                    // Apply fade in
                    for (let i = 0; i < fadeInSamples; i++) {
                        outputData[i] *= i / fadeInSamples;
                    }
                    
                    // Apply fade out
                    for (let i = 0; i < fadeOutSamples; i++) {
                        const idx = trimmedLength - 1 - i;
                        outputData[idx] *= i / fadeOutSamples;
                    }
                }
            }
            
            // Store the processed buffer (pre-lofi)
            let finalBuffer = processedBuffer;
            
            // STEP 3: Handle crossfade for looping (before applying Lo-Fi)
            if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
                setTimeout(() => {
                    const result = createCrossfadedBuffer(
                        processedBuffer,
                        0,  // Start from beginning of the processed buffer
                        1,  // Use entire processed buffer
                        sampleCrossfadeAmount
                    );
                    
                    if (result && result.buffer) {
                        let crossfadedBuffer = result.buffer;
                        
                        // STEP 4: Apply E-mu processing AFTER crossfade if enabled
                        if (isEmuModeOn) {
                            crossfadedBuffer = applyEmuProcessing(crossfadedBuffer);
                        }
                        
                        cachedCrossfadedBuffer = crossfadedBuffer;
                        lastCachedStartPos = sampleStartPosition;
                        lastCachedEndPos = sampleEndPosition;
                        lastCachedCrossfade = sampleCrossfadeAmount;
                    }
                }, 10);
            }
            
            // STEP 4: Apply E-mu processing at the very end for non-crossfaded cases
            if (isEmuModeOn) {
                finalBuffer = applyEmuProcessing(processedBuffer);
            }
            
            // Store the final processed buffer
            fadedBuffer = finalBuffer;
        }
    }, 10);
}
// Add MIDI controller support to overcome keyboard limitations
function setupMIDIAccess() {
  if (!navigator.requestMIDIAccess) {
    console.log("WebMIDI not supported in this browser");
    return;
  }

  navigator.requestMIDIAccess()
    .then(onMIDISuccess, onMIDIFailure);

  function onMIDISuccess(midiAccess) {
    console.log("MIDI access obtained");
    
    // Get lists of available MIDI controllers
    const inputs = midiAccess.inputs.values();
    
    // Connect to all available inputs
    for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
      input.value.onmidimessage = onMIDIMessage;
      console.log("Connected to MIDI device: " + input.value.name);
    }
    
    // Listen for new devices being connected
    midiAccess.onstatechange = function(e) {
      if (e.port.type === "input" && e.port.state === "connected") {
        e.port.onmidimessage = onMIDIMessage;
        console.log("Connected to MIDI device: " + e.port.name);
      }
    };
  }

  function onMIDIFailure(msg) {
    console.error("Failed to get MIDI access - " + msg);
  }

  function onMIDIMessage(event) {
    // Extract MIDI data
    const [command, note, velocity] = event.data;
    
    // Note on (144-159) with velocity > 0
    if ((command >= 144 && command <= 159) && velocity > 0) {
      // Convert MIDI note numbers (starts at 21 for A0) to our note system (starts at 0)
      const ourNoteNumber = Math.max(0, note - 36); // Adjust offset as needed
      noteOn(ourNoteNumber);
    } 
    // Note off (128-143) or note on with velocity 0
    else if ((command >= 128 && command <= 143) || 
             (command >= 144 && command <= 159 && velocity === 0)) {
      const ourNoteNumber = Math.max(0, note - 36); // Adjust offset as needed
      noteOff(ourNoteNumber);
    }
  }
}


// Detect iOS device
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

// Only show the unlock overlay on iOS devices
if (isIOS()) {
  // Wait a moment for everything else to initialize
  setTimeout(() => {
    createiOSStartupOverlay();
  }, 100);
}

// Add explicit touch handling for iOS throughout your UI
function addIOSTouchHandlers() {
  // Add touch handlers to all interactive elements
  const touchElements = document.querySelectorAll('.key, .knob, .button, .switch-container, .vertical-switch');
  
  touchElements.forEach(el => {
    el.addEventListener('touchstart', function(e) {
      // Ensure audio context is resumed on any touch
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          console.log('AudioContext resumed by user interaction');
        });
      }
      // Don't prevent default here to allow the original handlers to work
    });
  });
}





// Comprehensive fix for knobs and controls on both desktop and mobile
function fixAllControls() {
  // Fix desktop and mobile knob interaction
  document.querySelectorAll('.knob').forEach(knob => {
    // Create a completely fresh knob without any event listeners
    const newKnob = knob.cloneNode(true);
    knob.parentNode.replaceChild(newKnob, knob);
    
    // Extract ID and initial state
    const knobId = newKnob.id;
    const callback = knobInitializations[knobId];
    const defaultValue = knobDefaults[knobId] !== undefined ? knobDefaults[knobId] : 0.5;
    
    // Set up initial rotation
    let rotation = -150 + (defaultValue * 300);
    newKnob.style.transform = `rotate(${rotation}deg)`;
    
    // Track interaction state
    let isDragging = false;
    let startY, lastY;
    
    // Double-click/tap detection
    let lastClickTime = 0;
    
    // Desktop mouse handling
    newKnob.addEventListener('mousedown', function(e) {
      // Check for double-click
      const now = new Date().getTime();
      const timeSinceLastClick = now - lastClickTime;
      
      if (timeSinceLastClick < 350 && timeSinceLastClick > 0) {
        // Double-click - reset to default
        resetToDefault();
        e.preventDefault();
        return;
      }
      
      lastClickTime = now;
      
      // Start dragging
      isDragging = true;
      startY = e.clientY;
      lastY = startY;
      this.style.cursor = 'grabbing';
      
      // Set up document-level handlers
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      e.preventDefault();
    });
    
    function handleMouseMove(e) {
      if (!isDragging) return;
      
      // Calculate movement
      const deltaY = lastY - e.clientY;
      lastY = e.clientY;
      
      updateKnob(deltaY);
      e.preventDefault();
    }
    
    function handleMouseUp() {
      if (isDragging) {
        isDragging = false;
        newKnob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
    }
    
    // Touch handling
    newKnob.addEventListener('touchstart', function(e) {
      // Check for double-tap
      const now = new Date().getTime();
      const timeSinceLastClick = now - lastClickTime;
      
      if (timeSinceLastClick < 350 && timeSinceLastClick > 0) {
        // Double-tap - reset to default
        resetToDefault();
        e.preventDefault();
        return;
      }
      
      lastClickTime = now;
      
      // Only handle single touches
      if (e.touches.length !== 1) return;
      
      isDragging = true;
      startY = e.touches[0].clientY;
      lastY = startY;
      
      // Set up document-level handlers
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd);
      document.addEventListener('touchcancel', handleTouchEnd);
      
      e.preventDefault();
    }, { passive: false });
    
    function handleTouchMove(e) {
      if (!isDragging || e.touches.length !== 1) return;
      
      const deltaY = lastY - e.touches[0].clientY;
      lastY = e.touches[0].clientY;
      
      updateKnob(deltaY);
      e.preventDefault();
    }
    
    function handleTouchEnd() {
      if (isDragging) {
        isDragging = false;
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
        document.removeEventListener('touchcancel', handleTouchEnd);
      }
    }
    
    // Common function to update knob rotation and value
    function updateKnob(delta) {
      // Apply movement with sensitivity
      const newRotation = Math.min(150, Math.max(-150, rotation + delta));
      
      // Only update if there's actual change
      if (newRotation !== rotation) {
        rotation = newRotation;
        newKnob.style.transform = `rotate(${rotation}deg)`;
        
        if (callback) {
          const normalizedValue = (rotation + 150) / 300;
          callback(normalizedValue);
        }
      }
    }
    
    // Reset function for double-click/tap
    function resetToDefault() {
      rotation = -150 + (defaultValue * 300);
      newKnob.style.transform = `rotate(${rotation}deg)`;
      if (callback) {
        callback(defaultValue);
      }
      console.log(`Reset ${knobId} to default value:`, defaultValue);
    }
  });
  
  // Fix switch controls
  document.querySelectorAll('.vertical-switch').forEach(switchEl => {
    // Create fresh switch
    const newSwitch = switchEl.cloneNode(true);
    switchEl.parentNode.replaceChild(newSwitch, switchEl);
    
    // Simple click handler - works for both mouse and touch
    newSwitch.addEventListener('click', function(e) {
      this.classList.toggle('active');
      
      // Trigger switch updates based on ID
      const switchId = this.id;
      if (switchId === 'voice-mode-switch') {
        isMonoMode = this.classList.contains('active');
        cleanupAllNotes();
      } else if (switchId === 'trigger-mode-switch') {
        isLegatoMode = this.classList.contains('active');
      } else if (switchId === 'portamento-switch') {
        isPortamentoOn = this.classList.contains('active');
      }
      
      e.stopPropagation();
    });
    
    // Prevent default on touchstart to avoid scrolling
    newSwitch.addEventListener('touchstart', function(e) {
      e.preventDefault();
    }, { passive: false });
  });
}

// Fix Lo-Fi and Rec buttons (special buttons)
function initializeSpecialButtons() {
  // Fix for LoFi button
  const emuModeSwitch = document.getElementById('emu-mode-switch');
  if (emuModeSwitch) {
    // Remove any existing listeners first
    const newEmuSwitch = emuModeSwitch.cloneNode(true);
    emuModeSwitch.parentNode.replaceChild(newEmuSwitch, emuModeSwitch);
    
    // Add a single click handler with touch lock
    let touchLock = false;
    let touchTimeout;
    
    newEmuSwitch.addEventListener('click', function(e) {
      // Prevent rapid toggling
      if (touchLock) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      
      touchLock = true;
      
      // Toggle state
      const isActive = newEmuSwitch.classList.contains('active');
      isEmuModeOn = !isActive;
      
      // Update LED indicator
      const led = document.getElementById('emu-led');
      if (led) {
        led.classList.toggle('on', !isActive);
      }
      
      // Toggle active class
      newEmuSwitch.classList.toggle('active', !isActive);
      
      // Process with E-mu mode
      updateSampleProcessing();
      
      // Update any playing notes
      Object.values(activeNotes).forEach(note => {
        if (note && note.source && !heldNotes.includes(note.noteNumber)) {
          updateSamplePlaybackParameters(note);
        }
      });
      
      console.log('Lo-Fi Mode:', !isActive ? 'ON' : 'OFF');
      
      // Release lock after a delay
      clearTimeout(touchTimeout);
      touchTimeout = setTimeout(() => {
        touchLock = false;
      }, 300);
    });
    
    // Add touch handling that prevents propagation
    newEmuSwitch.addEventListener('touchstart', function(e) {
      e.stopPropagation();
    }, { passive: true });
    
    newEmuSwitch.addEventListener('touchend', function(e) {
      if (!touchLock) {
        this.click();
      }
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
  }
  
 
}




// Direct fix for vertical switches in touch mode
function fixSwitchesTouchMode() {
  // Target specific switches by ID
  const switchIds = ['voice-mode-switch', 'trigger-mode-switch', 'portamento-switch'];
  
  switchIds.forEach(id => {
    const switchEl = document.getElementById(id);
    if (!switchEl) return;
    
    // Remove ALL existing event listeners by cloning
    const newSwitch = switchEl.cloneNode(true);
    switchEl.parentNode.replaceChild(newSwitch, switchEl);
    
    // Add a single, simple touchstart event with proper passive setting
    newSwitch.addEventListener('touchstart', function(e) {
      // This is critical - must be at the top
      e.preventDefault();
      e.stopPropagation();
      
      // Simply toggle the active class
      this.classList.toggle('active');
      
      // Update state based on ID
      const isActive = this.classList.contains('active');
      console.log(`Switch ${id} touched, state now: ${isActive}`);
      
      switch(id) {
        case 'voice-mode-switch':
          isMonoMode = isActive;
          cleanupAllNotes();
          console.log('Voice Mode:', isActive ? 'MONO' : 'POLY');
          break;
        case 'trigger-mode-switch':
          isLegatoMode = isActive;
          console.log('Trigger Mode:', isActive ? 'LEGATO' : 'MULTI');
          break;
        case 'portamento-switch':
          isPortamentoOn = isActive;
          console.log('Portamento:', isPortamentoOn ? 'ON' : 'OFF');
          break;
      }
    }, { passive: false });  // passive: false is critical here!
    
    // Also handle normal clicks for mouse users
    newSwitch.addEventListener('click', function(e) {
      // Skip if this was a touch event that bubbled to click
      if (e.pointerType === 'touch') return;
      
      this.classList.toggle('active');
      const isActive = this.classList.contains('active');
      
      switch(id) {
        case 'voice-mode-switch':
          isMonoMode = isActive;
          cleanupAllNotes();
          break;
        case 'trigger-mode-switch':
          isLegatoMode = isActive;
          break;
        case 'portamento-switch':
          isPortamentoOn = isActive;
          break;
      }
    });
  });
}


// CLEAN UP - Delete redundant and outdated event listeners
// Keep only this consolidated event listener for initialization
document.addEventListener('DOMContentLoaded', function() {
  // Core functionality
  generateKeyboard();
  updateSliderValues();
  updateVoiceDisplay();
  updateADSRVisualization();
  
  // Initialize controls
  fixAllControls();
  initializeSpecialButtons();
  fixSwitchesTouchMode();
  fixMicRecording();
  preventScrollOnControls();
  
  // Set up special handling for touch devices
  if (isTouchDevice()) {
    setupAutoHideTooltips();
  }
  
  // iOS-specific handling
  if (isIOS()) {
    addIOSTouchHandlers();
    document.body.style.touchAction = 'none';
    document.body.style.overscrollBehavior = 'none';
  }
  
  // MIDI functionality
  setupMIDIAccess();
  
  // Re-register any important listeners
  if (D('audio-file')) {
    D('audio-file').addEventListener('change', handleFileSelect);
  }
  
  // Add audio context resume handlers
  const resumeAudioContext = function() {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        console.log('AudioContext resumed');
      });
    }
  };
  
  document.body.addEventListener('touchstart', resumeAudioContext, { passive: true });
  document.body.addEventListener('mousedown', resumeAudioContext, { passive: true });
});

    </script>
</body>
</html>