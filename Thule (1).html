<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ARDIST - Thule</title>
    <style>
        
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5dc;
            color: #3f2101;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
    max-width: 1500px; /* Increased from 1200px - 25% wider */
    width: 100%;
}
        
        h2 {
            color: #8b4513;
            margin-bottom: 5px;
        }
        
        p {
            margin-top: 5px;
            margin-bottom: 15px;
        }
        
        /* Synth panel styling */
        /* Update the synth-panel class */
.synth-panel {
    display: flex;  /* Change from grid to flex */
    flex-direction: row;
    gap: 2px;
    background-color: #f0e6d2;
    border: 2px solid #3f2101;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    overflow-x: auto;  /* Allow horizontal scrolling if needed */
}
        
        .module {
    background-color: #f5f5dc;
    border: 1px solid #3f2101;
    border-radius: 5px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    width: 80px; /* Fixed width, reduced by ~30% from original */
    min-width: 80px; /* Same as width to prevent resizing */
    max-width: 80px; /* Same as width to prevent resizing */
}
        
        .module-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 14px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3f2101;
        }
        .wave-select-container {
    position: relative;
    width: 100%;
    margin: 10px 0;
}
/* Styling for the sampler module with two columns */
.sampler-module {
  width: 160px; /* Double the width of regular modules */
  min-width: 160px; /* Keep the minimum width consistent */
  max-width: 160px; /* Maximum width */
}

.sampler-columns {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  width: 100%;
}

.sampler-column {
  width: 48%; /* Slightly less than 50% to allow for spacing */
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Make the file section take full width of its column */
.sampler-column .file-section {
  width: 100%;
}

/* Adjust knobs to fit within narrower columns */
.sampler-column .knob {
  margin: 8px auto; /* Slightly reduced margin */
}

/* Update sampler column labels to match other modules */
.sampler-column label {
  font-size: 16px; /* Changed from 11px to match oscillator modules */
  margin-bottom: 5px;
  font-family: 'Courier New', Courier, monospace; /* Explicitly set font family */
  color: #3f2101; /* Match text color */
  text-align: center; /* Ensure consistent alignment */
}
/* Updated sample selector styling to match rest of the interface */
.sample-selector-container {
  width: 100%;
  position: relative;
  margin: 5px 0 10px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Match button styling perfectly to Load Sample button */
#sample-selector-btn {
  width: 80%;
  height: 32px;
  min-height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #e6e6e6;
  color: #3f2101;
  border: 1px solid #3f2101;
  border-radius: 3px;
  padding: 8px;
  font-family: 'Courier New', Courier, monospace; /* Match font family */
  font-size: 12px; /* Match font size */
  text-align: center;
  cursor: pointer;
  box-sizing: border-box;
}

#sample-selector-btn:hover {
  background: #d4c6a8;
}

/* Update dropdown menu styling to match theme */
.sample-dropdown {
  display: none;
  position: absolute;
  top: 40px; /* Position below button */
  background-color: #e6e6e6; /* Match button background */
  width: 80%; /* Match button width */
  box-shadow: 0px 8px 16px 0px rgba(63, 33, 1, 0.2);
  z-index: 100;
  border-radius: 3px;
  border: 1px solid #3f2101;
  max-height: 150px;
  overflow-y: auto;
}

.sample-dropdown.show {
  display: block;
}

.dropdown-item {
  padding: 6px 8px;
  text-decoration: none;
  display: block;
  color: #3f2101;
  font-family: 'Courier New', Courier, monospace; /* Match font family */
  font-size: 12px; /* Match font size */
  cursor: pointer;
}

.dropdown-item:hover {
  background-color: #d4c6a8;
}
/* Fix alignment of right column knobs */
#sample-start-knob {
  margin-top: 11px !important; /* Push down the first knob in right column */
}

/* Make space for dropdown to prevent elements pushing down */
.sample-selector-container {
  margin-bottom: 5px;
  height: 42px; /* Fixed height to match file input area */
}
.wave-select {
    width: 100%;
    padding: 8px;
    border: 1px solid #3f2101;
    border-radius: 4px;
    background-color: #e6e6e6;
    color: #3f2101;
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
}

/* Custom dropdown arrow */
.wave-select-container::after {
    content: '';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid #3f2101;
    pointer-events: none;
}

/* Hover and focus states */
.wave-select:hover {
    background-color: #d4c6a8;
}

.wave-select:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
    background-color: #f5f5dc;
}

.tooltip {
    position: absolute;
    background: rgba(63, 33, 1, 0.9);
    color: #f5f5dc;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s;
}
/* Style for options */
.wave-select option {
    background-color: #f5f5dc;
    color: #3f2101;
    padding: 8px;
}
        /* Sliders and knobs */
        .knob {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e6e6e6;
    border: 1px solid #3f2101;
    position: relative;
    margin: 10px auto;
    cursor: grab;
    transform-origin: center center;
    transition: transform 0.05s ease-out;
}

.knob:active {
    cursor: grabbing;
}

.knob::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 3px;    /* Changed from 3px to 2px for consistency */
    height: 14px;   /* Changed from 14px to 10px for consistency */
    background-color: #3f2101;
    transform-origin: bottom center;
    transform: translateX(-50%);
}
        
.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    height: 120px;
    margin: 0 10px;
}

.slider-container label {
    font-size: 12px;
    color: #3f2101;
    margin-top: 10px;
}

.slider-container input[type="range"] {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-35px, 35px);
}

.slider-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.slider-container input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

.slider-container span {
    font-size: 12px;
    color: #3f2101;
    margin-top: 5px;
}
        
        /* Radio button group styling */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 10px 0;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        /* Keyboard responsive resizing */
.keyboard {
    display: flex;
    width: 100%;
    position: relative;
    background-color: #f0e6d2;
    border: 2px solid #3f2101;
    border-radius: 5px;
    /* Create an aspect ratio container */
    aspect-ratio: 4 / 1; /* Width:Height ratio for the keyboard */
    max-height: 190px; /* Maximum height */
    margin-top: 20px;
    overflow: hidden;
}

.key {
    flex: 1;
    height: 100%;
    background-color: #f5f5dc;
    border: 1px solid #3f2101;
    cursor: pointer;
    position: relative;
    user-select: none;
    margin: 0;
    padding: 0;
}

.key.black {
    background-color: #3f2101;
    position: absolute;
    width: 7%; /* Relative width instead of fixed pixels */
    height: 60%; /* Height relative to keyboard height */
    z-index: 1;
    border: none;
    transform: translateX(-50%);
    max-width: 5.5%; /* Maximum width for larger screens */
}

/* Update black key positioning calculations */
.key.black:nth-of-type(15) { left: calc(100% * 1/14); }   /* C# */
.key.black:nth-of-type(16) { left: calc(100% * 2/14); }   /* D# */
.key.black:nth-of-type(17) { left: calc(100% * 4/14); }   /* F# */
.key.black:nth-of-type(18) { left: calc(100% * 5/14); }   /* G# */
.key.black:nth-of-type(19) { left: calc(100% * 6/14); }   /* A# */
.key.black:nth-of-type(20) { left: calc(100% * 8/14); }   /* C# (second octave) */
.key.black:nth-of-type(21) { left: calc(100% * 9/14); }   /* D# (second octave) */
.key.black:nth-of-type(22) { left: calc(100% * 11/14); }  /* F# (second octave) */
.key.black:nth-of-type(23) { left: calc(100% * 12/14); }  /* G# (second octave) */
.key.black:nth-of-type(24) { left: calc(100% * 13/14); }  /* A# (second octave) */
/* Add a responsive adjustment for small screens */
@media (max-width: 768px) {
    .keyboard {
        max-height: 150px; /* Smaller maximum height on small screens */
    }
    
    .key.black {
        width: 8%; /* Slightly wider on small screens for better touch targets */
    }
}

/* For very small screens */
@media (max-width: 480px) {
    .keyboard {
        max-height: 120px; /* Even smaller on very small screens */
    }
}
/* Make sure the black keys overflow is visible */

.key.pressed {
    background-color: #d4c6a8;
}

.key.black.pressed {
    background-color: #6b4e29;
}
        
        /* Voice monitoring */
        .voice-monitor {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #3f2101;
            border-radius: 4px;
            background-color: #f0e6d2;
        }
        
        .voice-item {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            background-color: #e0e0e0;
            border-radius: 3px;
            border: 1px solid #3f2101;
        }
        
        .active-voice {
            background-color: #8b4513;
            color: white;
        }
        
        /* File section styling */
        .file-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        input[type="file"] {
            background-color: #f0e6d2;
            border: 1px solid #3f2101;
            border-radius: 3px;
            padding: 5px;
        }
        
        /* ADSR graph visualization */
        .adsr-graph {
            height: 100px;
            width: 100%;
            border: 1px solid #3f2101;
            background-color: #f5f5dc;
            margin: 10px 0;
            position: relative;
        }
        
        .adsr-line {
            position: absolute;
            background-color: #8b4513;
            width: 2px;
            height: 100%;
            top: 0;
            left: 0;
        }
        
body {
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
/* Base knob style */
.knob.notched {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #e6e6e6;
    border: 1px solid #3f2101;
    position: absolute;
    top: 0;
    left: 0;
    cursor: grab;
    z-index: 2;
}

/* Notch marks around the knob */
.knob.notched::before {
    content: '';
    position: absolute;
    top: -4px;  /* Position outside the knob */
    left: -4px;
    width: 48px;  /* Larger than the knob */
    height: 48px;
    border-radius: 50%;
    background: conic-gradient(
        from 60deg,
        transparent 0deg 2deg,
        #3f2101 2deg 4deg,      /* -2 octave notch */
        transparent 4deg 58deg,
        #3f2101 58deg 60deg,    /* -1 octave notch */
        transparent 60deg 118deg,
        #3f2101 118deg 120deg,  /* 0 octave notch */
        transparent 120deg 178deg,
        #3f2101 178deg 180deg,  /* +1 octave notch */
        transparent 180deg 238deg,
        #3f2101 238deg 240deg,  /* +2 octave notch */
        transparent 240deg 360deg
    );
    opacity: 0.6;
    pointer-events: none;
    z-index: 1;
}

/* Indicator line */
.knob.notched::after {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 10px;
    background-color: #3f2101;
    transform-origin: bottom center;
    transform: translateX(-50%);
    z-index: 3;
}

.knob-container {
    position: relative;
    width: 40px;
    height: 40px;
    margin: 10px auto;
}
/* Fixed notch ring */
.knob-container::before {
    content: '';
    position: absolute;
    top: -4px;
    left: -4px;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: conic-gradient(
        from 240deg,
        #3f2101 0deg 2deg,      /* -2 octave notch */
        transparent 2deg 58deg,
        #3f2101 58deg 60deg,    /* -1 octave notch */
        transparent 60deg 118deg,
        #3f2101 118deg 120deg,  /* 0 octave notch */
        transparent 120deg 178deg,
        #3f2101 178deg 180deg,  /* +1 octave notch */
        transparent 180deg 238deg,
        #3f2101 238deg 240deg,  /* +2 octave notch */
        transparent 240deg 360deg
    );
    opacity: 0.6;
    pointer-events: none;
    z-index: 1;
}
.knob-value {
    font-size: 12px;
    margin-top: 4px;
    color: #3f2101;
}

.octave-control {
    display: flex;
    flex-direction: row;
    align-items: center;
    margin: 10px 0;
    position: relative;
    height: 120px;
}

.octave-slider {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(0%, 22%);
    margin: 35px 0;

}

.octave-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.octave-slider::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

.octave-ticks {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 100px;
    font-size: 12px;
    color: #3f2101;
    margin-left: -80px; /* Adjust space between slider and ticks */
}
/* Adjust the label position */
.octave-control label {
    position: absolute;
    bottom: -10px; /* Moved down by 10px */
    left: 50%;
    transform: translateX(-50%);
    font-size: 15px;
    color: #3f2101;
}
.octave-ticks span {
    line-height: 20px;
}
/* Update the ADSR module layout */
.module[style="grid-column: span 2;"] .module-title {
    margin-top: -5px; /* Adjust to move text up by 5px */
    margin-bottom: 14px;
    padding-top: 0;
    padding-bottom: 5px; /* Add padding-bottom to put the underline in the right spot */
    display: block;
}

.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 60px;
    height: 140px;
    position: relative;
    margin-bottom: 30px; /* Add space for the lower labels */
}

.slider-container label {
    position: absolute;
    bottom: -30px; /* Move labels much lower */
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-container span {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-group {
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    align-items: center;
    width: 100%;
    height: 170px;
    margin: 10px 0;
    padding-bottom: 30px; /* Increased padding for lower labels */
}
.module[style="grid-column: span 0;"] {
    display: flex;
    flex-direction: column;
    min-height: 250px;
    min-width: 400px; /* Add minimum width */
    padding: 15px;
}

.adsr-graph {
    width: 100%;
    height: 100px;
    min-height: 100px;
    border: 1px solid #3f2101;
    background-color: #f5f5dc;
    margin: 10px 0;
    position: relative;
    overflow: hidden; /* Prevent overflow */
}

.slider-group {
    display: flex;
    flex-direction: row;
    justify-content: space-evenly; /* Changed from space-around */
    align-items: center;
    width: 100%;
    height: 150px;
    margin: 10px 0;
}

.slider-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 60px; /* Fixed width for container */
    height: 140px;
    position: relative;
}

.slider-container input[type="range"] {
    width: 100px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-35px, 35px);
    margin: 35px 0;
}

.slider-container span {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

.slider-container label {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}
/* ADSR module styles */
.module[style="grid-column: span 0;"] {
    display: flex;
    flex-direction: column;
    width: 160px; /* Match graph width */
    min-width: 160px;
    padding: 15px;
    align-items: center;
}

.adsr-graph {
    width: 105%; /* Reduced from 100% to 80% */
    height: 80px;
    border: 1px solid #3f2101;
    background-color: #f5f5dc;
    margin-bottom: 20px;
    position: relative;
}

/* Values row */
.slider-values {
    display: flex;
    justify-content: space-between;
    width: 220px; /* Match slider group width */
    margin-bottom: 5px;
}

.slider-values span {
    font-size: 12px;
    color: #3f2101;
    width: 40px;
    text-align: center;
}

.slider-group {
    width: 160px; /* Match graph width */
    display: flex;
    justify-content: center;
    margin: 10px 0;
    gap: 7%;
}

.slider-group input[type="range"] {
    width: 120px; /* Reduced width */
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(0px, -50px); /* Adjusted translation */
}

.slider-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 28px;
    width: 16px;
    border-radius: 3px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    cursor: grab;
    margin-top: -12px;
}

.slider-group input[type="range"]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 2px;
}

/* Labels row */
.slider-labels {
    display: flex;
    justify-content: space-between;
    width: 220px;
    margin-top: -10px;
}

.slider-labels label {
    font-size: 12px;
    color: #3f2101;
    width: 40px;
    text-align: center;
}
/* ADSR container styles */
.module[style="grid-column: span 2;"] {
    display: flex;
    flex-direction: column;
    min-width: 170px;
    max-width: 170px;
    padding: 15px;
    align-items: center;
    
}
input[type="range"] {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

input[type="range"]:focus {
    outline: none;
}

input[type="range"]::-moz-focus-outer {
    border: 0;
}

.slider-group {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

.slider-container {
    -webkit-tap-highlight-color: transparent;
    outline: none;
}

* {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
}
/* Individual slider containers */
.slider-attack, .slider-decay, .slider-sustain, .slider-release {
    position: relative;
    width: 35px; /* Unchanged base width */
    height: 120px;
    margin: 0 7%;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none; /* Prevent text selection */
    pointer-events: none; /* Prevent container from capturing clicks */

}

/* Common slider styles */
.slider-group input[type="range"] {
    position: absolute;
    width: 160px;
    height: 30px;
    -webkit-appearance: none;
    background: transparent;
    transform: rotate(270deg) translate(-40%, 40%);
    /* Center the slider over its label */
    left: -89.5px;
    pointer-events: auto; /* Re-enable clicks for slider */
}

/* Values above sliders */
#attack-value, #decay-value, #sustain-value, #release-value {
    position: absolute;
    top: -20px;
    width: 35px;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

/* Labels below sliders */
.slider-labels {
    display: flex;
    justify-content: space-between;
    width: 180px;
    margin-top: 5px;
}

.slider-labels label {
    width: 35px;
    text-align: center;
    font-size: 12px;
    color: #3f2101;
}

/* Slider group containing all sliders */
.slider-group {
    display: flex;
    justify-content: center;
    width: 180px;
    margin: 10px 0;
    gap: 7%; /* Added gap property to match margin */
    
}
/* Add to your existing CSS */
.file-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin: 5px 0;
}

.custom-file-input {
    position: relative;
    width: 80%;
    height: 45px;
    overflow: hidden;
}

.custom-file-input input[type="file"] {
    position: absolute;
    font-size: 100px;
    opacity: 0;
    right: 0;
    top: 0;
    cursor: pointer;
}

.custom-file-input label {
    display: flex;
    align-items: center;
    justify-content: center;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 3px;
    padding: 8px;
    font-size: 12px;
    color: #3f2101;
    text-align: center;
    cursor: pointer;
    height: 32px;  /* Fixed height */
    min-height: 32px;
    width: 100%;
    box-sizing: border-box;
}

#file-status {
    font-size: 10px;
    color: #3f2101;
    margin-top: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 90%;
    text-align: center;
}
/* Add vertical switch styling */
.switch-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 10px 0;
}

.switch-label {
    font-size: 10px;
    margin-bottom: 5px;
    color: #3f2101;
    text-align: center;
}

/* Update vertical switch styling */
.vertical-switch {
    width: 20px;
    height: 40px;
    background: #e6e6e6;
    border: 1px solid #3f2101;
    border-radius: 10px;
    position: relative;
    cursor: grab;
}

.vertical-switch::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 18px;
    background: #d4c6a8;
    border: 1px solid #3f2101;
    border-radius: 8px;
    left: 1px;
    top: 1px;
    transition: top 0.1s;
}

.vertical-switch.active::after {
    top: 19px;
}

/* Mono controls container */
.mono-controls {
    width: 100%;
    transition: opacity 0.3s;
}

.legato-controls {
    width: 100%;
    transition: opacity 0.3s;
}

    </style>
</head>
<body>
    </style>
</head>
<body>
    <div class="container">
        
        <div class="synth-panel">
            
        <!-- Modified SAMPLER Module with Two Columns and Sample Selector -->
<div class="module sampler-module">
    <div class="module-title">SAMPLER</div>
    
    <!-- Two-column layout container -->
    <div class="sampler-columns">
      <!-- Left Column -->
      <div class="sampler-column">
        <div class="file-section">
          <div class="custom-file-input">
            <input type="file" id="audio-file" accept="audio/*">
            <label for="audio-file">Load Sample</label>
          </div>
        </div>
        <div class="knob" id="sample-volume-knob"></div>
        <label for="sample-volume-knob" style="text-align: center;">Volume</label>
        <div class="knob" id="sample-pitch-knob"></div>
        <label for="sample-pitch-knob" style="text-align: center;">Pitch</label>
      <!-- Add this knob to the right column of your sampler module -->
<div class="knob" id="sample-fade-knob"></div>
<label for="sample-fade-knob" style="text-align: center;">Fade</label>
    </div>
      
      <!-- Right Column -->
      <div class="sampler-column">
        <!-- Sample selector dropdown -->
        <div class="sample-selector-container">
          <button id="sample-selector-btn">Presets ▼</button>
          <div id="sample-dropdown" class="sample-dropdown">
            <div class="dropdown-item" data-sample="Dirty Bass.wav">Dirty Bass</div>
            <div class="dropdown-item" data-sample="Keys - Piano.wav">Piano</div>
            <div class="dropdown-item" data-sample="Noise.wav">Noise</div>
            <div class="dropdown-item" data-sample="Saw.wav">Saw</div>
          </div>
        </div>
        <div class="knob" id="sample-start-knob"></div>
        <label for="sample-start-knob" style="text-align: center;">Start</label>
        <div class="knob" id="sample-end-knob"></div>
        <label for="sample-end-knob" style="text-align: center;">End</label>
        <div class="knob" id="sample-crossfade-knob"></div>
        <label for="sample-crossfade-knob" style="text-align: center;">Crossfade</label>
      </div>
    </div>
  </div>
            <!-- OSC 1 Module -->
            <div class="module">
                <div class="module-title">OSC 1</div>
                <div class="wave-select-container">
                    <select class="wave-select" name="osc1-wave">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="saw">Saw</option>
                        <option value="square">Square</option>
                        <option value="pulse">Pulse</option>
                    </select>
                </div>
                <div class="knob" id="osc1-pwm-knob"></div>
                <label for="osc1-pwm-knob" style="text-align: center;">PWM</label>
                <div class="knob" id="osc1-gain-knob"></div>
                <label for="osc1-gain-knob" style="text-align: center;">Gain</label>
                <div class="octave-control">
                    <input type="range" class="octave-slider" min="-2" max="2" step="1" value="0">
                    <div class="octave-ticks">
                        <span>+2</span>
                        <span>+1</span>
                        <span>0</span>
                        <span>-1</span>
                        <span>-2</span>
                    </div>
                    <label>Octave</label>
                </div>
            </div>

            <!-- OSC 2 Module -->
            <div class="module">
                <div class="module-title">OSC 2</div>
                <div class="wave-select-container">
                    <select class="wave-select" name="osc2-wave">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="saw">Saw</option>
                        <option value="square">Square</option>
                        <option value="pulse">Pulse</option>
                    </select>
                </div>
                <div class="knob" id="osc2-pwm-knob"></div>
                <label for="osc2-pwm-knob" style="text-align: center;">PWM</label>
                <div class="knob" id="osc2-gain-knob"></div>
                <label for="osc2-gain-knob" style="text-align: center;">Gain</label>
                <div class="octave-control">
                    <input type="range" class="octave-slider" min="-2" max="2" step="1" value="0">
                    <div class="octave-ticks">
                        <span>+2</span>
                        <span>+1</span>
                        <span>0</span>
                        <span>-1</span>
                        <span>-2</span>
                    </div>
                    <label>Octave</label>
                </div>
            </div>

            

            <!-- ADSR Module -->
            <div class="module" style="grid-column: span 2;">
                <div class="module-title">ADSR Envelope</div>
                
                <div class="adsr-graph" id="adsr-visualization">
                    <div class="adsr-line"></div>
                </div>
            
                <div class="slider-group">
                    <div class="slider-attack">
                        <span id="attack-value">0</span>
                        <input type="range" id="attack" min="0" max="5" step="0.01" value="0">
                    </div>
                    <div class="slider-decay">
                        <span id="decay-value">0.1</span>
                        <input type="range" id="decay" min="0" max="5" step="0.01" value="0.1">
                    </div>
                    <div class="slider-sustain">
                        <span id="sustain-value">0.7</span>
                        <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
                    </div>
                    <div class="slider-release">
                        <span id="release-value">0.01</span>
                        <input type="range" id="release" min="0" max="5" step="0.01" value="0.01">
                    </div>
                </div>
                <div class="slider-labels">
                    <label>A</label>
                    <label>D</label>
                    <label>S</label>
                    <label>R</label>
                </div>
            </div>
            

<div class="module">
    <div class="module-title">MASTER</div>
    
    <!-- Voice Mode Switch -->
    <div class="switch-container">
        <label class="switch-label">POLY/MONO</label>
        <div class="vertical-switch" id="voice-mode-switch"></div>
    </div>
    
    <!-- Mono controls -->
    <div class="mono-controls">
        <!-- Trigger Mode Switch -->
        <div class="switch-container">
            <label class="switch-label">MULTI/LEGATO</label>
            <div class="vertical-switch" id="trigger-mode-switch"></div>
        </div>
        
        <!-- Portamento controls -->
        <div class="legato-controls">
            <div class="switch-container">
                <label class="switch-label">PORTA ON/OFF</label>
                <div class="vertical-switch" id="portamento-switch"></div>
            </div>
            
            <!-- Glide Time Knob -->
            <div class="knob" id="glide-time-knob"></div>
            <label for="glide-time-knob">GLIDE</label>
        </div>
    </div>
    
    <!-- Master Volume -->
    <div class="knob" id="master-volume-knob"></div>
    <label for="master-volume-knob">Volume</label>
</div>
    
   
      

        </div> <!-- End of synth-panel -->
        
        <!-- Keyboard -->
        <div class="keyboard" id="keyboard">
            <!-- Keys will be generated by JavaScript -->
        </div>
        
        <div class="voice-monitor">
            <h3>Active Voices: <span id="voice-count">0</span>/6</h3>
            <div id="voice-display"></div>
        </div>
    </div>

    <script>
        const D = x => document.getElementById(x);
        const TR2 = 2 ** (1.0 / 12.0);
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
        masterGain.connect(audioCtx.destination);


// Main keys (first + second octave)
const keys = [
  'Z','S','X','D','C','V','G','B','H','N','J','M',  // First octave
  'Q','2','W','3','E','R','5','T','6','Y','7','U'   // Second octave
];

// Extra punctuation → note index mapping (second octave)
const specialKeyMap = {
  ',': 12, // C
  '.': 14, // D
  '/': 16, // E
  'L': 13, // C#
  'l': 13, // Handle lowercase L
  ';': 15,  // D#
    // Third octave (C through G):
    'I': 24, // C
    "i": 24, // Handle lowercase I
  '9': 25, // C#
  'O': 26, // D
  "o": 26, // Handle lowercase O
  '0': 27, // D#
  'P': 28, // E
  "p": 28, // Handle lowercase P
  '[': 29, // F
  '=': 30, // F#
  ']': 31  // G
};

// Add this after the masterGain initialization
let currentVolume = 0.5; // Initial volume
masterGain.gain.setValueAtTime(currentVolume, audioCtx.currentTime, 0.01);
// Add these global variables at the top with other audio-related variables
// Add to your global variables
let currentSampleDetune = 0; // Range will be -1200 to +1200 cents
let lastPlayedNote = null;
let sampleSource = null;
let isPlaying = false;
let sampleStartPosition = 0; // 0-1 range representing portion of audio file
let sampleEndPosition = 1;   // 0-1 range (default to full sample)
let sampleCrossfadeAmount = 0; // 0-1 range for crossfade percentage
let isSampleLoopOn = false; // Will now be controlled by crossfade knob
let cachedCrossfadedBuffer = null;
let crossfadeUpdateTimer = null;
let sampleFadeInAmount = 0;
let sampleFadeOutAmount = 0;
let fadeProcessTimer = null;
let fadedBuffer = null;
let startUpdateTimer = null;
let endUpdateTimer = null;
let lastCachedStartPos = null;
let lastCachedEndPos = null;
let lastCachedCrossfade = null;
// Add at top with other global variables
sampleGainNode = audioCtx.createGain();
sampleGainNode.gain.value = 0.5;
// Update the createNote function to use a reference to the current gain value
let currentSampleGain = 0.5; // Add this with other global variables
let currentSamplePosition = 0; // Add this with other global variables

// Replace all knob-related code with this single implementation
function initializeKnob(knob, onChange) {
    let rotation = -150;
    let isDragging = false;
    let lastY;
    const defaultValue = 0.5;

    function resetToDefault() {
        rotation = -150 + (defaultValue * 300);
        knob.style.transform = `rotate(${rotation}deg)`;
        if (onChange) {
            onChange(defaultValue);
        }
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Apply different sensitivity based on shift key state
        const sensitivity = e.shiftKey ? 0.25 : 1.0;
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        // Range from -150 to +150 degrees
        const newRotation = Math.min(150, Math.max(-150, rotation + deltaY));
        
        if (newRotation !== rotation) {
            rotation = newRotation;
            knob.style.transform = `rotate(${rotation}deg)`;
            
            if (onChange) {
                const normalizedValue = (rotation + 150) / 300;
                onChange(normalizedValue);
            }
        }
        
        e.preventDefault();
        e.stopPropagation();
    }

    function handleMouseUp() {
        isDragging = false;
        knob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }

    // Add click handlers for reset functionality
    knob.addEventListener('click', (e) => {
        if (e.altKey) {
            resetToDefault();
        }
    });

    knob.addEventListener('dblclick', () => {
        resetToDefault();
    });

    knob.addEventListener('mousedown', (e) => {
        if (!e.altKey) { // Only start dragging if not alt-clicking
            isDragging = true;
            lastY = e.clientY;
            knob.style.cursor = 'grabbing';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        e.preventDefault();
    });

    return {
        getValue: () => (rotation + 150) / 300,
        setValue: (value) => {
            const newRotation = (value * 300) - 150;
            rotation = Math.min(150, Math.max(-150, newRotation));
            knob.style.transform = `rotate(${rotation}deg)`;
        }
    };
}


// Place this code right after the initializeKnob function and before any initialization calls

function initializeNotchedKnob(knob, onChange) {
    let rotation = 0;
    let isDragging = false;
    let lastY;
    const degreesPerStep = 60; // 240 degrees total / 4 steps
    const steps = [-2, -1, 0, 1, 2]; // Octave values

    function snapToNotch(rotation) {
        const step = Math.round(rotation / degreesPerStep);
        const limitedStep = Math.max(-2, Math.min(2, step));
        return limitedStep * degreesPerStep;
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        const sensitivity = 1.5;
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        let newRotation = rotation + deltaY;
        let snappedRotation = snapToNotch(newRotation);
        
        if (snappedRotation !== rotation) {
            rotation = snappedRotation;
            knob.style.transform = `rotate(${rotation}deg)`;
            
            if (onChange) {
                const octaveValue = -Math.round(rotation / degreesPerStep);
                onChange(octaveValue);
            }
        }
        
        e.preventDefault();
        e.stopPropagation();
    }

    function handleMouseUp() {
        isDragging = false;
        knob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }

    knob.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        knob.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });

    return {
        getValue: () => -Math.round(rotation / degreesPerStep),
        setValue: (octave) => {
            rotation = -octave * degreesPerStep;
            knob.style.transform = `rotate(${rotation}deg)`;
        }
    };
}
// Function to process the buffer with fade in/out before crossfades
// Function to process the buffer with fade in/out after applying start/end points
// Clean up the processing order and fade handling functions

/**
 * Creates a properly loopable buffer with crossfades baked in.
 */

// Modify the beginning of createCrossfadedBuffer
function createCrossfadedBuffer(originalBuffer, startFraction, endFraction, crossfadeAmount) {
  console.log("createCrossfadedBuffer called:", { startFraction, endFraction, crossfadeAmount });
  try {
    // Basic parameter checks
    if (!originalBuffer || originalBuffer.length === 0) return null;
    if (crossfadeAmount <= 0.00001) return null;
    if (startFraction >= endFraction) return null;
    
    // Use faded buffer if available, otherwise use original
    const sourceBuffer = fadedBuffer || originalBuffer;
    console.log("Using " + (fadedBuffer ? "faded" : "original") + " buffer for crossfading");
    
    const sampleRate = sourceBuffer.sampleRate;
    const channels = sourceBuffer.numberOfChannels;
    const totalSamples = sourceBuffer.length;
    
    // Calculate sample indices and loop length
    let originalStartSample = Math.floor(startFraction * totalSamples);
    const endSamplePos = Math.floor(endFraction * totalSamples);
    let loopLength = endSamplePos - originalStartSample;
    
    // IMPORTANT: Check minimum sample length early
    if (loopLength < 2) {
      console.log("Sample too short for crossfade processing:", loopLength, "samples");
      return null;
    }
    
    // IMPORTANT: Define startSamplePos here, before it's used in any branching code
    let startSamplePos = originalStartSample;
    
    if (crossfadeAmount < 0.03) {
      console.log("Using zero-crossing alignment for small crossfade amount");
      
  // Get the first channel data for analysis
  const channel0Data = sourceBuffer.getChannelData(0);
  
  // Search window in samples (20ms)
  const searchWindow = Math.ceil(sampleRate * 0.02);
  
  // Find zero crossings and their slopes
  const endCrossings = [];
  const startCrossings = [];
  
  // Look for both positive and negative zero crossings near end
  for (let i = Math.max(0, endSamplePos - searchWindow); i < Math.min(endSamplePos + searchWindow, totalSamples - 1); i++) {
    // Positive crossing (negative to positive)
    if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
      endCrossings.push({
        position: i,
        slope: channel0Data[i + 1] - channel0Data[i],
        type: 'positive'
      });
    }
    // Negative crossing (positive to negative)
    else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
      endCrossings.push({
        position: i,
        slope: channel0Data[i + 1] - channel0Data[i],
        type: 'negative'
      });
    }
  }
  
  // Look for both positive and negative zero crossings near start
  for (let i = Math.max(0, startSamplePos - searchWindow); i < Math.min(startSamplePos + searchWindow, totalSamples - 1); i++) {
    // Positive crossing (negative to positive)
    if (channel0Data[i] <= 0 && channel0Data[i + 1] > 0) {
      startCrossings.push({
        position: i,
        slope: channel0Data[i + 1] - channel0Data[i],
        type: 'positive'
      });
    }
    // Negative crossing (positive to negative)
    else if (channel0Data[i] >= 0 && channel0Data[i + 1] < 0) {
      startCrossings.push({
        position: i,
        slope: channel0Data[i + 1] - channel0Data[i],
        type: 'negative'
      });
    }
  }
  
  console.log(`Found ${endCrossings.length} zero crossings near end and ${startCrossings.length} near start`);
  
  // Default to original positions if no crossings found
  let endZeroCrossing = endSamplePos;
  let startZeroCrossing = startSamplePos;
  
  // Find best matching pair of zero crossings (match type and closest slope)
  if (endCrossings.length > 0 && startCrossings.length > 0) {
    let bestMatch = { score: -Infinity, start: null, end: null };
    
    // Compare each pair
    for (const end of endCrossings) {
      for (const start of startCrossings) {
        // Perfect score for matching types (both positive or both negative)
        const typeScore = (end.type === start.type) ? 10 : -5;
        
        // Slope similarity score (closer to 0 is better)
        const slopeScore = 10 - Math.min(10, Math.abs(end.slope - start.slope) * 100);
        
        // Combined score
        const score = typeScore + slopeScore;
        
        if (score > bestMatch.score) {
          bestMatch = { 
            score, 
            start: start.position, 
            end: end.position 
          };
        }
      }
    }
    
    console.log(`Best zero crossing match score: ${bestMatch.score}`);
    
    // Only use the match if it's reasonably good
    if (bestMatch.score > 0) {
      startZeroCrossing = bestMatch.start;
      endZeroCrossing = bestMatch.end;
      console.log(`Using matched zero crossings: start=${startZeroCrossing}, end=${endZeroCrossing}`);
    }
  }
  
  // Use these zero crossings to create a perfectly looped buffer
  loopLength = endZeroCrossing - startZeroCrossing;
  if (loopLength <= 0) {
    console.log("Invalid loop length after zero crossing adjustment - using original positions");
    startZeroCrossing = startSamplePos;
    endZeroCrossing = endSamplePos;
    loopLength = endZeroCrossing - startZeroCrossing;
  }
  
  // Create buffer with aligned zero crossings
  const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
  
  for (let channel = 0; channel < channels; channel++) {
    const sourceData = sourceBuffer.getChannelData(channel);
    const newData = newBuffer.getChannelData(channel);
    
    for (let i = 0; i < loopLength; i++) {
      newData[i] = sourceData[startZeroCrossing + i];
    }
  }
  
  console.log(`Created phase-aligned looped buffer with zero crossings: ${(loopLength / sampleRate).toFixed(3)}s loop`);
  return { buffer: newBuffer, adjustedStartFraction: startZeroCrossing / totalSamples };
}
    
    // For larger crossfade amounts, use the original correlation-based crossfade logic
    const minFadeSamples = Math.max(Math.round(sampleRate * 0.02), Math.round(loopLength * 0.02));
    let fadeLengthSamples;
    
    if (crossfadeAmount < 0.1) {
      fadeLengthSamples = Math.max(minFadeSamples, Math.round(sampleRate * 0.02));
    } else {
      fadeLengthSamples = Math.floor(loopLength * crossfadeAmount * 0.2);
      fadeLengthSamples = Math.max(fadeLengthSamples, minFadeSamples);
      fadeLengthSamples = Math.min(fadeLengthSamples, Math.floor(loopLength / 3));
    }
    
    console.log("Fade length (samples):", fadeLengthSamples, "Time:", (fadeLengthSamples/sampleRate).toFixed(4), "sec");
    

    if (startSamplePos < fadeLengthSamples) {
      console.log(`Not enough lead-in samples; adjusting startSample from ${startSamplePos} to ${fadeLengthSamples}`);
      startSamplePos = fadeLengthSamples;
      loopLength = endSamplePos - startSamplePos;
    }
    
    // Find optimal crossfade points using waveform similarity
    const searchWindowMs = 20; 
    const searchWindow = Math.ceil(sampleRate * searchWindowMs / 1000);
    
    let bestMatchOffset = 0;
    let bestCorrelation = -1;
    
    // Only analyze first channel for finding the best match point
    const channel0Data = sourceBuffer.getChannelData(0);
    
    for (let offset = -searchWindow; offset <= searchWindow; offset++) {
      if (startSamplePos + offset < fadeLengthSamples || endSamplePos + offset >= totalSamples) {
        continue;
      }
      
      let correlation = 0;
      let endRegionEnergy = 0;
      let startRegionEnergy = 0;
      
      for (let i = 0; i < fadeLengthSamples; i++) {
        const endSampleValue = channel0Data[endSamplePos - fadeLengthSamples + i]; 
        const startSampleValue = channel0Data[startSamplePos - fadeLengthSamples + i + offset];
        
        correlation += endSampleValue * startSampleValue;
        endRegionEnergy += endSampleValue * endSampleValue;
        startRegionEnergy += startSampleValue * startSampleValue;
      }
      
      if (endRegionEnergy > 0 && startRegionEnergy > 0) {
        correlation = correlation / (Math.sqrt(endRegionEnergy) * Math.sqrt(startRegionEnergy));
        
        if (correlation > bestCorrelation) {
          bestCorrelation = correlation;
          bestMatchOffset = offset;
        }
      }
    }
    
    console.log(`Found best match with correlation ${bestCorrelation.toFixed(3)} at offset ${bestMatchOffset}`);
    
    const adjustedStart = Math.max(fadeLengthSamples, startSamplePos + bestMatchOffset);
    const fadeInStart = adjustedStart - fadeLengthSamples;
    loopLength = endSamplePos - adjustedStart;
    
    console.log(`Adjusted start sample: ${adjustedStart}, fadeInStart: ${fadeInStart}`);
    
    const newBuffer = audioCtx.createBuffer(channels, loopLength, sampleRate);
    
    for (let channel = 0; channel < channels; channel++) {
      const origData = sourceBuffer.getChannelData(channel);
      const newData = newBuffer.getChannelData(channel);
      
      for (let i = 0; i < loopLength; i++) {
        newData[i] = origData[adjustedStart + i];
      }
      
      // Apply crossfade at loop end
      for (let i = 0; i < fadeLengthSamples; i++) {
        const idx = loopLength - fadeLengthSamples + i;
        if (idx >= 0) { 
          const t = i / fadeLengthSamples;
          
          // Equal power crossfade
          const fadeOutFactor = Math.cos(t * Math.PI/2);
          const fadeInFactor = Math.sin(t * Math.PI/2);
          
          const loopEndSample = newData[idx];
          const leadInSample = origData[fadeInStart + i];
          
          newData[idx] = (loopEndSample * fadeOutFactor) + (leadInSample * fadeInFactor);
        }
      }
    }
    
    console.log(`Created crossfaded buffer: ${(loopLength / sampleRate).toFixed(3)}s loop`);
    return { buffer: newBuffer, adjustedStartFraction: adjustedStart / totalSamples };
  } catch (e) {
    console.error("Error creating crossfaded buffer:", e);
    return null;
  }
}
// Knob initializations (only one set)
const knobInitializations = {
      
    'osc1-pwm-knob': (value) => {
        const tooltip = createTooltipForKnob('osc1-pwm-knob', value);
        tooltip.textContent = `PWM: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        console.log('OSC1 PWM:', value.toFixed(2));
    },
    'osc1-gain-knob': (value) => {
        const tooltip = createTooltipForKnob('osc1-gain-knob', value);
        tooltip.textContent = `Gain: ${value.toFixed(2)}`;
        tooltip.style.opacity = '1';
        console.log('OSC1 Gain:', value.toFixed(2));
    },
    'osc2-pwm-knob': (value) => {
        const tooltip = createTooltipForKnob('osc2-pwm-knob', value);
        tooltip.textContent = `PWM: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        console.log('OSC2 PWM:', value.toFixed(2));
    },
    'osc2-gain-knob': (value) => {
        const tooltip = createTooltipForKnob('osc2-gain-knob', value);
        tooltip.textContent = `Gain: ${value.toFixed(2)}`;
        tooltip.style.opacity = '1';
        console.log('OSC2 Gain:', value.toFixed(2));
    },
    'master-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('master-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        masterGain.gain.setTargetAtTime(value, audioCtx.currentTime, 0.01);
        console.log('Master Volume:', value.toFixed(2));
    },
    'sample-volume-knob': (value) => {
        const tooltip = createTooltipForKnob('sample-volume-knob', value);
        tooltip.textContent = `Volume: ${(value * 100).toFixed(0)}%`;
        tooltip.style.opacity = '1';
        currentSampleGain = value;
        // Update all active notes' sample gain
        Object.values(activeNotes).forEach(note => {
            if (note && note.sampleNode) {
                note.sampleNode.gain.value = currentSampleGain;
            }
        });
        console.log('Sample Gain:', value.toFixed(2));
    },
    // ... existing knobs ...
    'sample-pitch-knob': (value) => {
        // Convert 0-1 range to -1200 to +1200 cents
        currentSampleDetune = (value * 2400) - 1200;
    
    // Show and update tooltip
    const tooltip = document.getElementById('pitch-tooltip') || createTooltip();
    tooltip.textContent = `${currentSampleDetune.toFixed(0)} cents`;
    tooltip.style.opacity = '1';
    
    // Update all active notes' sample pitch
    Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
            note.source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
        }
    });
    
    console.log('Sample Pitch:', currentSampleDetune.toFixed(0) + ' cents');
},

// Add these new knob initializations in the knobInitializations object
'sample-start-knob': (value) => {
    // Ensure start position is always less than end position
    const maxStart = Math.min(value, sampleEndPosition - 0.01);
    sampleStartPosition = maxStart;
    
    // Add this line to process fades when start position changes
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-start-knob', value);
    tooltip.textContent = `Start: ${(sampleStartPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample Start:', (sampleStartPosition * 100).toFixed(0) + '%. Scheduling update...');
    
    // TESTING: Force create a new crossfaded buffer if enabled
    if (audioBuffer && sampleCrossfadeAmount > 0.01) {
        console.log("Directly creating crossfaded buffer after start change");
        const result = createCrossfadedBuffer(audioBuffer, sampleStartPosition, sampleEndPosition, sampleCrossfadeAmount);
        if (result && result.buffer) {
            console.log("Successfully created crossfaded buffer after start change");
            cachedCrossfadedBuffer = result.buffer;
            lastCachedStartPos = sampleStartPosition;
            lastCachedEndPos = sampleEndPosition;
            lastCachedCrossfade = sampleCrossfadeAmount;
        } else {
            console.log("Failed to create crossfaded buffer after start change");
        }
    }
    
    // Debounce update for sample start knob
    if (startUpdateTimer) { clearTimeout(startUpdateTimer); }
    startUpdateTimer = setTimeout(() => {
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping start update.`);
                    return;
                }
                
                console.log(`Processing note ${note.id} after start change`);
                // Force re-processing - important!
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                // This is crucial: if looping is on, set up crossfade before updating parameters
                if (isSampleLoopOn) {
                    note.looping = true; // Force looping flag to true!
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        startUpdateTimer = null;
    }, 100);
},

'sample-end-knob': (value) => {
    // Ensure end position is always greater than start position
    const minEnd = Math.max(value, sampleStartPosition + 0.01);
    sampleEndPosition = minEnd;
    
    // Add this line to process fades when end position changes
    updateSampleProcessing();
    
    const tooltip = createTooltipForKnob('sample-end-knob', value);
    tooltip.textContent = `End: ${(sampleEndPosition * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    
    console.log('Sample End:', (sampleEndPosition * 100).toFixed(0) + '%. Scheduling update...');
    
    // TESTING: Force create a new crossfaded buffer if enabled
    if (audioBuffer && sampleCrossfadeAmount > 0.01) {
        console.log("Directly creating crossfaded buffer after end change");
        const result = createCrossfadedBuffer(audioBuffer, sampleStartPosition, sampleEndPosition, sampleCrossfadeAmount);
        if (result && result.buffer) {
            console.log("Successfully created crossfaded buffer after end change");
            cachedCrossfadedBuffer = result.buffer;
            lastCachedStartPos = sampleStartPosition;
            lastCachedEndPos = sampleEndPosition;
            lastCachedCrossfade = sampleCrossfadeAmount;
        } else {
            console.log("Failed to create crossfaded buffer after end change");
        }
    }
    
    // Debounce update for sample end knob
    if (endUpdateTimer) { clearTimeout(endUpdateTimer); }
    endUpdateTimer = setTimeout(() => {
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                // Skip update if note is held
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping end update.`);
                    return;
                }
                
                console.log(`Processing note ${note.id} after end change`);
                // Force re-processing - important!
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                // This is crucial: if looping is on, set up crossfade before updating parameters
                if (isSampleLoopOn) {
                    note.looping = true; // Force looping flag to true!
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        endUpdateTimer = null;
    }, 100);
},
'sample-crossfade-knob': (value) => {
    const tooltip = createTooltipForKnob('sample-crossfade-knob', value);
    tooltip.textContent = `Crossfade: ${(value * 100).toFixed(0)}%`;
    tooltip.style.opacity = '1';
    sampleCrossfadeAmount = value;
    isSampleLoopOn = value > 0.01;
    
    // If enabling crossfade, clear any existing fades
    if (value > 0.01) {
        // Reset fade values when enabling crossfade
        sampleFadeInAmount = 0;
        sampleFadeOutAmount = 0;
        
        // Update the fade knob position to center (no fade)
        const fadeKnob = D('sample-fade-knob');
        if (fadeKnob) {
            const control = initializeKnob(fadeKnob, knobInitializations['sample-fade-knob']);
            control.setValue(0.5);
        }
    }
    // Process with any updated settings
    updateSampleProcessing();
    
    


    // Regular debounced update
    if (crossfadeUpdateTimer) { clearTimeout(crossfadeUpdateTimer); }
    crossfadeUpdateTimer = setTimeout(() => {
        console.log("CROSSFADE UPDATE TIMER FIRED with", Object.keys(activeNotes).length, "active notes");
        Object.values(activeNotes).forEach(note => {
            if (note && note.source) {
                console.log(`Processing note ${note.id}, held: ${heldNotes.includes(note.noteNumber)}`);
                // Skip held notes
                if (heldNotes.includes(note.noteNumber)) {
                    console.log(`Note ${note.id} is held; skipping crossfade update.`);
                    return;
                }
                
                console.log(`Forcing re-processing for note ${note.id}`);
                // Force re-processing - important!
                note.usesProcessedBuffer = false;
                note.crossfadeActive = false;
                
                // This is crucial: first create the crossfaded buffer, then update the note
                if (isSampleLoopOn) {
                    note.looping = true; // Force looping flag to true!
                    setupLoopCrossfade(note);
                }
                updateSamplePlaybackParameters(note);
            }
        });
        crossfadeUpdateTimer = null;
    }, 100);
},
'sample-fade-knob': (value) => {
    // Convert 0-1 range to -0.5 to 0.5 range
    const fadeValue = value * 2 - 1;
    
    // Create tooltip
    const tooltip = createTooltipForKnob('sample-fade-knob', value);
    
    // If crossfade/loop is on, disable fade functionality completely
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        tooltip.textContent = `Fade (disabled)`;
        tooltip.style.opacity = '1';
        console.log("Fade knob ignored - crossfade is active");
        return; // Exit early - don't process fades when crossfade is active
    }
    
    // Different text based on direction
    if (fadeValue < 0) {
        // Fade out (left side)
        const fadeOutPercent = Math.abs(fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade Out: ${fadeOutPercent}%`;
        console.log(`Setting fade OUT to ${fadeOutPercent}%`);
    } else if (fadeValue > 0) {
        // Fade in (right side)
        const fadeInPercent = (fadeValue * 100).toFixed(0);
        tooltip.textContent = `Fade In: ${fadeInPercent}%`;
        console.log(`Setting fade IN to ${fadeInPercent}%`);
    } else {
        // Center position
        tooltip.textContent = `No Fade`;
        console.log("Resetting fades to 0");
    }
    tooltip.style.opacity = '1';
    
    // Store values for processing
    sampleFadeInAmount = Math.max(0, fadeValue);
    sampleFadeOutAmount = Math.abs(Math.min(0, fadeValue));
    
    console.log(`Fade control values: fadeIn=${sampleFadeInAmount.toFixed(2)}, fadeOut=${sampleFadeOutAmount.toFixed(2)}`);
    
    // Process the fade changes
    updateSampleProcessing();
},
'glide-time-knob': (value) => {
    const tooltip = createTooltipForKnob('glide-time-knob', value);
    tooltip.textContent = `${(value * 2000).toFixed(0)}ms`;
    tooltip.style.opacity = '1';
    glideTime = value * 2; // 0-2 seconds range
    console.log('Glide Time:', (value * 2000).toFixed(0) + 'ms');
},
};
/**
 * Updates existing note playback parameters.
 * For crossfaded loops, if not already using the processed buffer,
 * this will create a new note and fade out the old one.
 */
 function updateSamplePlaybackParameters(note) {
  if (!note || !audioBuffer) return note;
  if (note.isBeingUpdated) return note;
  if (note.state === "releasing") {
    console.log("updateSamplePlaybackParameters: Note", note.id, "is releasing; skipping update.");
    return note;
  }
  note.isBeingUpdated = true;
  
  // Reset flags to force new settings to take hold
  note.crossfadeActive = false;
  note.usesProcessedBuffer = false;
  
  try {
    if (sampleCrossfadeAmount > 0.01) {
      console.log("updateSamplePlaybackParameters: Creating replacement note with crossfade for note", note.id);
      const replacementNote = createNote(
        note.noteNumber,
        audioBuffer,
        audioCtx,
        masterGain
      );
      if (replacementNote) {
        replacementNote.gainNode.gain.value = note.gainNode.gain.value;
        quickFadeOut(note, 0.03);
        note = replacementNote;
        console.log("updateSamplePlaybackParameters: Replaced note", note.id, "with crossfaded version");
      }
    } else {
      if (note.source && note.looping) {
        note.source.loop = isSampleLoopOn;
        note.source.loopStart = sampleStartPosition * audioBuffer.duration;
        note.source.loopEnd = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: Updated loop points for note", note.id);
      }
      if (
        !note.looping ||
        Math.abs(note.sampleStartPosition - sampleStartPosition * audioBuffer.duration) > 0.01
      ) {
        console.log("updateSamplePlaybackParameters: Creating new source for note", note.id);
        const newSource = audioCtx.createBufferSource();
        newSource.buffer = audioBuffer;
        newSource.loop = isSampleLoopOn;
        newSource.playbackRate.value = note.source.playbackRate.value;
        newSource.detune.value = currentSampleDetune;
        if (isSampleLoopOn) {
          newSource.loopStart = sampleStartPosition * audioBuffer.duration;
          newSource.loopEnd = sampleEndPosition * audioBuffer.duration;
        }
        note.source.disconnect();
        newSource.connect(note.sampleNode);
        newSource.start(0, sampleStartPosition * audioBuffer.duration);
        setTimeout(() => { 
          try { note.source.stop(); } catch (e) {} 
        }, 30);
        note.source = newSource;
        note.sampleStartPosition = sampleStartPosition * audioBuffer.duration;
        note.sampleEndPosition = sampleEndPosition * audioBuffer.duration;
        console.log("updateSamplePlaybackParameters: New source set for note", note.id);
      }
    }
  } finally {
    note.isBeingUpdated = false;
  }
  return note;
}
// Modify the beginning of createNote to use fadedBuffer
function createNote(noteNumber, buffer, audioCtx, destination) {
    const noteId = `${noteNumber}_${Date.now()}`;
    
    // Create gain nodes
    const gainNode = audioCtx.createGain();
    const sampleNode = audioCtx.createGain();
    gainNode.gain.value = 0.5;
    sampleNode.gain.value = currentSampleGain;
    
    const source = audioCtx.createBufferSource();
    
    let useOriginalBuffer = true;
    let sourceBuffer;
    
    // First decide which buffer to use
    if (isSampleLoopOn && sampleCrossfadeAmount > 0.01 && cachedCrossfadedBuffer) {
        sourceBuffer = cachedCrossfadedBuffer;
        useOriginalBuffer = false;
        console.log("Creating note using crossfaded buffer");
    } else {
        sourceBuffer = fadedBuffer || buffer;
        useOriginalBuffer = sourceBuffer === buffer;
        console.log("Creating note with " + (fadedBuffer ? "faded" : "original") + " buffer");
    }
    
    // Set the buffer
    source.buffer = sourceBuffer;
    
    // Set playback speed for note pitch
    source.playbackRate.value = TR2 ** (noteNumber - 12);
    source.detune.setValueAtTime(currentSampleDetune, audioCtx.currentTime);
    
    // Connect nodes
    source.connect(sampleNode);
    sampleNode.connect(gainNode);
    gainNode.connect(destination);
    
    // Set exact loop points if using original buffer
    if (useOriginalBuffer) {
        if (isSampleLoopOn) {
            source.loop = true;
            source.loopStart = sampleStartPosition * buffer.duration;
            source.loopEnd = sampleEndPosition * buffer.duration;
            console.log(`Setting loop points: ${source.loopStart.toFixed(3)}s to ${source.loopEnd.toFixed(3)}s`);
        }
    } else {
        // For processed buffer, loop the entire thing if looping is on
        source.loop = isSampleLoopOn;
    }
    
    // Create note object
    const note = {
        id: noteId,
        noteNumber,
        source,
        gainNode,
        sampleNode,
        startTime: audioCtx.currentTime,
        state: "starting",
        scheduledEvents: [],
        sampleStartPosition: useOriginalBuffer ? sampleStartPosition * buffer.duration : 0,
        sampleEndPosition: useOriginalBuffer ? sampleEndPosition * buffer.duration : sourceBuffer.duration,
        looping: isSampleLoopOn,
        usesProcessedBuffer: !useOriginalBuffer,
        crossfadeActive: !useOriginalBuffer && isSampleLoopOn && sampleCrossfadeAmount > 0.01
    };
    
    // Start playback - only call start() ONCE
    // Schedule stop if not looping using the original duration
    // For processed buffers, always start at the beginning
source.start(0);
if (!isSampleLoopOn) {
  const originalDuration = (sampleEndPosition - sampleStartPosition) * buffer.duration;
  const safetyMargin = 0.1; // additional time to ensure full playback
  const playDuration = originalDuration + safetyMargin;
  console.log(`Final play duration with margin: ${playDuration.toFixed(3)}s`);

  if (playDuration > 0.005) {
    // Instead of having a processed (shortened) buffer, use the original trimmed sample
    // and apply the fade-out via the gain node over the full playback duration.
    const fadeOutTime = 0.05; // your desired fade length
    const stopTime = audioCtx.currentTime + playDuration;
    
    // Hold the gain steady until (stopTime - fadeOutTime) and then ramp to zero at stopTime
    sampleNode.gain.setValueAtTime(currentSampleGain, stopTime - fadeOutTime);
    sampleNode.gain.linearRampToValueAtTime(0, stopTime);
    
    source.stop(stopTime + 0.05);
  }
} else {
   
    
    // Schedule stop if not looping
    if (!isSampleLoopOn) {
        // IMPORTANT FIX: Use the original calculation for duration
        const originalDuration = (sampleEndPosition - sampleStartPosition) * buffer.duration;
        
        // Debug: Compare the two duration calculations
        console.log(`DURATION DEBUG: Using original: ${originalDuration.toFixed(3)}s vs. processed: ${sourceBuffer.duration.toFixed(3)}s`);
        
        // Use the LONGER duration to ensure full playback
        const actualDuration = Math.max(originalDuration, sourceBuffer.duration);
        const safetyMargin = 0.1; // Increased safety margin to 100ms 
        const playDuration = actualDuration + safetyMargin;
        
        console.log(`Final play duration with margin: ${playDuration.toFixed(3)}s`);
        
        if (playDuration > 0.005) {
            // For faded buffers, we need a longer fadeout to prevent clicks
            const fadeOut = 0.05; // Increased from 0.03 to 0.05 seconds
            const stopTime = audioCtx.currentTime + playDuration;
            
            // Hold the gain steady until very close to the end
            sampleNode.gain.setValueAtTime(currentSampleGain, stopTime - fadeOut);
            sampleNode.gain.linearRampToValueAtTime(0, stopTime);
            
            // Stop slightly later to ensure full playback
            source.stop(stopTime + 0.05); // Increased from 0.02 to 0.05
        }
    }
}
    
    // Store the note
    activeNotes[noteId] = note;
    
    return note;
}
/**
 * Sets up loop crossfade without recursion.
 * (Do not call updateSamplePlaybackParameters or createNote here.)
 */


// Update the DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', () => {
    // Initialize all regular knobs
    Object.entries(knobInitializations).forEach(([id, callback]) => {
        const knob = D(id);
        if (knob) {
            const control = initializeKnob(knob, callback);
            control.setValue(0.5);
        }
    });

    // Initialize octave knobs
    ['osc1-octave-knob', 'osc2-octave-knob'].forEach(id => {
        const knob = D(id);
        const valueId = id.replace('-knob', '-value');
        if (knob) {
            const control = initializeNotchedKnob(knob, (value) => {
                D(valueId).textContent = value > 0 ? `+${value}` : value;
                console.log(`${id} octave:`, value);
            });
            control.setValue(0);
        }
    });
});

// Remove any other knob initialization code
        const keyStates = {};
        keys.forEach(key => keyStates[key] = false);
// Add to global variables

const MAX_MONO = 1;
        let audioBuffer = null;
        const MAX_POLYPHONY = 6;
        const activeVoices = []; // FIFO queue of active notes with their key info
        const activeNotes = {}; // Stores active notes
        const playingNotes = [];
        let playingNoteCount = 0;

        // Generate piano keyboard
        function generateKeyboard() {
            
    const keyboard = D('keyboard');
    keyboard.innerHTML = '';
    
    // Create white keys first
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                      'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
    
    for (let i = 0; i < whiteKeys.length; i++) {
        const key = document.createElement('div');
        key.className = 'key';
        // Map to the correct index in the keys array
        const keyIndex = getWhiteKeyIndex(i);
        key.dataset.noteIndex = keyIndex;
        keyboard.appendChild(key);
        
        // Add mouse events
        key.addEventListener('mousedown', () => {
            noteOn(parseInt(key.dataset.noteIndex));
            key.classList.add('pressed');
        });
        
        key.addEventListener('mouseup', () => {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        });
        
        key.addEventListener('mouseleave', () => {
            if (key.classList.contains('pressed')) {
                noteOff(parseInt(key.dataset.noteIndex));
                key.classList.remove('pressed');
            }
        });
    }
  // Add this after your existing initializeKnob function
  function initializeNotchedKnob(knob, onChange) {
    let rotation = 0;
    let isDragging = false;
    let lastY;
    const degreesPerStep = 60;

    function snapToNotch(rotation) {
        const steps = Math.round(rotation / degreesPerStep);
        const limitedSteps = Math.max(-2, Math.min(2, steps));
        return limitedSteps * degreesPerStep;
    }

    function handleMouseMove(e) {
        if (!isDragging) return;
        
        const sensitivity = 1.0; // Increased sensitivity
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        let newRotation = rotation + deltaY;
        newRotation = snapToNotch(newRotation);
        
        if (newRotation !== rotation) {
            rotation = newRotation;
            knob.style.transform = `rotate(${rotation}deg)`;
            
            if (onChange) {
                // Convert rotation to octave value (-2 to +2)
                const octaveValue = Math.round(-rotation / degreesPerStep);
                onChange(octaveValue);
            }
        }
        
        e.preventDefault();
        e.stopPropagation();
    }

    function handleMouseUp() {
        isDragging = false;
        knob.style.cursor = 'grab';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }

    knob.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        knob.style.cursor = 'grabbing';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });

    return {
        getValue: () => Math.round(-rotation / degreesPerStep),
        setValue: (octave) => {
            rotation = -octave * degreesPerStep;
            knob.style.transform = `rotate(${rotation}deg)`;
        }
    };
}

// Replace the octave initialization code with this
document.addEventListener('DOMContentLoaded', () => {
    // Initialize octave sliders
    ['osc1', 'osc2'].forEach(id => {
        const slider = document.querySelector(`#${id}-octave-slider`);
        if (slider) {
            slider.addEventListener('input', (e) => {
                console.log(`${id.toUpperCase()} Octave:`, e.target.value);
            });
        }
    });
});
// Update the black keys creation in generateKeyboard
const blackKeys = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // Positions for all black keys

blackKeys.forEach((position) => {
    const key = document.createElement('div');
    key.className = 'key black';
    const keyIndex = getBlackKeyIndex(position);
    key.dataset.noteIndex = keyIndex;
    keyboard.appendChild(key);
    
    // Add mouse events
    key.addEventListener('mousedown', () => {
        noteOn(parseInt(key.dataset.noteIndex));
        key.classList.add('pressed');
    });
    
    key.addEventListener('mouseup', () => {
        noteOff(parseInt(key.dataset.noteIndex));
        key.classList.remove('pressed');
    });
    
    key.addEventListener('mouseleave', () => {
        if (key.classList.contains('pressed')) {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        }
    });
})};

// Helper functions to map key positions to note indices
function getWhiteKeyIndex(position) {
    // Maps white key position to the corresponding index in the keys array
    const whiteKeyMap = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B positions
    const octave = Math.floor(position / 7);
    const noteInOctave = position % 7;
    return whiteKeyMap[noteInOctave] + (octave * 12);
}

function getBlackKeyIndex(position) {
    // Black key mapping for the entire keyboard
    const blackKeyIndices = [
        1,  // C#
        3,  // D#
        6,  // F#
        8,  // G#
        10, // A#
        13, // C# (second octave)
        15, // D# (second octave)
        18, // F# (second octave)
        20, // G# (second octave)
        22  // A# (second octave)
    ];
    
    return blackKeyIndices[position];
}

        // Add interface updating functions
        function updateSliderValues() {
            D('attack-value').textContent = D('attack').value;
            D('decay-value').textContent = D('decay').value;
            D('sustain-value').textContent = D('sustain').value;
            D('release-value').textContent = D('release').value;
            updateADSRVisualization();
        }

        // ADSR visualization
        function updateADSRVisualization() {
            const attack = parseFloat(D('attack').value);
            const decay = parseFloat(D('decay').value);
            const sustain = parseFloat(D('sustain').value);
            const release = parseFloat(D('release').value);
            
            const graph = D('adsr-visualization');
            const totalTime = attack + decay + 2 + release; // 2 seconds for sustain
            const width = graph.offsetWidth;
            const height = graph.offsetHeight;
            
            // Calculate points for ADSR envelope
            const attackX = (attack / totalTime) * width;
            const decayX = attackX + ((decay / totalTime) * width);
            const releaseStartX = decayX + ((2 / totalTime) * width); // 2 seconds sustain
            const releaseEndX = width;
            
            // Create SVG path for visualization
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            
            // Draw ADSR path
            ctx.beginPath();
            ctx.moveTo(0, height); // Start at bottom left
            ctx.lineTo(attackX, 0); // Attack to peak
            ctx.lineTo(decayX, height - (sustain * height)); // Decay to sustain level
            ctx.lineTo(releaseStartX, height - (sustain * height)); // Sustain
            ctx.lineTo(releaseEndX, height); // Release
            ctx.stroke();
            
            // Update visualization
            graph.innerHTML = '';
            graph.appendChild(canvas);
        }
    
        // Update the voice monitoring display
        // Update the voice display function to handle releasing state
// Update the updateVoiceDisplay function
// Update the updateVoiceDisplay function to also update keyboard
function updateVoiceDisplay() {
    const displayEl = D('voice-display');
    displayEl.innerHTML = '';
    
    // Only count and display notes that are in "playing" state
    const playingNotes = Object.values(activeNotes).filter(
        note => note && note.state === "playing"
    );
    
    // Update count first
    const activeNoteCount = Math.min(playingNotes.length, MAX_POLYPHONY);
    D('voice-count').textContent = activeNoteCount;
    
    // Create display items for keyboard keys
    keys.forEach((key, index) => {
        const voiceItem = document.createElement('div');
        voiceItem.className = 'voice-item';
        voiceItem.textContent = key;
        
        // Only show as active if the note is actually playing
        const isPlaying = playingNotes.some(
            note => note.noteNumber === index
        );
        
        if (isPlaying) {
            voiceItem.classList.add('active-voice');
        }
        
        displayEl.appendChild(voiceItem);
    });

    // Update keyboard visual state
    updateKeyboardDisplay();
}

// you're the best <3 and you should put french fries in my car so that my car smells like fries forever :) - from Asher to Faith
        // Add event listeners for sliders
        D('attack').addEventListener('input', updateSliderValues);
        D('decay').addEventListener('input', updateSliderValues);
        D('sustain').addEventListener('input', updateSliderValues);
        D('release').addEventListener('input', updateSliderValues);

        // Update createNote to use unique IDs instead of note numbers as keys
       

       // Update releaseNote to properly handle keyboard display

    function startNote(noteNumber, audioCtx, destination, buffer) {
    // Create new note
    const note = createNote(noteNumber, buffer, audioCtx, destination);
    
    // Apply ADSR envelope
    const attack = parseFloat(D('attack').value);
    const decay = parseFloat(D('decay').value);
    const sustain = parseFloat(D('sustain').value);
    const now = audioCtx.currentTime;
    
    note.gainNode.gain.setValueAtTime(0, now);
    note.gainNode.gain.linearRampToValueAtTime(1, now + attack);
    note.gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    
    note.state = "playing";
    updateVoiceDisplay();
    return note;
}
// Update releaseNote function to use noteId instead of noteNumber
function releaseNote(noteId, audioCtx) {
  const note = activeNotes[noteId];
  if (!note || note.state !== "playing") {
    console.log("releaseNote: Note", noteId, "is not playing. Skipping release.");
    return;
  }
  
  // If the note is using the processed (crossfaded) buffer, disable looping
  if (note.usesProcessedBuffer) {
    note.looping = false;
    console.log("releaseNote: Disabling looping for processed note", noteId);
  }
  
  note.state = "releasing";
  const release = parseFloat(D('release').value);
  const now = audioCtx.currentTime;
  
  note.gainNode.gain.cancelScheduledValues(now);
  const currentGain = note.gainNode.gain.value;
  note.gainNode.gain.setValueAtTime(currentGain, now);
  note.gainNode.gain.linearRampToValueAtTime(0, now + release);
  
  try {
    note.source.stop(now + release + 0.05);
    console.log("releaseNote: Scheduling stop for note", noteId, "at", now + release + 0.05);
  } catch (e) {
    console.log("releaseNote: Error stopping source for note", noteId, e);
  }
  
  const releaseTimer = setTimeout(() => {
    if (note.state === "releasing") {
      killNote(note.id);
      updateVoiceDisplay();
      console.log("releaseNote: Note", noteId, "has been cleaned up.");
    }
  }, (release * 1000) + 100);
  
  note.releaseTimer = releaseTimer;
  note.scheduledEvents.push({ type: "timeout", id: releaseTimer });
  
  updateVoiceDisplay();
}
// Rename existing noteOn/noteOff to these:
// Update handlePolyNoteOn function
// Update handlePolyNoteOn function
function handlePolyNoteOn(noteNumber) {
    if (!heldNotes.includes(noteNumber)) {
    heldNotes.push(noteNumber);
}

// Gather all notes that are still alive (playing or releasing)
let active = Object.values(activeNotes).filter(
    n => n.state === "playing" || n.state === "releasing"
);

// While we are at or above the poly limit,
// kill the oldest note to free a slot
while (active.length >= MAX_POLYPHONY) {
    // Sort oldest first
    active.sort((a, b) => a.startTime - b.startTime);
    const oldest = active[0];

    // Mark it as "fadingOut" so it won't be counted in active[] next loop
    oldest.state = "fadingOut";
    quickFadeOut(oldest, 0.15); // short forced fade

    // Re-check the active list
    active = Object.values(activeNotes).filter(
        n => n.state === "playing" || n.state === "releasing"
    );
}

// Now that we freed up a slot, start the new note
startNewPolyNote(noteNumber);
updateVoiceDisplay();
}
// Helper to start a note with portamento if needed
function startNewPolyNote(noteNumber) {
    if (isPortamentoOn && lastPlayedNote !== null) {
        const note = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        const startRate = TR2 ** (lastPlayedNote - 12);
        const targetRate = TR2 ** (noteNumber - 12);

        note.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
        note.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    } else {
        startNote(noteNumber, audioCtx, masterGain, audioBuffer);
    }
    lastPlayedNote = noteNumber;
}
// Fix handlePolyNoteOff function
function handlePolyNoteOff(noteNumber) {
    // Remove from held notes
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    // Release all instances of this note
    Object.values(activeNotes).forEach(note => {
        if (note.noteNumber === noteNumber && note.state === "playing") {
            releaseNote(note.id, audioCtx);
        }
    });
    updateVoiceDisplay();
}updateVoiceDisplay();


// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
/**
 * Quickly fades out a note and cleans it up.
 * @param {Object} note - The note object to fade out
 * @param {number} fadeTime - Fade time in seconds (default: 0.05)
 * @returns {Object} - The same note for chaining
 */
 function quickFadeOut(note, fadeTime = 0.05) {
  if (!note || !note.gainNode) return note;
  
  // Update state
  note.state = "fadingOut";
  
  try {
    // Get current time and gain value
    const now = audioCtx.currentTime;
    const currentGain = note.gainNode.gain.value;
    
    // Cancel any scheduled values and set current value
    note.gainNode.gain.cancelScheduledValues(now);
    note.gainNode.gain.setValueAtTime(currentGain, now);
    
    // Ramp down to zero
    note.gainNode.gain.linearRampToValueAtTime(0, now + fadeTime);
    
    // Schedule the note to be killed after the fade
    const killTimer = setTimeout(() => {
      killNote(note.id);
    }, fadeTime * 1000 + 10); // Add 10ms buffer
    
    // Register this timeout in the note's scheduled events
    note.scheduledEvents.push({ type: 'timeout', id: killTimer });
  } 
  catch (e) {
    console.error("Error in quickFadeOut:", e);
    killNote(note.id); // Clean up immediately on error
  }
  
  return note;
}
        // Fix the killNote function
        function killNote(noteId) {
    const note = activeNotes[noteId];
    if (!note) return false;

    // Clean up scheduled events
    note.scheduledEvents.forEach(event => {
        if (event.type === "timeout") {
            clearTimeout(event.id);
        }
    });

    // Stop the source and disconnect nodes
    try {
        note.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
        note.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        if (note.source) {
            note.source.stop(audioCtx.currentTime);
        }
    } catch (e) {
        console.log("Error during cleanup:", e);
    }

    // Remove note from active notes
    delete activeNotes[noteId];
    return true;
}

function updateKeyboardDisplay() {
    // Update all keyboard keys based on active notes
    document.querySelectorAll('.key').forEach(keyElement => {
        const noteIndex = parseInt(keyElement.dataset.noteIndex);
        const isNotePlaying = Object.values(activeNotes).some(
            note => note.noteNumber === noteIndex && note.state === "playing"
        );
        
        keyElement.classList.toggle('pressed', isNotePlaying);
    });
}

// Update noteOn to handle polyphony with unique note instances
// Update noteOn to ensure proper mode handling
function noteOn(noteNumber) {
    if (!audioBuffer) {
        console.error("No audio buffer available!");
        return;
    }

    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
    updateKeyboardDisplay();
}

function noteOff(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOff(noteNumber);
    } else {
        handlePolyNoteOff(noteNumber);
    }
    updateKeyboardDisplay();
}

document.onkeydown = function(e) {
  // Stop repeated keydown events
  if (e.repeat) return;

  const upperKey = e.key.toUpperCase();
  console.log("Key pressed:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && !keyStates[upperKey]) {
    console.log("Mapped to note index:", keys.indexOf(upperKey));
    keyStates[upperKey] = true;
    noteOn(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && !keyStates[e.key]) {
    console.log("Special key pressed:", e.key, "=> Note index:", specialKeyMap[e.key]);
    keyStates[e.key] = true;
    noteOn(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

document.onkeyup = function(e) {
  const upperKey = e.key.toUpperCase();
  console.log("Key released:", e.key);

  // 1) Check main keys array (letters/digits)
  if (keys.includes(upperKey) && keyStates[upperKey]) {
    console.log("Released from array:", upperKey);
    keyStates[upperKey] = false;
    noteOff(keys.indexOf(upperKey));
    updateKeyboardDisplay();
    return;
  }

  // 2) Check punctuation map
  if (Object.prototype.hasOwnProperty.call(specialKeyMap, e.key) && keyStates[e.key]) {
    console.log("Released special key:", e.key);
    keyStates[e.key] = false;
    noteOff(specialKeyMap[e.key]);
    updateKeyboardDisplay();
  }
};

// Update the keyboard generation to use correct note triggering
function generateKeyboard() {
    const keyboard = D('keyboard');
    keyboard.innerHTML = '';

    // Create white keys first
    const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B', 
                      'C', 'D', 'E', 'F', 'G', 'A', 'B']; // Two octaves
    
    for (let i = 0; i < whiteKeys.length; i++) {
        const key = document.createElement('div');
        key.className = 'key';
        // Map to the correct index in the keys array
        const keyIndex = getWhiteKeyIndex(i);
        key.dataset.noteIndex = keyIndex;
        keyboard.appendChild(key);
        
        // Add mouse events
        key.addEventListener('mousedown', () => {
            noteOn(parseInt(key.dataset.noteIndex));
            key.classList.add('pressed');
        });
        
        key.addEventListener('mouseup', () => {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        });
        
        key.addEventListener('mouseleave', () => {
            if (key.classList.contains('pressed')) {
                noteOff(parseInt(key.dataset.noteIndex));
                key.classList.remove('pressed');
            }
        });
    }

      // Create black keys
      for (let i = 0; i < 10; i++) { // 5 black keys per octave, 2 octaves
        const key = document.createElement('div');
        key.className = 'key black';
        const keyIndex = getBlackKeyIndex(i);
        key.dataset.noteIndex = keyIndex;
        
        key.addEventListener('mousedown', () => {
            noteOn(parseInt(key.dataset.noteIndex));
            key.classList.add('pressed');
        });
        
        key.addEventListener('mouseup', () => {
            noteOff(parseInt(key.dataset.noteIndex));
            key.classList.remove('pressed');
        });
        
        key.addEventListener('mouseleave', () => {
            if (key.classList.contains('pressed')) {
                noteOff(parseInt(key.dataset.noteIndex));
                key.classList.remove('pressed');
            }
        });
        
        keyboard.appendChild(key);
    }
}


function handleFileSelect(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            audioCtx.decodeAudioData(e.target.result, function(buffer) {
                audioBuffer = buffer;
                
                // Process fades and crossfades whenever a new sample is loaded
                updateSampleProcessing();
                
                // Reset cached crossfade buffer when loading a new sample
                cachedCrossfadedBuffer = null;
                lastCachedStartPos = null;
                lastCachedEndPos = null;
                lastCachedCrossfade = null;
                
                // Create new source node
                if (sampleSource) {
                    sampleSource.stop();
                }
                sampleSource = audioCtx.createBufferSource();
                sampleSource.buffer = buffer;
                
                // Connect the audio chain
                sampleSource.connect(sampleGainNode);
                sampleSource.start();
                
                // Update the label text to show the file name
                const fileLabel = document.querySelector('label[for="audio-file"]');
                if (fileLabel) {
                    // Truncate filename if too long
                    const maxLength = 12;
                    const displayName = file.name.length > maxLength ? 
                        file.name.substring(0, maxLength-3) + '...' : 
                        file.name;
                    fileLabel.textContent = displayName;
                }
                
                // Create crossfaded buffer if needed
                if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
                    console.log("Creating crossfaded buffer for newly loaded sample");
                    const result = createCrossfadedBuffer(
                        buffer, 
                        sampleStartPosition, 
                        sampleEndPosition, 
                        sampleCrossfadeAmount
                    );
                    
                    if (result && result.buffer) {
                        console.log("Successfully created crossfaded buffer for new sample");
                        cachedCrossfadedBuffer = result.buffer;
                        lastCachedStartPos = sampleStartPosition;
                        lastCachedEndPos = sampleEndPosition;
                        lastCachedCrossfade = sampleCrossfadeAmount;
                    }
                }
                
                // Update any active notes to use the new buffer
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        // Skip held notes to avoid interruption
                        if (heldNotes.includes(note.noteNumber)) {
                            console.log(`Note ${note.id} is held; will update on release.`);
                            return;
                        }
                        
                        console.log(`Updating note ${note.id} to use new sample`);
                        note.usesProcessedBuffer = false;
                        note.crossfadeActive = false;
                        
                        if (isSampleLoopOn) {
                            note.looping = true; 
                            setupLoopCrossfade(note);
                        }
                        updateSamplePlaybackParameters(note);
                    }
                });
            });
        };
        reader.readAsArrayBuffer(file);
    }
}

function checkAudioAvailable() {
    if (!audioBuffer) {
        console.warn("No audio buffer available - load a sample first!");
        return false;
    }
    return true;
}

        D('audio-file').addEventListener('change', handleFileSelect);
        
        // Clean up everything
        function cleanupAllNotes() {
            for (const noteNum in activeNotes) {
                killNote(parseInt(noteNum));
            }
            
            // Reset all key states
            for (const key in keyStates) {
                keyStates[key] = false;
            }
            
            updateVoiceDisplay();
        }

        // Add additional safety with blur/focus event handling
        window.addEventListener('blur', cleanupAllNotes);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cleanupAllNotes();
            }
        });

        // Initialize interface
        generateKeyboard();
        updateSliderValues();
        updateVoiceDisplay();
        updateADSRVisualization();

        document.addEventListener('DOMContentLoaded', () => {
    // Initialize all knobs with placeholder functionality
    const knobInitializations = {
        'osc1-pwm-knob': (value) => console.log('OSC1 PWM:', value.toFixed(2)),
        'osc1-gain-knob': (value) => console.log('OSC1 Gain:', value.toFixed(2)),
        'osc2-pwm-knob': (value) => console.log('OSC2 PWM:', value.toFixed(2)),
        'osc2-gain-knob': (value) => console.log('OSC2 Gain:', value.toFixed(2)),
        'vcf-cutoff-knob': (value) => console.log('VCF Cutoff:', value.toFixed(2)),
        'vcf-resonance-knob': (value) => console.log('VCF Resonance:', value.toFixed(2)),
        'lfo-rate-knob': (value) => console.log('LFO Rate:', value.toFixed(2)),
        'arp-rate-knob': (value) => console.log('ARP Rate:', value.toFixed(2)),
        'sample-volume-knob': (value) => {
            if (sampleGainNode) {
                sampleGainNode.gain.setValueAtTime(value, audioCtx.currentTime);
                console.log('Sample Gain:', value.toFixed(2));
            }
        }
    };
});

    // Initialize all regular knobs
    Object.entries(knobInitializations).forEach(([id, callback]) => {
        const knob = D(id);
        if (knob) {
            const control = initializeKnob(knob, callback);
            control.setValue(0.5); // Set initial position
        }
    });

    // Initialize octave knobs
    ['osc1-octave-knob', 'osc2-octave-knob'].forEach(id => {
        const knob = D(id);
        const valueId = id.replace('-knob', '-value');
        if (knob) {
            const control = initializeNotchedKnob(knob, (value) => {
                D(valueId).textContent = value > 0 ? `+${value}` : value;
                console.log(`${id} octave:`, value);
            });
            control.setValue(0); // Set initial position to center
        }
    });

// Add tooltip creation function
function createTooltip() {
    const tooltip = document.createElement('div');
    tooltip.id = 'pitch-tooltip';
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    // Position tooltip near the pitch knob
    const knob = D('sample-pitch-knob');
    const knobRect = knob.getBoundingClientRect();
    tooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
    tooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
    
    return tooltip;
}
function createTooltipForKnob(knobId, value) {
    const tooltip = document.getElementById(`${knobId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${knobId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        
        // Position tooltip near its knob
        const knob = D(knobId);
        const knobRect = knob.getBoundingClientRect();
        newTooltip.style.left = `${knobRect.left + knobRect.width + 5}px`;
        newTooltip.style.top = `${knobRect.top + (knobRect.height / 2) - 10}px`;
        
        return newTooltip;
    })();
    
    return tooltip;
}
function initializeOctaveSlider(slider, onChange) {
    const handle = slider.querySelector('.octave-slider-handle');
    const sliderHeight = slider.offsetHeight - handle.offsetHeight;
    const positions = 5; // -2 to +2
    const stepSize = sliderHeight / (positions - 1);
    let currentPosition = 2; // Start at middle (0)
    
    // Set initial position
    handle.style.top = (currentPosition * stepSize) + 'px';
    
    function snapToPosition(y) {
        const relativeY = y - slider.getBoundingClientRect().top;
        let position = Math.round(relativeY / stepSize);
        position = Math.max(0, Math.min(positions - 1, position));
        return position;
    }
    
    function updatePosition(position) {
        handle.style.top = (position * stepSize) + 'px';
        const value = 2 - position; // Convert position to octave value
        if (onChange) onChange(value);
    }
    
    let isDragging = false;
    
    handle.addEventListener('mousedown', (e) => {
        isDragging = true;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const position = snapToPosition(e.clientY);
        updatePosition(position);
        currentPosition = position;
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
        }
    });
    
    // Initialize at center position (0 octave)
    updatePosition(2);
    
    return {
        setValue: (octave) => {
            const position = 2 - octave; // Convert octave value to position
            updatePosition(Math.max(0, Math.min(positions - 1, position)));
        }
    };
}
// Update the document mouseup handler to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});

function initializePrecisionSlider(slider) {
    let lastY;
    let isDragging = false;
    const range = parseFloat(slider.max) - parseFloat(slider.min);
    const totalHeight = 120; // Height of slider in pixels
    
    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Calculate sensitivity based on shift key
        const sensitivity = e.shiftKey ? 0.2 : 1.0;
        const deltaY = (lastY - e.clientY) * sensitivity;
        lastY = e.clientY;
        
        // Calculate value change
        const valueChange = (deltaY / totalHeight) * range;
        const currentValue = parseFloat(slider.value);
        let newValue = currentValue + valueChange;
        
        // Clamp to min/max
        newValue = Math.min(Math.max(newValue, slider.min), slider.max);
        
        // Update slider value
        slider.value = newValue;
        
        // Trigger input event for ADSR visualization
        slider.dispatchEvent(new Event('input'));
        
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }
    
    slider.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastY = e.clientY;
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        e.preventDefault();
    });
}

// Initialize precision control for ADSR sliders
document.addEventListener('DOMContentLoaded', () => {
    ['attack', 'decay', 'sustain', 'release'].forEach(id => {
        const slider = D(id);
        if (slider) {
            initializePrecisionSlider(slider);
        }
    });
});

// Add to your global variables
let isMonoMode = false;
let isLegatoMode = false;
let isPortamentoOn = false;
let glideTime = 0.1; // seconds
let heldNotes = []; // Keep track of held notes in mono mode
let currentNote = null; // Currently sounding note in mono mode


// Add to initializeSwitch function
function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
    let isDragging = false;
    let isActive = false;
    
    // Create tooltip for this switch
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    document.body.appendChild(tooltip);
    
    function updateTooltip() {
        const switchRect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${switchRect.left + switchRect.width + 5}px`;
        tooltip.style.top = `${switchRect.top + (switchRect.height / 2) - 10}px`;
        tooltip.textContent = isActive ? options.onText : options.offText;
        tooltip.style.opacity = '1';
    }
    
    function handleMouseDown(e) {
        isDragging = true;
        switchEl.style.cursor = 'grabbing';
        updateTooltip();
        e.preventDefault();
    }
    
    function handleMouseUp() {
        isDragging = false;
        switchEl.style.cursor = 'grab';
        tooltip.style.opacity = '0';
    }
    
    function handleClick() {
        isActive = !isActive;
        switchEl.classList.toggle('active');
        updateTooltip();
        return isActive;
    }
    
    switchEl.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    switchEl.addEventListener('click', handleClick);
    
    return {
        getValue: () => isActive,
        setValue: (value) => {
            isActive = value;
            switchEl.classList.toggle('active', isActive);
            updateTooltip();
        }
    };
}

// Update switch initialization with custom text
function initializeSwitches() {
    // Initialize all switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
    const switches = {
        'voice-mode-switch': {
            // ... existing code ...
        },
        'trigger-mode-switch': {
            // ... existing code ...
        },
        'portamento-switch': {
            // ... existing code ...
        },
        'sample-loop-switch': {
            onText: 'LOOP ON',
            offText: 'LOOP OFF',
            onChange: (active) => {
                isSampleLoopOn = active;
                
                // Update any playing samples
                Object.values(activeNotes).forEach(note => {
                    if (note && note.source) {
                        updateSamplePlaybackParameters(note);
                    }
                });
                
                console.log('Sample Loop:', active ? 'ON' : 'OFF');
            }
        }
    };
    // Rest of the initialization code remains the same...
}

// Initialize the switches
function initializeSwitches() {
    function initializeSwitch(switchEl) {
        let isDragging = false;
        let isActive = false;
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
            }
        };
    }
    
    // Initialize all switches
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'));
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'));
    const portamentoSwitch = initializeSwitch(D('portamento-switch'));
    
    // Handle voice mode changes
    voiceModeSwitch.onChange = (isActive) => {
        isMonoMode = isActive;
        cleanupAllNotes();
    };
    
    // Handle trigger mode changes
    triggerModeSwitch.onChange = (isActive) => {
        isLegatoMode = isActive;
    };
    
    // Handle portamento changes
    portamentoSwitch.onChange = (isActive) => {
        isPortamentoOn = isActive;
    };
}

// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});

        // Update noteOn function to handle mono mode
function noteOn(noteNumber) {
    if (isMonoMode) {
        handleMonoNoteOn(noteNumber);
    } else {
        handlePolyNoteOn(noteNumber);
    }
}
// Fix for voice limiting in mono mode
function handleMonoNoteOn(noteNumber) {
    if (!checkAudioAvailable()) return;
    
    // Add note to held notes
    if (!heldNotes.includes(noteNumber)) {
        heldNotes.push(noteNumber);
    }
    
    // Clean up any stale notes that aren't the current note
    Object.values(activeNotes).forEach(note => {
        if (note !== currentNote && note.state === "releasing") {
            quickFadeOut(note, 0.015);
        }
    });

    const shouldTrigger = !isLegatoMode || !currentNote;
    const shouldGlide = isPortamentoOn && lastPlayedNote !== null;

    if (shouldTrigger) {
        if (currentNote) {
            const prevNote = currentNote;
            quickFadeOut(prevNote, 0.015);
            setTimeout(() => {
                // Make sure we're really in mono mode - kill any remaining notes
                Object.values(activeNotes).forEach(note => {
                    if (note !== prevNote) {
                        killNote(note.id);
                    }
                });
                
                currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
                
                if (shouldGlide) {
                    const startRate = TR2 ** (lastPlayedNote - 12);
                    const targetRate = TR2 ** (noteNumber - 12);
                    currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
                    currentNote.source.playbackRate.linearRampToValueAtTime(
                        targetRate,
                        audioCtx.currentTime + glideTime
                    );
                }
                updateVoiceDisplay();
            }, 20);
            return;
        }
        
        currentNote = startNote(noteNumber, audioCtx, masterGain, audioBuffer);
        if (shouldGlide) {
            const startRate = TR2 ** (lastPlayedNote - 12);
            const targetRate = TR2 ** (noteNumber - 12);
            currentNote.source.playbackRate.setValueAtTime(startRate, audioCtx.currentTime);
            currentNote.source.playbackRate.linearRampToValueAtTime(
                targetRate,
                audioCtx.currentTime + glideTime
            );
        }
    } else if (currentNote) {
        // Handle pitch changes in legato mode
        currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
        const currentRate = currentNote.source.playbackRate.value;
        const targetRate = TR2 ** (noteNumber - 12);
        
        currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
        currentNote.source.playbackRate.linearRampToValueAtTime(
            targetRate,
            audioCtx.currentTime + glideTime
        );
    }

    lastPlayedNote = noteNumber;
    updateVoiceDisplay();
}

// Update handleMonoNoteOff function
function handleMonoNoteOff(noteNumber) {
    // Remove note from held notes array
    heldNotes = heldNotes.filter(n => n !== noteNumber);

    if (heldNotes.length > 0) {
        // If there are still held notes, move to the last pressed note
        const lastNote = heldNotes[heldNotes.length - 1];

        if (!isLegatoMode) {
            // In multi-trigger mode, only retrigger if we're releasing the currently playing note
            if (currentNote && currentNote.noteNumber === noteNumber) {
                quickFadeOut(currentNote);
                setTimeout(() => {
                    currentNote = startNote(lastNote, audioCtx, masterGain, audioBuffer);
                    updateVoiceDisplay();
                }, 20);
            }
        } else {
            // In legato mode, glide if needed
            if (currentNote) {
                currentNote.source.playbackRate.cancelScheduledValues(audioCtx.currentTime);
                const currentRate = currentNote.source.playbackRate.value;
                const targetRate = TR2 ** (lastNote - 12);
                
                currentNote.source.playbackRate.setValueAtTime(currentRate, audioCtx.currentTime);
                currentNote.source.playbackRate.linearRampToValueAtTime(
                    targetRate,
                    audioCtx.currentTime + glideTime
                );
            }
        }
    } else {
        if (currentNote) {
            releaseNote(currentNote.id, audioCtx);
            currentNote = null;
        }
    }

    updateVoiceDisplay();
}
// Initialize switches on DOM load
document.addEventListener('DOMContentLoaded', () => {
    initializeSwitches();
});
function initializeSampleLoopSwitch() {
  const loopSwitch = document.getElementById('sample-loop-switch');
  if (!loopSwitch) return;

  // Toggle “active” class on click
  loopSwitch.addEventListener('click', () => {
    loopSwitch.classList.toggle('active');
    isSampleLoopOn = loopSwitch.classList.contains('active');
    // Update any playing samples
    Object.values(activeNotes).forEach(note => {
      if (note.source) updateSamplePlaybackParameters(note);
    });
    console.log('Sample Loop:', isSampleLoopOn ? 'ON' : 'OFF');
  });
}
document.addEventListener('DOMContentLoaded', () => {
  // Call this after other setup
  initializeSampleLoopSwitch();
});
// Add this function for switch tooltips
function createTooltipForSwitch(switchId, options = { onText: 'ON', offText: 'OFF' }) {
    const tooltip = document.getElementById(`${switchId}-tooltip`) || (() => {
        const newTooltip = document.createElement('div');
        newTooltip.id = `${switchId}-tooltip`;
        newTooltip.className = 'tooltip';
        document.body.appendChild(newTooltip);
        return newTooltip;
    })();
    
    // Position tooltip near its switch
    const switchEl = D(switchId);
    if (switchEl) {
        const rect = switchEl.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width + 5}px`;
        tooltip.style.top = `${rect.top + (rect.height / 2) - 10}px`;
    }
    
    return tooltip;
}

function initializeSwitches() {
    function initializeSwitch(switchEl, options = { onText: 'ON', offText: 'OFF' }) {
        let isDragging = false;
        let isActive = false;
        
        function updateTooltip() {
            const tooltip = createTooltipForSwitch(switchEl.id, options);
            tooltip.textContent = isActive ? options.onText : options.offText;
            tooltip.style.opacity = '1';
        }
        
        function handleMouseDown(e) {
            isDragging = true;
            switchEl.style.cursor = 'grabbing';
            updateTooltip();
            e.preventDefault();
        }
        
        function handleMouseUp() {
            isDragging = false;
            switchEl.style.cursor = 'grab';
        }
        
        function handleClick() {
            isActive = !isActive;
            switchEl.classList.toggle('active');
            updateTooltip();
            return isActive;
        }
        
        switchEl.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        switchEl.addEventListener('click', handleClick);
        
        return {
            getValue: () => isActive,
            setValue: (value) => {
                isActive = value;
                switchEl.classList.toggle('active', isActive);
                updateTooltip();
            }
        };
    }
    
    // Initialize switches with custom tooltip text
    const voiceModeSwitch = initializeSwitch(D('voice-mode-switch'), {
        onText: 'MONO',
        offText: 'POLY'
    });
    
    const triggerModeSwitch = initializeSwitch(D('trigger-mode-switch'), {
        onText: 'LEGATO',
        offText: 'MULTI'
    });
    
    const portamentoSwitch = initializeSwitch(D('portamento-switch'), {
        onText: 'PORTA ON',
        offText: 'PORTA OFF'
    });
}

// Update document mouseup to hide all tooltips
document.addEventListener('mouseup', () => {
    document.querySelectorAll('.tooltip').forEach(tooltip => {
        tooltip.style.opacity = '0';
    });
});

function initializeSwitches() {
    const switches = {
        'voice-mode-switch': {
            onText: 'MONO',
            offText: 'POLY',
            onChange: (active) => {
                isMonoMode = active;
                cleanupAllNotes();
                console.log('Voice Mode:', active ? 'MONO' : 'POLY');
            }
        },
        'trigger-mode-switch': {
            onText: 'LEGATO',
            offText: 'MULTI',
            onChange: (active) => {
                isLegatoMode = active;
                console.log('Trigger Mode:', active ? 'LEGATO' : 'MULTI');
            }
        },
        'portamento-switch': {
            onText: 'PORTA ON',
            offText: 'PORTA OFF',
            onChange: (active) => {
                isPortamentoOn = active;
                console.log('Portamento:', active ? 'ON' : 'OFF');
            }
        }
    };

    Object.entries(switches).forEach(([id, config]) => {
        const switchEl = D(id);
        if (!switchEl) return;

        let isActive = false;
        
        function updateSwitch() {
            switchEl.classList.toggle('active', isActive);
            const tooltip = createTooltipForSwitch(id);
            tooltip.textContent = isActive ? config.onText : config.offText;
            tooltip.style.opacity = '1';
            config.onChange(isActive);
        }

        switchEl.addEventListener('click', () => {
            isActive = !isActive;
            updateSwitch();
        });

        switchEl.addEventListener('mousedown', (e) => {
            const tooltip = createTooltipForSwitch(id);
            tooltip.textContent = isActive ? config.onText : config.offText;
            tooltip.style.opacity = '1';
            e.preventDefault();
        });
    });
}
// JavaScript for sample selector dropdown
document.addEventListener('DOMContentLoaded', function() {
  const selectorBtn = document.getElementById('sample-selector-btn');
  const dropdown = document.getElementById('sample-dropdown');
  const dropdownItems = document.querySelectorAll('.dropdown-item');
  
  // Toggle dropdown when clicking the button
  selectorBtn.addEventListener('click', function() {
    dropdown.classList.toggle('show');
    event.stopPropagation();
  });
  
  // Close dropdown when clicking outside
  window.addEventListener('click', function() {
    if (dropdown.classList.contains('show')) {
      dropdown.classList.remove('show');
    }
  });
  
  // Handle preset sample selection
  dropdownItems.forEach(item => {
    item.addEventListener('click', function() {
      const sampleName = this.getAttribute('data-sample');
      loadPresetSample(sampleName);
      dropdown.classList.remove('show');
    });
  });
});

// Function to load preset samples
function loadPresetSample(filename) {
  console.log(`Loading preset sample: ${filename}`);
  
  // Build the URL to the sample file
  const sampleUrl = `samples/${filename}`;
  
  // Fetch the sample file
  fetch(sampleUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load sample: ${response.status} ${response.statusText}`);
      }
      return response.arrayBuffer();
    })
    .then(arrayBuffer => {
      // Decode the audio data
      return audioCtx.decodeAudioData(arrayBuffer);
    })
    .then(buffer => {
    // Use the buffer as the sample
    audioBuffer = buffer;
    
    // Process fades and crossfades whenever a new preset is loaded
    updateSampleProcessing();
    
    // Rest of the function...
      
      // Reset cached crossfade buffer when loading a new sample
      cachedCrossfadedBuffer = null;
      lastCachedStartPos = null;
      lastCachedEndPos = null;
      lastCachedCrossfade = null;
      
      // Create new source node
      if (sampleSource) {
        sampleSource.stop();
      }
      sampleSource = audioCtx.createBufferSource();
      sampleSource.buffer = buffer;
      
      // Connect the audio chain
      sampleSource.connect(sampleGainNode);
      sampleSource.start();
      
      // Update the label to show the loaded sample name
      const fileLabel = document.querySelector('label[for="audio-file"]');
      if (fileLabel) {
        fileLabel.textContent = filename.substring(0, 10) + (filename.length > 10 ? '...' : '');
      }
      
      // Create crossfaded buffer if needed
      if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
        console.log("Creating crossfaded buffer for preset sample");
        const result = createCrossfadedBuffer(
          buffer, 
          sampleStartPosition, 
          sampleEndPosition, 
          sampleCrossfadeAmount
        );
        
        if (result && result.buffer) {
          console.log("Successfully created crossfaded buffer for preset sample");
          cachedCrossfadedBuffer = result.buffer;
          lastCachedStartPos = sampleStartPosition;
          lastCachedEndPos = sampleEndPosition;
          lastCachedCrossfade = sampleCrossfadeAmount;
        }
      }
      
      // Update any active notes to use the new buffer
      Object.values(activeNotes).forEach(note => {
        if (note && note.source) {
          // Skip held notes to avoid interruption
          if (heldNotes.includes(note.noteNumber)) {
            console.log(`Note ${note.id} is held; will update on release.`);
            return;
          }
          
          console.log(`Updating note ${note.id} to use new preset sample`);
          note.usesProcessedBuffer = false;
          note.crossfadeActive = false;
          
          if (isSampleLoopOn) {
            note.looping = true; 
            setupLoopCrossfade(note);
          }
          updateSamplePlaybackParameters(note);
        }
      });
    })
    .catch(error => {
      console.error('Error loading preset sample:', error);
      alert(`Failed to load sample: ${filename}`);
    });
}
// Function to process the buffer with fade in/out effects
function processBufferWithFades() {
    if (!audioBuffer) return null;
    
    console.log("Processing buffer with fades:", {
        fadeIn: sampleFadeInAmount, 
        fadeOut: sampleFadeOutAmount,
        start: sampleStartPosition,
        end: sampleEndPosition
    });
    
    // Skip processing if no fades needed
    if (sampleFadeInAmount < 0.01 && sampleFadeOutAmount < 0.01) {
        fadedBuffer = null;
        return audioBuffer;
    }
    
    try {
        const originalBuffer = audioBuffer;
        const sampleRate = originalBuffer.sampleRate;
        const channels = originalBuffer.numberOfChannels;
        const totalSamples = originalBuffer.length;
        
        // Calculate trim points based on start/end positions
        const startSample = Math.floor(sampleStartPosition * totalSamples);
        const endSample = Math.floor(sampleEndPosition * totalSamples);
        const trimmedLength = Math.max(2, endSample - startSample);
        
        // Create a new buffer with EXACT same length as the trimmed region
        const processedBuffer = audioCtx.createBuffer(
            channels,
            trimmedLength,
            sampleRate
        );
        
        // Copy EXACT trimmed data - no additional trimming
        for (let channel = 0; channel < channels; channel++) {
            const origData = originalBuffer.getChannelData(channel);
            const newData = processedBuffer.getChannelData(channel);
            
            for (let i = 0; i < trimmedLength; i++) {
                newData[i] = origData[startSample + i];
            }
        }
        
        // Calculate fade lengths but don't change the overall buffer length
        let fadeInSamples = 0;
        let fadeOutSamples = 0;
        
        if (sampleFadeInAmount > 0.01) {
            fadeInSamples = Math.floor(trimmedLength * sampleFadeInAmount);
        }
        
        if (sampleFadeOutAmount > 0.01) {
            fadeOutSamples = Math.floor(trimmedLength * sampleFadeOutAmount);
        }
        
        // Make sure fades don't overlap
        const totalFadeLength = fadeInSamples + fadeOutSamples;
        if (totalFadeLength > trimmedLength) {
            const scale = trimmedLength / totalFadeLength * 0.95; // 5% safety margin
            fadeInSamples = Math.floor(fadeInSamples * scale);
            fadeOutSamples = Math.floor(fadeOutSamples * scale);
        }
        
        console.log(`Applying fades: In=${fadeInSamples} samples, Out=${fadeOutSamples} samples, Total length=${trimmedLength} samples`);
        
        // Apply fades with exponential curves while preserving buffer length
        for (let channel = 0; channel < channels; channel++) {
            const newData = processedBuffer.getChannelData(channel);
            
            // Apply fade in
            if (fadeInSamples > 0) {
                const fadeInCurve = 2; // Higher = more exponential curve
                for (let i = 0; i < fadeInSamples; i++) {
                    const fadeRatio = i / fadeInSamples;
                    const fadeGain = Math.pow(fadeRatio, fadeInCurve);
                    newData[i] *= fadeGain;
                }
            }
            
            // Apply fade out - starts at the end minus fadeOutSamples
            if (fadeOutSamples > 0) {
                const fadeOutCurve = 2; // Higher = more exponential curve
                for (let i = 0; i < fadeOutSamples; i++) {
                    const sampleIndex = trimmedLength - fadeOutSamples + i;
                    if (sampleIndex >= 0) { // Safety check
                        const fadeRatio = 1 - (i / fadeOutSamples);
                        const fadeGain = Math.pow(fadeRatio, fadeOutCurve);
                        newData[sampleIndex] *= fadeGain;
                    }
                }
            }
        }
        
        // Store the processed buffer
        fadedBuffer = processedBuffer;
        
        // Reset the crossfaded buffer cache
        cachedCrossfadedBuffer = null;
        lastCachedStartPos = null;
        lastCachedEndPos = null;
        lastCachedCrossfade = null;
        
        console.log("Fade processing complete, buffer length maintained:", trimmedLength);
        return processedBuffer;
    } 
    catch (e) {
        console.error("Error processing buffer:", e);
        fadedBuffer = null;
        return audioBuffer;
    }
}
// Add this function to trigger fade processing whenever needed
function updateSampleProcessing() {
  console.log("Updating sample processing...");
  
  // First reset cached buffers
  fadedBuffer = null;
  cachedCrossfadedBuffer = null;
  lastCachedStartPos = null;
  lastCachedEndPos = null;
  lastCachedCrossfade = null;
  
  // Process in sequence with safety checks
  setTimeout(() => {
    if (audioBuffer) {
      // Process fades first
      const processedBuffer = processBufferWithFades();
      
      // Then handle crossfades if needed
      setTimeout(() => {
        if (isSampleLoopOn && sampleCrossfadeAmount > 0.01) {
          const result = createCrossfadedBuffer(
            processedBuffer, 
            sampleStartPosition, 
            sampleEndPosition, 
            sampleCrossfadeAmount
          );
          
          if (result && result.buffer) {
            cachedCrossfadedBuffer = result.buffer;
            lastCachedStartPos = sampleStartPosition;
            lastCachedEndPos = sampleEndPosition;
            lastCachedCrossfade = sampleCrossfadeAmount;
            
            console.log("Sample processing complete with crossfades");
          }
        } else {
          console.log("Sample processing complete without crossfades");
        }
      }, 10);
    }
  }, 10);
}
    </script>
</body>
</html>